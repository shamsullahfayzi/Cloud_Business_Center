[
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typing",
        "description": "typing",
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Protocol",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "BinaryIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Text",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "runtime_checkable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Protocol",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "BinaryIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "jwt",
        "importPath": "jose",
        "description": "jose",
        "isExtraImport": true,
        "detail": "jose",
        "documentation": {}
    },
    {
        "label": "jwt",
        "importPath": "jose",
        "description": "jose",
        "isExtraImport": true,
        "detail": "jose",
        "documentation": {}
    },
    {
        "label": "JWTError",
        "importPath": "jose",
        "description": "jose",
        "isExtraImport": true,
        "detail": "jose",
        "documentation": {}
    },
    {
        "label": "jwt",
        "importPath": "jose",
        "description": "jose",
        "isExtraImport": true,
        "detail": "jose",
        "documentation": {}
    },
    {
        "label": "CryptContext",
        "importPath": "passlib.context",
        "description": "passlib.context",
        "isExtraImport": true,
        "detail": "passlib.context",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "urandom",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Mapped",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "mapped_column",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "TokenResponse",
        "importPath": "app.crud.login",
        "description": "app.crud.login",
        "isExtraImport": true,
        "detail": "app.crud.login",
        "documentation": {}
    },
    {
        "label": "process_login",
        "importPath": "app.crud.login",
        "description": "app.crud.login",
        "isExtraImport": true,
        "detail": "app.crud.login",
        "documentation": {}
    },
    {
        "label": "TokenResponse",
        "importPath": "app.crud.login",
        "description": "app.crud.login",
        "isExtraImport": true,
        "detail": "app.crud.login",
        "documentation": {}
    },
    {
        "label": "process_login",
        "importPath": "app.crud.login",
        "description": "app.crud.login",
        "isExtraImport": true,
        "detail": "app.crud.login",
        "documentation": {}
    },
    {
        "label": "TokenResponse",
        "importPath": "app.crud.login",
        "description": "app.crud.login",
        "isExtraImport": true,
        "detail": "app.crud.login",
        "documentation": {}
    },
    {
        "label": "process_login",
        "importPath": "app.crud.login",
        "description": "app.crud.login",
        "isExtraImport": true,
        "detail": "app.crud.login",
        "documentation": {}
    },
    {
        "label": "LoginRequest",
        "importPath": "app.models.login_model",
        "description": "app.models.login_model",
        "isExtraImport": true,
        "detail": "app.models.login_model",
        "documentation": {}
    },
    {
        "label": "LoginRequest",
        "importPath": "app.models.login_model",
        "description": "app.models.login_model",
        "isExtraImport": true,
        "detail": "app.models.login_model",
        "documentation": {}
    },
    {
        "label": "LoginRequest",
        "importPath": "app.models.login_model",
        "description": "app.models.login_model",
        "isExtraImport": true,
        "detail": "app.models.login_model",
        "documentation": {}
    },
    {
        "label": "SalesmanBase",
        "importPath": "app.models.salesman",
        "description": "app.models.salesman",
        "isExtraImport": true,
        "detail": "app.models.salesman",
        "documentation": {}
    },
    {
        "label": "SalesmanBase",
        "importPath": "app.models.salesman",
        "description": "app.models.salesman",
        "isExtraImport": true,
        "detail": "app.models.salesman",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ConfigDict",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "EmailStr",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ConfigDict",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "EmailStr",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ConfigDict",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ConfigDict",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ConfigDict",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "EmailStr",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "EmailStr",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ConfigDict",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ConfigDict",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ConfigDict",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ConfigDict",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "EmailStr",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "SQLAlchemyError",
        "importPath": "sqlalchemy.exc",
        "description": "sqlalchemy.exc",
        "isExtraImport": true,
        "detail": "sqlalchemy.exc",
        "documentation": {}
    },
    {
        "label": "ProductBase",
        "importPath": "app.models.product",
        "description": "app.models.product",
        "isExtraImport": true,
        "detail": "app.models.product",
        "documentation": {}
    },
    {
        "label": "ProductResponse",
        "importPath": "app.models.product",
        "description": "app.models.product",
        "isExtraImport": true,
        "detail": "app.models.product",
        "documentation": {}
    },
    {
        "label": "ProductBase",
        "importPath": "app.models.product",
        "description": "app.models.product",
        "isExtraImport": true,
        "detail": "app.models.product",
        "documentation": {}
    },
    {
        "label": "Response_Product_Create",
        "importPath": "app.models.response_product_create",
        "description": "app.models.response_product_create",
        "isExtraImport": true,
        "detail": "app.models.response_product_create",
        "documentation": {}
    },
    {
        "label": "Response_Product_Create",
        "importPath": "app.models.response_product_create",
        "description": "app.models.response_product_create",
        "isExtraImport": true,
        "detail": "app.models.response_product_create",
        "documentation": {}
    },
    {
        "label": "ShipmentBase",
        "importPath": "app.models.shipment",
        "description": "app.models.shipment",
        "isExtraImport": true,
        "detail": "app.models.shipment",
        "documentation": {}
    },
    {
        "label": "WarehouseBase",
        "importPath": "app.models.warehouse",
        "description": "app.models.warehouse",
        "isExtraImport": true,
        "detail": "app.models.warehouse",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "MetaData",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Date",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Float",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Date",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Float",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Date",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Date",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Float",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Date",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Float",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.ext.declarative",
        "description": "sqlalchemy.ext.declarative",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.declarative",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.ext.declarative",
        "description": "sqlalchemy.ext.declarative",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.declarative",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.ext.declarative",
        "description": "sqlalchemy.ext.declarative",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.declarative",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.ext.declarative",
        "description": "sqlalchemy.ext.declarative",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.declarative",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.ext.declarative",
        "description": "sqlalchemy.ext.declarative",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.declarative",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.ext.declarative",
        "description": "sqlalchemy.ext.declarative",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.declarative",
        "documentation": {}
    },
    {
        "label": "URL",
        "importPath": "sqlalchemy.engine",
        "description": "sqlalchemy.engine",
        "isExtraImport": true,
        "detail": "sqlalchemy.engine",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "error",
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "isExtraImport": true,
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "Add_To_Cart_Create",
        "importPath": "app.models.add_to_cart",
        "description": "app.models.add_to_cart",
        "isExtraImport": true,
        "detail": "app.models.add_to_cart",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "stringify",
        "importPath": "flatted",
        "description": "flatted",
        "isExtraImport": true,
        "detail": "flatted",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "flatted",
        "description": "flatted",
        "isExtraImport": true,
        "detail": "flatted",
        "documentation": {}
    },
    {
        "label": "_collections_abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_collections_abc",
        "description": "_collections_abc",
        "detail": "_collections_abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "_collections_abc",
        "description": "_collections_abc",
        "isExtraImport": true,
        "detail": "_collections_abc",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codecs",
        "description": "codecs",
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "mbcs_encode",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "mbcs_decode",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "oem_encode",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "oem_decode",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "lookup",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF8",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "_codecs_tw,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_codecs_tw.",
        "description": "_codecs_tw.",
        "detail": "_codecs_tw.",
        "documentation": {}
    },
    {
        "label": "_multibytecodec",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_multibytecodec",
        "description": "_multibytecodec",
        "detail": "_multibytecodec",
        "documentation": {}
    },
    {
        "label": "_codecs_hk,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_codecs_hk.",
        "description": "_codecs_hk.",
        "detail": "_codecs_hk.",
        "documentation": {}
    },
    {
        "label": "bz2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bz2",
        "description": "bz2",
        "detail": "bz2",
        "documentation": {}
    },
    {
        "label": "_codecs_jp,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_codecs_jp.",
        "description": "_codecs_jp.",
        "detail": "_codecs_jp.",
        "documentation": {}
    },
    {
        "label": "_codecs_kr,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_codecs_kr.",
        "description": "_codecs_kr.",
        "detail": "_codecs_kr.",
        "documentation": {}
    },
    {
        "label": "_codecs_cn,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_codecs_cn.",
        "description": "_codecs_cn.",
        "detail": "_codecs_cn.",
        "documentation": {}
    },
    {
        "label": "binascii",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "binascii",
        "description": "binascii",
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "stringprep,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "stringprep.",
        "description": "stringprep.",
        "detail": "stringprep.",
        "documentation": {}
    },
    {
        "label": "ucd_3_2_0",
        "importPath": "unicodedata",
        "description": "unicodedata",
        "isExtraImport": true,
        "detail": "unicodedata",
        "documentation": {}
    },
    {
        "label": "_codecs_iso2022,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_codecs_iso2022.",
        "description": "_codecs_iso2022.",
        "detail": "_codecs_iso2022.",
        "documentation": {}
    },
    {
        "label": "quopri",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "quopri",
        "description": "quopri",
        "detail": "quopri",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "TextIOWrapper",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "TextIOWrapper",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "codecs,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codecs.",
        "description": "codecs.",
        "detail": "codecs.",
        "documentation": {}
    },
    {
        "label": "zlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zlib",
        "description": "zlib",
        "detail": "zlib",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "_compiler",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "_constants",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "_parser",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "textwrap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "textwrap",
        "description": "textwrap",
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "email.message",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "email.message",
        "description": "email.message",
        "detail": "email.message",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "types",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "types",
        "description": "types",
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "MappingProxyType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "DynamicClassAttribute",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "GenericAlias",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "filterfalse",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "accumulate",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "repeat",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "islice",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "abc",
        "description": "abc",
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "get_cache_token",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "suppress",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "index",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "zipfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipfile",
        "description": "zipfile",
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "_imp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_imp",
        "description": "_imp",
        "detail": "_imp",
        "documentation": {}
    },
    {
        "label": "_io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_io",
        "description": "_io",
        "detail": "_io",
        "documentation": {}
    },
    {
        "label": "_warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_warnings",
        "description": "_warnings",
        "detail": "_warnings",
        "documentation": {}
    },
    {
        "label": "marshal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "marshal",
        "description": "marshal",
        "detail": "marshal",
        "documentation": {}
    },
    {
        "label": "_sre",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_sre",
        "description": "_sre",
        "detail": "_sre",
        "documentation": {}
    },
    {
        "label": "MAXREPEAT",
        "importPath": "_sre",
        "description": "_sre",
        "isExtraImport": true,
        "detail": "_sre",
        "documentation": {}
    },
    {
        "label": "MAXGROUPS",
        "importPath": "_sre",
        "description": "_sre",
        "isExtraImport": true,
        "detail": "_sre",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "weakref",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "weakref",
        "description": "weakref",
        "detail": "weakref",
        "documentation": {}
    },
    {
        "label": "dispatch_table",
        "importPath": "copyreg",
        "description": "copyreg",
        "isExtraImport": true,
        "detail": "copyreg",
        "documentation": {}
    },
    {
        "label": "builtins",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "builtins",
        "description": "builtins",
        "detail": "builtins",
        "documentation": {}
    },
    {
        "label": "str",
        "importPath": "builtins",
        "description": "builtins",
        "isExtraImport": true,
        "detail": "builtins",
        "documentation": {}
    },
    {
        "label": "abs",
        "importPath": "builtins",
        "description": "builtins",
        "isExtraImport": true,
        "detail": "builtins",
        "documentation": {}
    },
    {
        "label": "open",
        "importPath": "builtins",
        "description": "builtins",
        "isExtraImport": true,
        "detail": "builtins",
        "documentation": {}
    },
    {
        "label": "open",
        "importPath": "builtins",
        "description": "builtins",
        "isExtraImport": true,
        "detail": "builtins",
        "documentation": {}
    },
    {
        "label": "posixpath",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "posixpath",
        "description": "posixpath",
        "detail": "posixpath",
        "documentation": {}
    },
    {
        "label": "recursive_repr",
        "importPath": "reprlib",
        "description": "reprlib",
        "isExtraImport": true,
        "detail": "reprlib",
        "documentation": {}
    },
    {
        "label": "_thread",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_thread",
        "description": "_thread",
        "detail": "_thread",
        "documentation": {}
    },
    {
        "label": "RLock",
        "importPath": "_thread",
        "description": "_thread",
        "isExtraImport": true,
        "detail": "_thread",
        "documentation": {}
    },
    {
        "label": "get_ident",
        "importPath": "_thread",
        "description": "_thread",
        "isExtraImport": true,
        "detail": "_thread",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "encodings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "encodings",
        "description": "encodings",
        "detail": "encodings",
        "documentation": {}
    },
    {
        "label": "encodings.aliases",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "encodings.aliases",
        "description": "encodings.aliases",
        "detail": "encodings.aliases",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "exp",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "pi",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "e",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sqrt",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "acos",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "cos",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sin",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "tau",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "floor",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "isfinite",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "lgamma",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "fabs",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "log2",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "bisect",
        "importPath": "bisect",
        "description": "bisect",
        "isExtraImport": true,
        "detail": "bisect",
        "documentation": {}
    },
    {
        "label": "_random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_random",
        "description": "_random",
        "detail": "_random",
        "documentation": {}
    },
    {
        "label": "atexit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "atexit",
        "description": "atexit",
        "detail": "atexit",
        "documentation": {}
    },
    {
        "label": "keyword",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "keyword",
        "description": "keyword",
        "detail": "keyword",
        "documentation": {}
    },
    {
        "label": "__main__",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "__main__",
        "description": "__main__",
        "detail": "__main__",
        "documentation": {}
    },
    {
        "label": "stat",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "stat",
        "description": "stat",
        "detail": "stat",
        "documentation": {}
    },
    {
        "label": "fnmatch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fnmatch",
        "description": "fnmatch",
        "detail": "fnmatch",
        "documentation": {}
    },
    {
        "label": "errno",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "errno",
        "description": "errno",
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "_struct",
        "description": "_struct",
        "isExtraImport": true,
        "detail": "_struct",
        "documentation": {}
    },
    {
        "label": "_clearcache",
        "importPath": "_struct",
        "description": "_struct",
        "isExtraImport": true,
        "detail": "_struct",
        "documentation": {}
    },
    {
        "label": "__doc__",
        "importPath": "_struct",
        "description": "_struct",
        "isExtraImport": true,
        "detail": "_struct",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "Random",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "token",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "token",
        "description": "token",
        "detail": "token",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "token",
        "description": "token",
        "isExtraImport": true,
        "detail": "token",
        "documentation": {}
    },
    {
        "label": "EXACT_TOKEN_TYPES",
        "importPath": "token",
        "description": "token",
        "isExtraImport": true,
        "detail": "token",
        "documentation": {}
    },
    {
        "label": "_tokenize",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_tokenize",
        "description": "_tokenize",
        "detail": "_tokenize",
        "documentation": {}
    },
    {
        "label": "getweakrefcount",
        "importPath": "_weakref",
        "description": "_weakref",
        "isExtraImport": true,
        "detail": "_weakref",
        "documentation": {}
    },
    {
        "label": "getweakrefs",
        "importPath": "_weakref",
        "description": "_weakref",
        "isExtraImport": true,
        "detail": "_weakref",
        "documentation": {}
    },
    {
        "label": "ref",
        "importPath": "_weakref",
        "description": "_weakref",
        "isExtraImport": true,
        "detail": "_weakref",
        "documentation": {}
    },
    {
        "label": "proxy",
        "importPath": "_weakref",
        "description": "_weakref",
        "isExtraImport": true,
        "detail": "_weakref",
        "documentation": {}
    },
    {
        "label": "CallableProxyType",
        "importPath": "_weakref",
        "description": "_weakref",
        "isExtraImport": true,
        "detail": "_weakref",
        "documentation": {}
    },
    {
        "label": "ProxyType",
        "importPath": "_weakref",
        "description": "_weakref",
        "isExtraImport": true,
        "detail": "_weakref",
        "documentation": {}
    },
    {
        "label": "ReferenceType",
        "importPath": "_weakref",
        "description": "_weakref",
        "isExtraImport": true,
        "detail": "_weakref",
        "documentation": {}
    },
    {
        "label": "_remove_dead_weakref",
        "importPath": "_weakref",
        "description": "_weakref",
        "isExtraImport": true,
        "detail": "_weakref",
        "documentation": {}
    },
    {
        "label": "ref",
        "importPath": "_weakref",
        "description": "_weakref",
        "isExtraImport": true,
        "detail": "_weakref",
        "documentation": {}
    },
    {
        "label": "WeakSet",
        "importPath": "_weakrefset",
        "description": "_weakrefset",
        "isExtraImport": true,
        "detail": "_weakrefset",
        "documentation": {}
    },
    {
        "label": "_IterationGuard",
        "importPath": "_weakrefset",
        "description": "_weakrefset",
        "isExtraImport": true,
        "detail": "_weakrefset",
        "documentation": {}
    },
    {
        "label": "verify_password",
        "kind": 2,
        "importPath": "app.core.security",
        "description": "app.core.security",
        "peekOfCode": "def verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)",
        "detail": "app.core.security",
        "documentation": {}
    },
    {
        "label": "get_password_hash",
        "kind": 2,
        "importPath": "app.core.security",
        "description": "app.core.security",
        "peekOfCode": "def get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)",
        "detail": "app.core.security",
        "documentation": {}
    },
    {
        "label": "create_access_token",
        "kind": 2,
        "importPath": "app.core.security",
        "description": "app.core.security",
        "peekOfCode": "def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt",
        "detail": "app.core.security",
        "documentation": {}
    },
    {
        "label": "pwd_context",
        "kind": 5,
        "importPath": "app.core.security",
        "description": "app.core.security",
        "peekOfCode": "pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n# Security configuration\nSECRET_KEY = os.getenv(\"SECRET_KEY\", \"your-secret-key\")\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):",
        "detail": "app.core.security",
        "documentation": {}
    },
    {
        "label": "SECRET_KEY",
        "kind": 5,
        "importPath": "app.core.security",
        "description": "app.core.security",
        "peekOfCode": "SECRET_KEY = os.getenv(\"SECRET_KEY\", \"your-secret-key\")\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:",
        "detail": "app.core.security",
        "documentation": {}
    },
    {
        "label": "ALGORITHM",
        "kind": 5,
        "importPath": "app.core.security",
        "description": "app.core.security",
        "peekOfCode": "ALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta",
        "detail": "app.core.security",
        "documentation": {}
    },
    {
        "label": "ACCESS_TOKEN_EXPIRE_MINUTES",
        "kind": 5,
        "importPath": "app.core.security",
        "description": "app.core.security",
        "peekOfCode": "ACCESS_TOKEN_EXPIRE_MINUTES = 30\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:",
        "detail": "app.core.security",
        "documentation": {}
    },
    {
        "label": "TokenResponse",
        "kind": 6,
        "importPath": "app.crud.login",
        "description": "app.crud.login",
        "peekOfCode": "class TokenResponse(BaseModel):\n    access_token: str\n    token_type: str\n    user_data: Union[UserResponse, SalesmanResponse]\nasync def process_login(db: Session, login_data: LoginRequest,res:Response) -> Optional[TokenResponse]:\n    \"\"\"\n    Process login request and return access token if successful\n    \"\"\"\n    if login_data.role == 3:  # customer\n        user = db.query(CustomerBase).filter(",
        "detail": "app.crud.login",
        "documentation": {}
    },
    {
        "label": "ACCESS_TOKEN_EXPIRE_MINUTES",
        "kind": 5,
        "importPath": "app.crud.login",
        "description": "app.crud.login",
        "peekOfCode": "ACCESS_TOKEN_EXPIRE_MINUTES = 120\nSECRET_KEY = os.getenv(\"SECRET_KEY\", \"your-secret-key\")\nALGORITHM = \"HS256\"\nclass TokenResponse(BaseModel):\n    access_token: str\n    token_type: str\n    user_data: Union[UserResponse, SalesmanResponse]\nasync def process_login(db: Session, login_data: LoginRequest,res:Response) -> Optional[TokenResponse]:\n    \"\"\"\n    Process login request and return access token if successful",
        "detail": "app.crud.login",
        "documentation": {}
    },
    {
        "label": "SECRET_KEY",
        "kind": 5,
        "importPath": "app.crud.login",
        "description": "app.crud.login",
        "peekOfCode": "SECRET_KEY = os.getenv(\"SECRET_KEY\", \"your-secret-key\")\nALGORITHM = \"HS256\"\nclass TokenResponse(BaseModel):\n    access_token: str\n    token_type: str\n    user_data: Union[UserResponse, SalesmanResponse]\nasync def process_login(db: Session, login_data: LoginRequest,res:Response) -> Optional[TokenResponse]:\n    \"\"\"\n    Process login request and return access token if successful\n    \"\"\"",
        "detail": "app.crud.login",
        "documentation": {}
    },
    {
        "label": "ALGORITHM",
        "kind": 5,
        "importPath": "app.crud.login",
        "description": "app.crud.login",
        "peekOfCode": "ALGORITHM = \"HS256\"\nclass TokenResponse(BaseModel):\n    access_token: str\n    token_type: str\n    user_data: Union[UserResponse, SalesmanResponse]\nasync def process_login(db: Session, login_data: LoginRequest,res:Response) -> Optional[TokenResponse]:\n    \"\"\"\n    Process login request and return access token if successful\n    \"\"\"\n    if login_data.role == 3:  # customer",
        "detail": "app.crud.login",
        "documentation": {}
    },
    {
        "label": "get_db",
        "kind": 2,
        "importPath": "app.db.database",
        "description": "app.db.database",
        "peekOfCode": "def get_db() -> Generator:\n    \"\"\"\n    Dependency function to get DB session.\n    Used in FastAPI dependency injection.\n    \"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()",
        "detail": "app.db.database",
        "documentation": {}
    },
    {
        "label": "init_db",
        "kind": 2,
        "importPath": "app.db.database",
        "description": "app.db.database",
        "peekOfCode": "def init_db() -> None:\n    \"\"\"\n    Initialize database by creating all tables.\n    Call this function when starting your application.\n    \"\"\"\n    try:\n        # Create all tables\n        Base.metadata.create_all(bind=engine)\n        print(\"Database tables created successfully!\")\n    except Exception as e:",
        "detail": "app.db.database",
        "documentation": {}
    },
    {
        "label": "cleanup_database",
        "kind": 2,
        "importPath": "app.db.database",
        "description": "app.db.database",
        "peekOfCode": "def cleanup_database() -> None:\n    \"\"\"\n    Cleanup database connections.\n    Call this function when shutting down your application.\n    \"\"\"\n    try:\n        engine.dispose()\n        print(\"Database connections closed successfully!\")\n    except Exception as e:\n        print(f\"Error closing database connections: {e}\")",
        "detail": "app.db.database",
        "documentation": {}
    },
    {
        "label": "DATABASE_URL",
        "kind": 5,
        "importPath": "app.db.database",
        "description": "app.db.database",
        "peekOfCode": "DATABASE_URL = URL.create(\n    drivername=\"mssql+pyodbc\",\n    username=os.getenv(\"DB_USER\"),\n    password=os.getenv(\"DB_PASSWORD\"),\n    host=os.getenv(\"DB_HOST\", \"localhost\"),\n    database=os.getenv(\"DB_NAME\"),\n    query={\"driver\": \"ODBC Driver 17 for SQL Server\"},\n)\n# Create SQLAlchemy engine\nengine = create_engine(",
        "detail": "app.db.database",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "app.db.database",
        "description": "app.db.database",
        "peekOfCode": "engine = create_engine(\n    DATABASE_URL,\n    echo=True,  # Set to False in production\n    pool_pre_ping=True,  # Enable connection pool \"pre-ping\" feature\n    pool_size=5,  # Maximum number of connections to keep persistent\n    max_overflow=10,  # Maximum number of connections to create when pool is full\n)\n# SessionLocal class for database sessions\nSessionLocal = sessionmaker(\n    bind=engine,",
        "detail": "app.db.database",
        "documentation": {}
    },
    {
        "label": "SessionLocal",
        "kind": 5,
        "importPath": "app.db.database",
        "description": "app.db.database",
        "peekOfCode": "SessionLocal = sessionmaker(\n    bind=engine,\n    autocommit=False,\n    autoflush=False,\n    expire_on_commit=False\n)\n# Base class for declarative models\nBase = declarative_base()\nmetadata = MetaData()\n# Database dependency",
        "detail": "app.db.database",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "app.db.database",
        "description": "app.db.database",
        "peekOfCode": "Base = declarative_base()\nmetadata = MetaData()\n# Database dependency\ndef get_db() -> Generator:\n    \"\"\"\n    Dependency function to get DB session.\n    Used in FastAPI dependency injection.\n    \"\"\"\n    db = SessionLocal()\n    try:",
        "detail": "app.db.database",
        "documentation": {}
    },
    {
        "label": "metadata",
        "kind": 5,
        "importPath": "app.db.database",
        "description": "app.db.database",
        "peekOfCode": "metadata = MetaData()\n# Database dependency\ndef get_db() -> Generator:\n    \"\"\"\n    Dependency function to get DB session.\n    Used in FastAPI dependency injection.\n    \"\"\"\n    db = SessionLocal()\n    try:\n        yield db",
        "detail": "app.db.database",
        "documentation": {}
    },
    {
        "label": "validate_cookie_token",
        "kind": 2,
        "importPath": "app.middleware.middleware",
        "description": "app.middleware.middleware",
        "peekOfCode": "def validate_cookie_token(request: Request):\n    print(request)\n    print(request.cookies)\n    token = request.cookies.get(\"access_token\")\n    if not token:\n        raise HTTPException(status_code=401, detail=\"No token\")\n    try:\n        return jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n    except JWTError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")",
        "detail": "app.middleware.middleware",
        "documentation": {}
    },
    {
        "label": "require_roles",
        "kind": 2,
        "importPath": "app.middleware.middleware",
        "description": "app.middleware.middleware",
        "peekOfCode": "def require_roles(allowed_roles: List[int]):\n    def decorator(func):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            request = next(\n                (arg for arg in args if isinstance(arg, Request)), kwargs.get(\"request\")\n            )\n            payload = validate_cookie_token(request)\n            if payload.get(\"role\") not in allowed_roles:\n                raise HTTPException(status_code=403, detail=\"Unauthorized\")",
        "detail": "app.middleware.middleware",
        "documentation": {}
    },
    {
        "label": "Add_To_Cart_Create",
        "kind": 6,
        "importPath": "app.models.add_to_cart",
        "description": "app.models.add_to_cart",
        "peekOfCode": "class Add_To_Cart_Create(BaseModel):\n    cid:int | None = None\n    productIds: List[int]\n    model_config = ConfigDict(from_attributes=True, arbitrary_types_allowed=True)",
        "detail": "app.models.add_to_cart",
        "documentation": {}
    },
    {
        "label": "CartBase",
        "kind": 6,
        "importPath": "app.models.cart",
        "description": "app.models.cart",
        "peekOfCode": "class CartBase(Base):\n    __tablename__ = \"cart\"\n    cid = Column(Integer, primary_key=True, index=True)\n    custid = Column(Integer, nullable=False)  \n    created_at = Column(Date, nullable=False)  # User's last name\n    status = Column(String, unique=True, index=True, nullable=False)  # Unique email",
        "detail": "app.models.cart",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "app.models.cart",
        "description": "app.models.cart",
        "peekOfCode": "Base = declarative_base()\nclass CartBase(Base):\n    __tablename__ = \"cart\"\n    cid = Column(Integer, primary_key=True, index=True)\n    custid = Column(Integer, nullable=False)  \n    created_at = Column(Date, nullable=False)  # User's last name\n    status = Column(String, unique=True, index=True, nullable=False)  # Unique email",
        "detail": "app.models.cart",
        "documentation": {}
    },
    {
        "label": "CartItemBase",
        "kind": 6,
        "importPath": "app.models.cart_item",
        "description": "app.models.cart_item",
        "peekOfCode": "class CartItemBase(Base):\n    __tablename__ = \"cart_items\"\n    ci_id = Column(Integer, primary_key=True, index=True)\n    cid = Column(Integer, nullable=False)  \n    pid = Column(Integer, nullable=False)  \n    quantity = Column(Integer, index=True, nullable=False)  \n    price = Column(Float, nullable=False)",
        "detail": "app.models.cart_item",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "app.models.cart_item",
        "description": "app.models.cart_item",
        "peekOfCode": "Base = declarative_base()\nclass CartItemBase(Base):\n    __tablename__ = \"cart_items\"\n    ci_id = Column(Integer, primary_key=True, index=True)\n    cid = Column(Integer, nullable=False)  \n    pid = Column(Integer, nullable=False)  \n    quantity = Column(Integer, index=True, nullable=False)  \n    price = Column(Float, nullable=False)",
        "detail": "app.models.cart_item",
        "documentation": {}
    },
    {
        "label": "CustomerBase",
        "kind": 6,
        "importPath": "app.models.customer",
        "description": "app.models.customer",
        "peekOfCode": "class CustomerBase(Base):\n    __tablename__ = \"customer\"\n    uid = (Column(Integer, primary_key=True, index=True))\n    uname = (Column(String, nullable=False))# User's first name\n    lname = (Column(String, nullable=False))# User's last name\n    email = (Column(String, unique=True, index=True, nullable=False))  # Unique email\n    password_hash =(Column(String, nullable=False))  # Hashed password\n    address =(Column(String))  # Address is optional\n    phone = (Column(String, nullable=False))  # Phone number is required\n    rid = Column(Integer, nullable=True)  # Reference to another table (optional)",
        "detail": "app.models.customer",
        "documentation": {}
    },
    {
        "label": "UserResponse",
        "kind": 6,
        "importPath": "app.models.customer",
        "description": "app.models.customer",
        "peekOfCode": "class UserResponse(BaseModel):\n    id: int\n    email: str\n    role:str\n    model_config = ConfigDict(\n        from_attributes=True,\n        arbitrary_types_allowed=True\n    )",
        "detail": "app.models.customer",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "app.models.customer",
        "description": "app.models.customer",
        "peekOfCode": "Base = declarative_base()\nclass CustomerBase(Base):\n    __tablename__ = \"customer\"\n    uid = (Column(Integer, primary_key=True, index=True))\n    uname = (Column(String, nullable=False))# User's first name\n    lname = (Column(String, nullable=False))# User's last name\n    email = (Column(String, unique=True, index=True, nullable=False))  # Unique email\n    password_hash =(Column(String, nullable=False))  # Hashed password\n    address =(Column(String))  # Address is optional\n    phone = (Column(String, nullable=False))  # Phone number is required",
        "detail": "app.models.customer",
        "documentation": {}
    },
    {
        "label": "LoginRequest",
        "kind": 6,
        "importPath": "app.models.login_model",
        "description": "app.models.login_model",
        "peekOfCode": "class LoginRequest(BaseModel):\n    email: EmailStr\n    password: str\n    role: int  # 2 for salesman, 3 for customer\n    model_config = ConfigDict(\n        from_attributes=True,\n        arbitrary_types_allowed=True\n    )",
        "detail": "app.models.login_model",
        "documentation": {}
    },
    {
        "label": "ProductBase",
        "kind": 6,
        "importPath": "app.models.product",
        "description": "app.models.product",
        "peekOfCode": "class ProductBase(Base):\n    __tablename__ = \"product\"\n    pid = Column(Integer, primary_key=True, index=True)\n    sid = Column(Integer,nullable=False)\n    pname = Column(String, nullable=False)\n    pdescription = Column(String,nullable=False)\n    price = Column(Float, nullable=False)\n    stock_quantity = Column(Integer, nullable=False)\n    discount = Column(Float,nullable=True)\n    status = Column(Integer, nullable=False)",
        "detail": "app.models.product",
        "documentation": {}
    },
    {
        "label": "ProductResponse",
        "kind": 6,
        "importPath": "app.models.product",
        "description": "app.models.product",
        "peekOfCode": "class ProductResponse(BaseModel):\n    id: int\n    name: str\n    description: str | None\n    price: float\n    stock: int\n    image: str | None\n    model_config = ConfigDict(from_attributes=True, arbitrary_types_allowed=True)",
        "detail": "app.models.product",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "app.models.product",
        "description": "app.models.product",
        "peekOfCode": "Base = declarative_base()\nclass ProductBase(Base):\n    __tablename__ = \"product\"\n    pid = Column(Integer, primary_key=True, index=True)\n    sid = Column(Integer,nullable=False)\n    pname = Column(String, nullable=False)\n    pdescription = Column(String,nullable=False)\n    price = Column(Float, nullable=False)\n    stock_quantity = Column(Integer, nullable=False)\n    discount = Column(Float,nullable=True)",
        "detail": "app.models.product",
        "documentation": {}
    },
    {
        "label": "Response_Product_Create",
        "kind": 6,
        "importPath": "app.models.response_product_create",
        "description": "app.models.response_product_create",
        "peekOfCode": "class Response_Product_Create(BaseModel):\n    success: bool\n    message: str\n    # product: ProductBase | None = None\n    # error:dict | None = None\n    model_config = ConfigDict(\n        from_attributes=True,\n        arbitrary_types_allowed=True\n    )",
        "detail": "app.models.response_product_create",
        "documentation": {}
    },
    {
        "label": "SalesmanBase",
        "kind": 6,
        "importPath": "app.models.salesman",
        "description": "app.models.salesman",
        "peekOfCode": "class SalesmanBase(Base):\n    __tablename__ = \"salesman\"\n    sid = Column(Integer, primary_key=True, index=True)\n    name = Column(String)\n    lname = Column(String)\n    phone = Column(String)\n    email = Column(String, unique=True, index=True)\n    password_hash = Column(String)\n    address = Column(String)\n    created_at = Column(Date)",
        "detail": "app.models.salesman",
        "documentation": {}
    },
    {
        "label": "SalesmanResponse",
        "kind": 6,
        "importPath": "app.models.salesman",
        "description": "app.models.salesman",
        "peekOfCode": "class SalesmanResponse(BaseModel):\n    id: int\n    email: str\n    role:str\n    model_config = ConfigDict(\n        from_attributes=True,\n        arbitrary_types_allowed=True\n    )",
        "detail": "app.models.salesman",
        "documentation": {}
    },
    {
        "label": "ShipmentBase",
        "kind": 6,
        "importPath": "app.models.shipment",
        "description": "app.models.shipment",
        "peekOfCode": "class ShipmentBase(Base):\n    __tablename__ = \"shipment\"\n    ShipmentID = Column(Integer, primary_key=True, index=True)\n    ProductID = Column(Integer, nullable=False)\n    WarehouseID = Column(Integer, nullable=False)\n    Quantity = Column(Integer, nullable=False)\n    Status = Column(String, nullable=False)\n    EstimatedArrivalDate = Column(Date)\n    ActualArrivalDate = Column(Date)",
        "detail": "app.models.shipment",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "app.models.shipment",
        "description": "app.models.shipment",
        "peekOfCode": "Base = declarative_base()\nclass ShipmentBase(Base):\n    __tablename__ = \"shipment\"\n    ShipmentID = Column(Integer, primary_key=True, index=True)\n    ProductID = Column(Integer, nullable=False)\n    WarehouseID = Column(Integer, nullable=False)\n    Quantity = Column(Integer, nullable=False)\n    Status = Column(String, nullable=False)\n    EstimatedArrivalDate = Column(Date)\n    ActualArrivalDate = Column(Date)",
        "detail": "app.models.shipment",
        "documentation": {}
    },
    {
        "label": "WarehouseBase",
        "kind": 6,
        "importPath": "app.models.warehouse",
        "description": "app.models.warehouse",
        "peekOfCode": "class WarehouseBase(Base):  \n    __tablename__ = \"warehouse\"\n    wid = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False)\n    location = Column(String, nullable=False)\n    phone = Column(String, nullable=False)\n    capacity_volume = Column(Integer, nullable=False)\n    capacity_weight = Column(Integer, nullable=False)",
        "detail": "app.models.warehouse",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "app.models.warehouse",
        "description": "app.models.warehouse",
        "peekOfCode": "Base = declarative_base()\nclass WarehouseBase(Base):  \n    __tablename__ = \"warehouse\"\n    wid = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False)\n    location = Column(String, nullable=False)\n    phone = Column(String, nullable=False)\n    capacity_volume = Column(Integer, nullable=False)\n    capacity_weight = Column(Integer, nullable=False)",
        "detail": "app.models.warehouse",
        "documentation": {}
    },
    {
        "label": "CustomerCreate",
        "kind": 6,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "class CustomerCreate(BaseModel):\n    uname: str\n    lname: str\n    email: EmailStr\n    password: str\n    address: str | None = None\n    phone: str\n    rid: int | None = None\n    model_config = ConfigDict(\n        from_attributes=True,",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "SalesmanCreate",
        "kind": 6,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "class SalesmanCreate(BaseModel):\n    name: str\n    lname: str\n    phone: str\n    email: EmailStr\n    password: str\n    address: str | None = None\n    model_config = ConfigDict(\n        from_attributes=True,\n        arbitrary_types_allowed=True",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "Product_Create",
        "kind": 6,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "class Product_Create(BaseModel):\n    sid:int\n    pname:str\n    pdescription:str\n    price:float\n    cid:int\n    discount:float\n    status:str\n    wid:int\n    stock_quantity:int",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "ROLE_CUSTOMER",
        "kind": 5,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "ROLE_CUSTOMER = 3\nROLE_SALESMAN = 2\nROLE_ADMIN = 1\napp = FastAPI()\nclass CustomerCreate(BaseModel):\n    uname: str\n    lname: str\n    email: EmailStr\n    password: str\n    address: str | None = None",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "ROLE_SALESMAN",
        "kind": 5,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "ROLE_SALESMAN = 2\nROLE_ADMIN = 1\napp = FastAPI()\nclass CustomerCreate(BaseModel):\n    uname: str\n    lname: str\n    email: EmailStr\n    password: str\n    address: str | None = None\n    phone: str",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "ROLE_ADMIN",
        "kind": 5,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "ROLE_ADMIN = 1\napp = FastAPI()\nclass CustomerCreate(BaseModel):\n    uname: str\n    lname: str\n    email: EmailStr\n    password: str\n    address: str | None = None\n    phone: str\n    rid: int | None = None",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "app = FastAPI()\nclass CustomerCreate(BaseModel):\n    uname: str\n    lname: str\n    email: EmailStr\n    password: str\n    address: str | None = None\n    phone: str\n    rid: int | None = None\n    model_config = ConfigDict(",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "_Known",
        "kind": 6,
        "importPath": "front-end.trendora.node_modules.flatted.python.flatted",
        "description": "front-end.trendora.node_modules.flatted.python.flatted",
        "peekOfCode": "class _Known:\n    def __init__(self):\n        self.key = []\n        self.value = []\nclass _String:\n    def __init__(self, value):\n        self.value = value\ndef _array_keys(value):\n    keys = []\n    i = 0",
        "detail": "front-end.trendora.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "_String",
        "kind": 6,
        "importPath": "front-end.trendora.node_modules.flatted.python.flatted",
        "description": "front-end.trendora.node_modules.flatted.python.flatted",
        "peekOfCode": "class _String:\n    def __init__(self, value):\n        self.value = value\ndef _array_keys(value):\n    keys = []\n    i = 0\n    for _ in value:\n        keys.append(i)\n        i += 1\n    return keys",
        "detail": "front-end.trendora.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "front-end.trendora.node_modules.flatted.python.flatted",
        "description": "front-end.trendora.node_modules.flatted.python.flatted",
        "peekOfCode": "def parse(value, *args, **kwargs):\n    json = _json.loads(value, *args, **kwargs)\n    wrapped = []\n    for value in json:\n        wrapped.append(_wrap(value))\n    input = []\n    for value in wrapped:\n        if isinstance(value, _String):\n            input.append(value.value)\n        else:",
        "detail": "front-end.trendora.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "stringify",
        "kind": 2,
        "importPath": "front-end.trendora.node_modules.flatted.python.flatted",
        "description": "front-end.trendora.node_modules.flatted.python.flatted",
        "peekOfCode": "def stringify(value, *args, **kwargs):\n    known = _Known()\n    input = []\n    output = []\n    i = int(_index(known, input, value))\n    while i < len(input):\n        output.append(_transform(known, input, input[i]))\n        i += 1\n    return _json.dumps(output, *args, **kwargs)",
        "detail": "front-end.trendora.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "stringify",
        "kind": 2,
        "importPath": "front-end.trendora.node_modules.flatted.python.test",
        "description": "front-end.trendora.node_modules.flatted.python.test",
        "peekOfCode": "def stringify(value):\n    return _stringify(value, separators=(',', ':'))\nassert stringify([None, None]) == '[[null,null]]'\na = []\no = {}\nassert stringify(a) == '[[]]'\nassert stringify(o) == '[{}]'\na.append(a)\no['o'] = o\nassert stringify(a) == '[[\"0\"]]'",
        "detail": "front-end.trendora.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "front-end.trendora.node_modules.flatted.python.test",
        "description": "front-end.trendora.node_modules.flatted.python.test",
        "peekOfCode": "a = []\no = {}\nassert stringify(a) == '[[]]'\nassert stringify(o) == '[{}]'\na.append(a)\no['o'] = o\nassert stringify(a) == '[[\"0\"]]'\nassert stringify(o) == '[{\"o\":\"0\"}]'\nb = parse(stringify(a))\nassert isinstance(b, list) and b[0] == b",
        "detail": "front-end.trendora.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o",
        "kind": 5,
        "importPath": "front-end.trendora.node_modules.flatted.python.test",
        "description": "front-end.trendora.node_modules.flatted.python.test",
        "peekOfCode": "o = {}\nassert stringify(a) == '[[]]'\nassert stringify(o) == '[{}]'\na.append(a)\no['o'] = o\nassert stringify(a) == '[[\"0\"]]'\nassert stringify(o) == '[{\"o\":\"0\"}]'\nb = parse(stringify(a))\nassert isinstance(b, list) and b[0] == b\na.append(1)",
        "detail": "front-end.trendora.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['o']",
        "kind": 5,
        "importPath": "front-end.trendora.node_modules.flatted.python.test",
        "description": "front-end.trendora.node_modules.flatted.python.test",
        "peekOfCode": "o['o'] = o\nassert stringify(a) == '[[\"0\"]]'\nassert stringify(o) == '[{\"o\":\"0\"}]'\nb = parse(stringify(a))\nassert isinstance(b, list) and b[0] == b\na.append(1)\na.append('two')\na.append(True)\no['one'] = 1\no['two'] = 'two'",
        "detail": "front-end.trendora.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "front-end.trendora.node_modules.flatted.python.test",
        "description": "front-end.trendora.node_modules.flatted.python.test",
        "peekOfCode": "b = parse(stringify(a))\nassert isinstance(b, list) and b[0] == b\na.append(1)\na.append('two')\na.append(True)\no['one'] = 1\no['two'] = 'two'\no['three'] = True\nassert stringify(a) == '[[\"0\",1,\"1\",true],\"two\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true},\"two\"]'",
        "detail": "front-end.trendora.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['one']",
        "kind": 5,
        "importPath": "front-end.trendora.node_modules.flatted.python.test",
        "description": "front-end.trendora.node_modules.flatted.python.test",
        "peekOfCode": "o['one'] = 1\no['two'] = 'two'\no['three'] = True\nassert stringify(a) == '[[\"0\",1,\"1\",true],\"two\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true},\"two\"]'\na.append(o)\no['a'] = a\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\"}]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\"},\"two\",[\"2\",1,\"1\",true,\"0\"]]'\na.append({'test': 'OK'})",
        "detail": "front-end.trendora.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['two']",
        "kind": 5,
        "importPath": "front-end.trendora.node_modules.flatted.python.test",
        "description": "front-end.trendora.node_modules.flatted.python.test",
        "peekOfCode": "o['two'] = 'two'\no['three'] = True\nassert stringify(a) == '[[\"0\",1,\"1\",true],\"two\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true},\"two\"]'\na.append(o)\no['a'] = a\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\"}]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\"},\"two\",[\"2\",1,\"1\",true,\"0\"]]'\na.append({'test': 'OK'})\na.append([1, 2, 3])",
        "detail": "front-end.trendora.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['three']",
        "kind": 5,
        "importPath": "front-end.trendora.node_modules.flatted.python.test",
        "description": "front-end.trendora.node_modules.flatted.python.test",
        "peekOfCode": "o['three'] = True\nassert stringify(a) == '[[\"0\",1,\"1\",true],\"two\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true},\"two\"]'\na.append(o)\no['a'] = a\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\"}]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\"},\"two\",[\"2\",1,\"1\",true,\"0\"]]'\na.append({'test': 'OK'})\na.append([1, 2, 3])\no['test'] = {'test': 'OK'}",
        "detail": "front-end.trendora.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['a']",
        "kind": 5,
        "importPath": "front-end.trendora.node_modules.flatted.python.test",
        "description": "front-end.trendora.node_modules.flatted.python.test",
        "peekOfCode": "o['a'] = a\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\"}]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\"},\"two\",[\"2\",1,\"1\",true,\"0\"]]'\na.append({'test': 'OK'})\na.append([1, 2, 3])\no['test'] = {'test': 'OK'}\no['array'] = [1, 2, 3]\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\",\"3\",\"4\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\",\"test\":\"3\",\"array\":\"4\"},{\"test\":\"5\"},[1,2,3],\"OK\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\",\"test\":\"3\",\"array\":\"4\"},\"two\",[\"2\",1,\"1\",true,\"0\",\"3\",\"4\"],{\"test\":\"5\"},[1,2,3],\"OK\"]'\na2 = parse(stringify(a));",
        "detail": "front-end.trendora.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['test']",
        "kind": 5,
        "importPath": "front-end.trendora.node_modules.flatted.python.test",
        "description": "front-end.trendora.node_modules.flatted.python.test",
        "peekOfCode": "o['test'] = {'test': 'OK'}\no['array'] = [1, 2, 3]\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\",\"3\",\"4\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\",\"test\":\"3\",\"array\":\"4\"},{\"test\":\"5\"},[1,2,3],\"OK\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\",\"test\":\"3\",\"array\":\"4\"},\"two\",[\"2\",1,\"1\",true,\"0\",\"3\",\"4\"],{\"test\":\"5\"},[1,2,3],\"OK\"]'\na2 = parse(stringify(a));\no2 = parse(stringify(o));\nassert a2[0] == a2\nassert o2['o'] == o2\nassert a2[1] == 1 and a2[2] == 'two' and a2[3] == True and isinstance(a2[4], dict)\nassert a2[4] == a2[4]['o'] and a2 == a2[4]['o']['a']",
        "detail": "front-end.trendora.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o['array']",
        "kind": 5,
        "importPath": "front-end.trendora.node_modules.flatted.python.test",
        "description": "front-end.trendora.node_modules.flatted.python.test",
        "peekOfCode": "o['array'] = [1, 2, 3]\nassert stringify(a) == '[[\"0\",1,\"1\",true,\"2\",\"3\",\"4\"],\"two\",{\"o\":\"2\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"0\",\"test\":\"3\",\"array\":\"4\"},{\"test\":\"5\"},[1,2,3],\"OK\"]'\nassert stringify(o) == '[{\"o\":\"0\",\"one\":1,\"two\":\"1\",\"three\":true,\"a\":\"2\",\"test\":\"3\",\"array\":\"4\"},\"two\",[\"2\",1,\"1\",true,\"0\",\"3\",\"4\"],{\"test\":\"5\"},[1,2,3],\"OK\"]'\na2 = parse(stringify(a));\no2 = parse(stringify(o));\nassert a2[0] == a2\nassert o2['o'] == o2\nassert a2[1] == 1 and a2[2] == 'two' and a2[3] == True and isinstance(a2[4], dict)\nassert a2[4] == a2[4]['o'] and a2 == a2[4]['o']['a']\nstr = parse('[{\"prop\":\"1\",\"a\":\"2\",\"b\":\"3\"},{\"value\":123},[\"4\",\"5\"],{\"e\":\"6\",\"t\":\"7\",\"p\":4},{},{\"b\":\"8\"},\"f\",{\"a\":\"9\"},[\"10\"],\"sup\",{\"a\":1,\"d\":2,\"c\":\"7\",\"z\":\"11\",\"h\":1},{\"g\":2,\"a\":\"7\",\"b\":\"12\",\"f\":6},{\"r\":4,\"u\":\"7\",\"c\":5}]')",
        "detail": "front-end.trendora.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "a2",
        "kind": 5,
        "importPath": "front-end.trendora.node_modules.flatted.python.test",
        "description": "front-end.trendora.node_modules.flatted.python.test",
        "peekOfCode": "a2 = parse(stringify(a));\no2 = parse(stringify(o));\nassert a2[0] == a2\nassert o2['o'] == o2\nassert a2[1] == 1 and a2[2] == 'two' and a2[3] == True and isinstance(a2[4], dict)\nassert a2[4] == a2[4]['o'] and a2 == a2[4]['o']['a']\nstr = parse('[{\"prop\":\"1\",\"a\":\"2\",\"b\":\"3\"},{\"value\":123},[\"4\",\"5\"],{\"e\":\"6\",\"t\":\"7\",\"p\":4},{},{\"b\":\"8\"},\"f\",{\"a\":\"9\"},[\"10\"],\"sup\",{\"a\":1,\"d\":2,\"c\":\"7\",\"z\":\"11\",\"h\":1},{\"g\":2,\"a\":\"7\",\"b\":\"12\",\"f\":6},{\"r\":4,\"u\":\"7\",\"c\":5}]')\nassert str['b']['t']['a'] == 'sup' and str['a'][1]['b'][0]['c'] == str['b']['t']\noo = parse('[{\"a\":\"1\",\"b\":\"0\",\"c\":\"2\"},{\"aa\":\"3\"},{\"ca\":\"4\",\"cb\":\"5\",\"cc\":\"6\",\"cd\":\"7\",\"ce\":\"8\",\"cf\":\"9\"},{\"aaa\":\"10\"},{\"caa\":\"4\"},{\"cba\":\"5\"},{\"cca\":\"2\"},{\"cda\":\"4\"},\"value2\",\"value3\",\"value1\"]');\nassert oo['a']['aa']['aaa'] == 'value1' and oo == oo['b'] and oo['c']['ca']['caa'] == oo['c']['ca']",
        "detail": "front-end.trendora.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "o2",
        "kind": 5,
        "importPath": "front-end.trendora.node_modules.flatted.python.test",
        "description": "front-end.trendora.node_modules.flatted.python.test",
        "peekOfCode": "o2 = parse(stringify(o));\nassert a2[0] == a2\nassert o2['o'] == o2\nassert a2[1] == 1 and a2[2] == 'two' and a2[3] == True and isinstance(a2[4], dict)\nassert a2[4] == a2[4]['o'] and a2 == a2[4]['o']['a']\nstr = parse('[{\"prop\":\"1\",\"a\":\"2\",\"b\":\"3\"},{\"value\":123},[\"4\",\"5\"],{\"e\":\"6\",\"t\":\"7\",\"p\":4},{},{\"b\":\"8\"},\"f\",{\"a\":\"9\"},[\"10\"],\"sup\",{\"a\":1,\"d\":2,\"c\":\"7\",\"z\":\"11\",\"h\":1},{\"g\":2,\"a\":\"7\",\"b\":\"12\",\"f\":6},{\"r\":4,\"u\":\"7\",\"c\":5}]')\nassert str['b']['t']['a'] == 'sup' and str['a'][1]['b'][0]['c'] == str['b']['t']\noo = parse('[{\"a\":\"1\",\"b\":\"0\",\"c\":\"2\"},{\"aa\":\"3\"},{\"ca\":\"4\",\"cb\":\"5\",\"cc\":\"6\",\"cd\":\"7\",\"ce\":\"8\",\"cf\":\"9\"},{\"aaa\":\"10\"},{\"caa\":\"4\"},{\"cba\":\"5\"},{\"cca\":\"2\"},{\"cda\":\"4\"},\"value2\",\"value3\",\"value1\"]');\nassert oo['a']['aa']['aaa'] == 'value1' and oo == oo['b'] and oo['c']['ca']['caa'] == oo['c']['ca']\nprint('OK')",
        "detail": "front-end.trendora.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "str",
        "kind": 5,
        "importPath": "front-end.trendora.node_modules.flatted.python.test",
        "description": "front-end.trendora.node_modules.flatted.python.test",
        "peekOfCode": "str = parse('[{\"prop\":\"1\",\"a\":\"2\",\"b\":\"3\"},{\"value\":123},[\"4\",\"5\"],{\"e\":\"6\",\"t\":\"7\",\"p\":4},{},{\"b\":\"8\"},\"f\",{\"a\":\"9\"},[\"10\"],\"sup\",{\"a\":1,\"d\":2,\"c\":\"7\",\"z\":\"11\",\"h\":1},{\"g\":2,\"a\":\"7\",\"b\":\"12\",\"f\":6},{\"r\":4,\"u\":\"7\",\"c\":5}]')\nassert str['b']['t']['a'] == 'sup' and str['a'][1]['b'][0]['c'] == str['b']['t']\noo = parse('[{\"a\":\"1\",\"b\":\"0\",\"c\":\"2\"},{\"aa\":\"3\"},{\"ca\":\"4\",\"cb\":\"5\",\"cc\":\"6\",\"cd\":\"7\",\"ce\":\"8\",\"cf\":\"9\"},{\"aaa\":\"10\"},{\"caa\":\"4\"},{\"cba\":\"5\"},{\"cca\":\"2\"},{\"cda\":\"4\"},\"value2\",\"value3\",\"value1\"]');\nassert oo['a']['aa']['aaa'] == 'value1' and oo == oo['b'] and oo['c']['ca']['caa'] == oo['c']['ca']\nprint('OK')",
        "detail": "front-end.trendora.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "oo",
        "kind": 5,
        "importPath": "front-end.trendora.node_modules.flatted.python.test",
        "description": "front-end.trendora.node_modules.flatted.python.test",
        "peekOfCode": "oo = parse('[{\"a\":\"1\",\"b\":\"0\",\"c\":\"2\"},{\"aa\":\"3\"},{\"ca\":\"4\",\"cb\":\"5\",\"cc\":\"6\",\"cd\":\"7\",\"ce\":\"8\",\"cf\":\"9\"},{\"aaa\":\"10\"},{\"caa\":\"4\"},{\"cba\":\"5\"},{\"cca\":\"2\"},{\"cda\":\"4\"},\"value2\",\"value3\",\"value1\"]');\nassert oo['a']['aa']['aaa'] == 'value1' and oo == oo['b'] and oo['c']['ca']['caa'] == oo['c']['ca']\nprint('OK')",
        "detail": "front-end.trendora.node_modules.flatted.python.test",
        "documentation": {}
    },
    {
        "label": "sys.modules[__name__]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.collections.abc",
        "description": "pycharm_venv.Lib.collections.abc",
        "peekOfCode": "sys.modules[__name__] = _collections_abc",
        "detail": "pycharm_venv.Lib.collections.abc",
        "documentation": {}
    },
    {
        "label": "aliases",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.aliases",
        "description": "pycharm_venv.Lib.encodings.aliases",
        "peekOfCode": "aliases = {\n    # Please keep this list sorted alphabetically by value !\n    # ascii codec\n    '646'                : 'ascii',\n    'ansi_x3.4_1968'     : 'ascii',\n    'ansi_x3_4_1968'     : 'ascii', # some email headers use this non-standard name\n    'ansi_x3.4_1986'     : 'ascii',\n    'cp367'              : 'ascii',\n    'csascii'            : 'ascii',\n    'ibm367'             : 'ascii',",
        "detail": "pycharm_venv.Lib.encodings.aliases",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.ascii",
        "description": "pycharm_venv.Lib.encodings.ascii",
        "peekOfCode": "class Codec(codecs.Codec):\n    # Note: Binding these as C functions will result in the class not\n    # converting them to methods. This is intended.\n    encode = codecs.ascii_encode\n    decode = codecs.ascii_decode\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.ascii_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.ascii",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.ascii",
        "description": "pycharm_venv.Lib.encodings.ascii",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.ascii_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.ascii_decode(input, self.errors)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.ascii",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.ascii",
        "description": "pycharm_venv.Lib.encodings.ascii",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.ascii_decode(input, self.errors)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\nclass StreamConverter(StreamWriter,StreamReader):\n    encode = codecs.ascii_decode\n    decode = codecs.ascii_encode",
        "detail": "pycharm_venv.Lib.encodings.ascii",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.ascii",
        "description": "pycharm_venv.Lib.encodings.ascii",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\nclass StreamConverter(StreamWriter,StreamReader):\n    encode = codecs.ascii_decode\n    decode = codecs.ascii_encode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.ascii",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.ascii",
        "description": "pycharm_venv.Lib.encodings.ascii",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\nclass StreamConverter(StreamWriter,StreamReader):\n    encode = codecs.ascii_decode\n    decode = codecs.ascii_encode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='ascii',\n        encode=Codec.encode,",
        "detail": "pycharm_venv.Lib.encodings.ascii",
        "documentation": {}
    },
    {
        "label": "StreamConverter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.ascii",
        "description": "pycharm_venv.Lib.encodings.ascii",
        "peekOfCode": "class StreamConverter(StreamWriter,StreamReader):\n    encode = codecs.ascii_decode\n    decode = codecs.ascii_encode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='ascii',\n        encode=Codec.encode,\n        decode=Codec.decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.ascii",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.ascii",
        "description": "pycharm_venv.Lib.encodings.ascii",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='ascii',\n        encode=Codec.encode,\n        decode=Codec.decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,\n        streamreader=StreamReader,\n    )",
        "detail": "pycharm_venv.Lib.encodings.ascii",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.base64_codec",
        "description": "pycharm_venv.Lib.encodings.base64_codec",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        return base64_encode(input, errors)\n    def decode(self, input, errors='strict'):\n        return base64_decode(input, errors)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        assert self.errors == 'strict'\n        return base64.encodebytes(input)\nclass IncrementalDecoder(codecs.IncrementalDecoder):",
        "detail": "pycharm_venv.Lib.encodings.base64_codec",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.base64_codec",
        "description": "pycharm_venv.Lib.encodings.base64_codec",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        assert self.errors == 'strict'\n        return base64.encodebytes(input)\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        assert self.errors == 'strict'\n        return base64.decodebytes(input)\nclass StreamWriter(Codec, codecs.StreamWriter):\n    charbuffertype = bytes",
        "detail": "pycharm_venv.Lib.encodings.base64_codec",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.base64_codec",
        "description": "pycharm_venv.Lib.encodings.base64_codec",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        assert self.errors == 'strict'\n        return base64.decodebytes(input)\nclass StreamWriter(Codec, codecs.StreamWriter):\n    charbuffertype = bytes\nclass StreamReader(Codec, codecs.StreamReader):\n    charbuffertype = bytes\n### encodings module API\ndef getregentry():",
        "detail": "pycharm_venv.Lib.encodings.base64_codec",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.base64_codec",
        "description": "pycharm_venv.Lib.encodings.base64_codec",
        "peekOfCode": "class StreamWriter(Codec, codecs.StreamWriter):\n    charbuffertype = bytes\nclass StreamReader(Codec, codecs.StreamReader):\n    charbuffertype = bytes\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='base64',\n        encode=base64_encode,\n        decode=base64_decode,",
        "detail": "pycharm_venv.Lib.encodings.base64_codec",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.base64_codec",
        "description": "pycharm_venv.Lib.encodings.base64_codec",
        "peekOfCode": "class StreamReader(Codec, codecs.StreamReader):\n    charbuffertype = bytes\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='base64',\n        encode=base64_encode,\n        decode=base64_decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.base64_codec",
        "documentation": {}
    },
    {
        "label": "base64_encode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.base64_codec",
        "description": "pycharm_venv.Lib.encodings.base64_codec",
        "peekOfCode": "def base64_encode(input, errors='strict'):\n    assert errors == 'strict'\n    return (base64.encodebytes(input), len(input))\ndef base64_decode(input, errors='strict'):\n    assert errors == 'strict'\n    return (base64.decodebytes(input), len(input))\nclass Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        return base64_encode(input, errors)\n    def decode(self, input, errors='strict'):",
        "detail": "pycharm_venv.Lib.encodings.base64_codec",
        "documentation": {}
    },
    {
        "label": "base64_decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.base64_codec",
        "description": "pycharm_venv.Lib.encodings.base64_codec",
        "peekOfCode": "def base64_decode(input, errors='strict'):\n    assert errors == 'strict'\n    return (base64.decodebytes(input), len(input))\nclass Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        return base64_encode(input, errors)\n    def decode(self, input, errors='strict'):\n        return base64_decode(input, errors)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.base64_codec",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.base64_codec",
        "description": "pycharm_venv.Lib.encodings.base64_codec",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='base64',\n        encode=base64_encode,\n        decode=base64_decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,\n        streamreader=StreamReader,\n        _is_text_encoding=False,",
        "detail": "pycharm_venv.Lib.encodings.base64_codec",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.big5",
        "description": "pycharm_venv.Lib.encodings.big5",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.big5",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.big5",
        "description": "pycharm_venv.Lib.encodings.big5",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.big5",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.big5",
        "description": "pycharm_venv.Lib.encodings.big5",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='big5',",
        "detail": "pycharm_venv.Lib.encodings.big5",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.big5",
        "description": "pycharm_venv.Lib.encodings.big5",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='big5',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.big5",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.big5",
        "description": "pycharm_venv.Lib.encodings.big5",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='big5',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.big5",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.big5",
        "description": "pycharm_venv.Lib.encodings.big5",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='big5',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.big5",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.big5",
        "description": "pycharm_venv.Lib.encodings.big5",
        "peekOfCode": "codec = _codecs_tw.getcodec('big5')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.big5",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.big5hkscs",
        "description": "pycharm_venv.Lib.encodings.big5hkscs",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.big5hkscs",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.big5hkscs",
        "description": "pycharm_venv.Lib.encodings.big5hkscs",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.big5hkscs",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.big5hkscs",
        "description": "pycharm_venv.Lib.encodings.big5hkscs",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='big5hkscs',",
        "detail": "pycharm_venv.Lib.encodings.big5hkscs",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.big5hkscs",
        "description": "pycharm_venv.Lib.encodings.big5hkscs",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='big5hkscs',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.big5hkscs",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.big5hkscs",
        "description": "pycharm_venv.Lib.encodings.big5hkscs",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='big5hkscs',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.big5hkscs",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.big5hkscs",
        "description": "pycharm_venv.Lib.encodings.big5hkscs",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='big5hkscs',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.big5hkscs",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.big5hkscs",
        "description": "pycharm_venv.Lib.encodings.big5hkscs",
        "peekOfCode": "codec = _codecs_hk.getcodec('big5hkscs')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.big5hkscs",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.bz2_codec",
        "description": "pycharm_venv.Lib.encodings.bz2_codec",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        return bz2_encode(input, errors)\n    def decode(self, input, errors='strict'):\n        return bz2_decode(input, errors)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def __init__(self, errors='strict'):\n        assert errors == 'strict'\n        self.errors = errors\n        self.compressobj = bz2.BZ2Compressor()",
        "detail": "pycharm_venv.Lib.encodings.bz2_codec",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.bz2_codec",
        "description": "pycharm_venv.Lib.encodings.bz2_codec",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def __init__(self, errors='strict'):\n        assert errors == 'strict'\n        self.errors = errors\n        self.compressobj = bz2.BZ2Compressor()\n    def encode(self, input, final=False):\n        if final:\n            c = self.compressobj.compress(input)\n            return c + self.compressobj.flush()\n        else:",
        "detail": "pycharm_venv.Lib.encodings.bz2_codec",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.bz2_codec",
        "description": "pycharm_venv.Lib.encodings.bz2_codec",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def __init__(self, errors='strict'):\n        assert errors == 'strict'\n        self.errors = errors\n        self.decompressobj = bz2.BZ2Decompressor()\n    def decode(self, input, final=False):\n        try:\n            return self.decompressobj.decompress(input)\n        except EOFError:\n            return ''",
        "detail": "pycharm_venv.Lib.encodings.bz2_codec",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.bz2_codec",
        "description": "pycharm_venv.Lib.encodings.bz2_codec",
        "peekOfCode": "class StreamWriter(Codec, codecs.StreamWriter):\n    charbuffertype = bytes\nclass StreamReader(Codec, codecs.StreamReader):\n    charbuffertype = bytes\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name=\"bz2\",\n        encode=bz2_encode,\n        decode=bz2_decode,",
        "detail": "pycharm_venv.Lib.encodings.bz2_codec",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.bz2_codec",
        "description": "pycharm_venv.Lib.encodings.bz2_codec",
        "peekOfCode": "class StreamReader(Codec, codecs.StreamReader):\n    charbuffertype = bytes\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name=\"bz2\",\n        encode=bz2_encode,\n        decode=bz2_decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.bz2_codec",
        "documentation": {}
    },
    {
        "label": "bz2_encode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.bz2_codec",
        "description": "pycharm_venv.Lib.encodings.bz2_codec",
        "peekOfCode": "def bz2_encode(input, errors='strict'):\n    assert errors == 'strict'\n    return (bz2.compress(input), len(input))\ndef bz2_decode(input, errors='strict'):\n    assert errors == 'strict'\n    return (bz2.decompress(input), len(input))\nclass Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        return bz2_encode(input, errors)\n    def decode(self, input, errors='strict'):",
        "detail": "pycharm_venv.Lib.encodings.bz2_codec",
        "documentation": {}
    },
    {
        "label": "bz2_decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.bz2_codec",
        "description": "pycharm_venv.Lib.encodings.bz2_codec",
        "peekOfCode": "def bz2_decode(input, errors='strict'):\n    assert errors == 'strict'\n    return (bz2.decompress(input), len(input))\nclass Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        return bz2_encode(input, errors)\n    def decode(self, input, errors='strict'):\n        return bz2_decode(input, errors)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def __init__(self, errors='strict'):",
        "detail": "pycharm_venv.Lib.encodings.bz2_codec",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.bz2_codec",
        "description": "pycharm_venv.Lib.encodings.bz2_codec",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name=\"bz2\",\n        encode=bz2_encode,\n        decode=bz2_decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,\n        streamreader=StreamReader,\n        _is_text_encoding=False,",
        "detail": "pycharm_venv.Lib.encodings.bz2_codec",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.charmap",
        "description": "pycharm_venv.Lib.encodings.charmap",
        "peekOfCode": "class Codec(codecs.Codec):\n    # Note: Binding these as C functions will result in the class not\n    # converting them to methods. This is intended.\n    encode = codecs.charmap_encode\n    decode = codecs.charmap_decode\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def __init__(self, errors='strict', mapping=None):\n        codecs.IncrementalEncoder.__init__(self, errors)\n        self.mapping = mapping\n    def encode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.charmap",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.charmap",
        "description": "pycharm_venv.Lib.encodings.charmap",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def __init__(self, errors='strict', mapping=None):\n        codecs.IncrementalEncoder.__init__(self, errors)\n        self.mapping = mapping\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input, self.errors, self.mapping)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def __init__(self, errors='strict', mapping=None):\n        codecs.IncrementalDecoder.__init__(self, errors)\n        self.mapping = mapping",
        "detail": "pycharm_venv.Lib.encodings.charmap",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.charmap",
        "description": "pycharm_venv.Lib.encodings.charmap",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def __init__(self, errors='strict', mapping=None):\n        codecs.IncrementalDecoder.__init__(self, errors)\n        self.mapping = mapping\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input, self.errors, self.mapping)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    def __init__(self,stream,errors='strict',mapping=None):\n        codecs.StreamWriter.__init__(self,stream,errors)\n        self.mapping = mapping",
        "detail": "pycharm_venv.Lib.encodings.charmap",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.charmap",
        "description": "pycharm_venv.Lib.encodings.charmap",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    def __init__(self,stream,errors='strict',mapping=None):\n        codecs.StreamWriter.__init__(self,stream,errors)\n        self.mapping = mapping\n    def encode(self,input,errors='strict'):\n        return Codec.encode(input,errors,self.mapping)\nclass StreamReader(Codec,codecs.StreamReader):\n    def __init__(self,stream,errors='strict',mapping=None):\n        codecs.StreamReader.__init__(self,stream,errors)\n        self.mapping = mapping",
        "detail": "pycharm_venv.Lib.encodings.charmap",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.charmap",
        "description": "pycharm_venv.Lib.encodings.charmap",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    def __init__(self,stream,errors='strict',mapping=None):\n        codecs.StreamReader.__init__(self,stream,errors)\n        self.mapping = mapping\n    def decode(self,input,errors='strict'):\n        return Codec.decode(input,errors,self.mapping)\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='charmap',",
        "detail": "pycharm_venv.Lib.encodings.charmap",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.charmap",
        "description": "pycharm_venv.Lib.encodings.charmap",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='charmap',\n        encode=Codec.encode,\n        decode=Codec.decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,\n        streamreader=StreamReader,\n    )",
        "detail": "pycharm_venv.Lib.encodings.charmap",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp037",
        "description": "pycharm_venv.Lib.encodings.cp037",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp037",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp037",
        "description": "pycharm_venv.Lib.encodings.cp037",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp037",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp037",
        "description": "pycharm_venv.Lib.encodings.cp037",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp037",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp037",
        "description": "pycharm_venv.Lib.encodings.cp037",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp037',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp037",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp037",
        "description": "pycharm_venv.Lib.encodings.cp037",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp037',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp037",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp037",
        "description": "pycharm_venv.Lib.encodings.cp037",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp037',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp037",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp037",
        "description": "pycharm_venv.Lib.encodings.cp037",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x9c'     #  0x04 -> CONTROL\n    '\\t'       #  0x05 -> HORIZONTAL TABULATION\n    '\\x86'     #  0x06 -> CONTROL\n    '\\x7f'     #  0x07 -> DELETE\n    '\\x97'     #  0x08 -> CONTROL",
        "detail": "pycharm_venv.Lib.encodings.cp037",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1006",
        "description": "pycharm_venv.Lib.encodings.cp1006",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp1006",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1006",
        "description": "pycharm_venv.Lib.encodings.cp1006",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp1006",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1006",
        "description": "pycharm_venv.Lib.encodings.cp1006",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp1006",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1006",
        "description": "pycharm_venv.Lib.encodings.cp1006",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1006',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp1006",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1006",
        "description": "pycharm_venv.Lib.encodings.cp1006",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1006',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp1006",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp1006",
        "description": "pycharm_venv.Lib.encodings.cp1006",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp1006',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp1006",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp1006",
        "description": "pycharm_venv.Lib.encodings.cp1006",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp1006",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1026",
        "description": "pycharm_venv.Lib.encodings.cp1026",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp1026",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1026",
        "description": "pycharm_venv.Lib.encodings.cp1026",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp1026",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1026",
        "description": "pycharm_venv.Lib.encodings.cp1026",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp1026",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1026",
        "description": "pycharm_venv.Lib.encodings.cp1026",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1026',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp1026",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1026",
        "description": "pycharm_venv.Lib.encodings.cp1026",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1026',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp1026",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp1026",
        "description": "pycharm_venv.Lib.encodings.cp1026",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp1026',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp1026",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp1026",
        "description": "pycharm_venv.Lib.encodings.cp1026",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x9c'     #  0x04 -> CONTROL\n    '\\t'       #  0x05 -> HORIZONTAL TABULATION\n    '\\x86'     #  0x06 -> CONTROL\n    '\\x7f'     #  0x07 -> DELETE\n    '\\x97'     #  0x08 -> CONTROL",
        "detail": "pycharm_venv.Lib.encodings.cp1026",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1125",
        "description": "pycharm_venv.Lib.encodings.cp1125",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_map)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp1125",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1125",
        "description": "pycharm_venv.Lib.encodings.cp1125",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp1125",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1125",
        "description": "pycharm_venv.Lib.encodings.cp1125",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp1125",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1125",
        "description": "pycharm_venv.Lib.encodings.cp1125",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1125',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp1125",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1125",
        "description": "pycharm_venv.Lib.encodings.cp1125",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1125',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp1125",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp1125",
        "description": "pycharm_venv.Lib.encodings.cp1125",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp1125',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp1125",
        "documentation": {}
    },
    {
        "label": "decoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp1125",
        "description": "pycharm_venv.Lib.encodings.cp1125",
        "peekOfCode": "decoding_map = codecs.make_identity_dict(range(256))\ndecoding_map.update({\n    0x0080: 0x0410,     #  CYRILLIC CAPITAL LETTER A\n    0x0081: 0x0411,     #  CYRILLIC CAPITAL LETTER BE\n    0x0082: 0x0412,     #  CYRILLIC CAPITAL LETTER VE\n    0x0083: 0x0413,     #  CYRILLIC CAPITAL LETTER GHE\n    0x0084: 0x0414,     #  CYRILLIC CAPITAL LETTER DE\n    0x0085: 0x0415,     #  CYRILLIC CAPITAL LETTER IE\n    0x0086: 0x0416,     #  CYRILLIC CAPITAL LETTER ZHE\n    0x0087: 0x0417,     #  CYRILLIC CAPITAL LETTER ZE",
        "detail": "pycharm_venv.Lib.encodings.cp1125",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp1125",
        "description": "pycharm_venv.Lib.encodings.cp1125",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x0000 -> NULL\n    '\\x01'     #  0x0001 -> START OF HEADING\n    '\\x02'     #  0x0002 -> START OF TEXT\n    '\\x03'     #  0x0003 -> END OF TEXT\n    '\\x04'     #  0x0004 -> END OF TRANSMISSION\n    '\\x05'     #  0x0005 -> ENQUIRY\n    '\\x06'     #  0x0006 -> ACKNOWLEDGE\n    '\\x07'     #  0x0007 -> BELL\n    '\\x08'     #  0x0008 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp1125",
        "documentation": {}
    },
    {
        "label": "encoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp1125",
        "description": "pycharm_venv.Lib.encodings.cp1125",
        "peekOfCode": "encoding_map = {\n    0x0000: 0x0000,     #  NULL\n    0x0001: 0x0001,     #  START OF HEADING\n    0x0002: 0x0002,     #  START OF TEXT\n    0x0003: 0x0003,     #  END OF TEXT\n    0x0004: 0x0004,     #  END OF TRANSMISSION\n    0x0005: 0x0005,     #  ENQUIRY\n    0x0006: 0x0006,     #  ACKNOWLEDGE\n    0x0007: 0x0007,     #  BELL\n    0x0008: 0x0008,     #  BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp1125",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1140",
        "description": "pycharm_venv.Lib.encodings.cp1140",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp1140",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1140",
        "description": "pycharm_venv.Lib.encodings.cp1140",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp1140",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1140",
        "description": "pycharm_venv.Lib.encodings.cp1140",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp1140",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1140",
        "description": "pycharm_venv.Lib.encodings.cp1140",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1140',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp1140",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1140",
        "description": "pycharm_venv.Lib.encodings.cp1140",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1140',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp1140",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp1140",
        "description": "pycharm_venv.Lib.encodings.cp1140",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp1140',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp1140",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp1140",
        "description": "pycharm_venv.Lib.encodings.cp1140",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x9c'     #  0x04 -> CONTROL\n    '\\t'       #  0x05 -> HORIZONTAL TABULATION\n    '\\x86'     #  0x06 -> CONTROL\n    '\\x7f'     #  0x07 -> DELETE\n    '\\x97'     #  0x08 -> CONTROL",
        "detail": "pycharm_venv.Lib.encodings.cp1140",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1250",
        "description": "pycharm_venv.Lib.encodings.cp1250",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp1250",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1250",
        "description": "pycharm_venv.Lib.encodings.cp1250",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp1250",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1250",
        "description": "pycharm_venv.Lib.encodings.cp1250",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp1250",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1250",
        "description": "pycharm_venv.Lib.encodings.cp1250",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1250',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp1250",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1250",
        "description": "pycharm_venv.Lib.encodings.cp1250",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1250',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp1250",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp1250",
        "description": "pycharm_venv.Lib.encodings.cp1250",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp1250',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp1250",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp1250",
        "description": "pycharm_venv.Lib.encodings.cp1250",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp1250",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1251",
        "description": "pycharm_venv.Lib.encodings.cp1251",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp1251",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1251",
        "description": "pycharm_venv.Lib.encodings.cp1251",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp1251",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1251",
        "description": "pycharm_venv.Lib.encodings.cp1251",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp1251",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1251",
        "description": "pycharm_venv.Lib.encodings.cp1251",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1251',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp1251",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1251",
        "description": "pycharm_venv.Lib.encodings.cp1251",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1251',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp1251",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp1251",
        "description": "pycharm_venv.Lib.encodings.cp1251",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp1251',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp1251",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp1251",
        "description": "pycharm_venv.Lib.encodings.cp1251",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp1251",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1252",
        "description": "pycharm_venv.Lib.encodings.cp1252",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp1252",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1252",
        "description": "pycharm_venv.Lib.encodings.cp1252",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp1252",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1252",
        "description": "pycharm_venv.Lib.encodings.cp1252",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp1252",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1252",
        "description": "pycharm_venv.Lib.encodings.cp1252",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1252',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp1252",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1252",
        "description": "pycharm_venv.Lib.encodings.cp1252",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1252',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp1252",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp1252",
        "description": "pycharm_venv.Lib.encodings.cp1252",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp1252',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp1252",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp1252",
        "description": "pycharm_venv.Lib.encodings.cp1252",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp1252",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1253",
        "description": "pycharm_venv.Lib.encodings.cp1253",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp1253",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1253",
        "description": "pycharm_venv.Lib.encodings.cp1253",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp1253",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1253",
        "description": "pycharm_venv.Lib.encodings.cp1253",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp1253",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1253",
        "description": "pycharm_venv.Lib.encodings.cp1253",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1253',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp1253",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1253",
        "description": "pycharm_venv.Lib.encodings.cp1253",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1253',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp1253",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp1253",
        "description": "pycharm_venv.Lib.encodings.cp1253",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp1253',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp1253",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp1253",
        "description": "pycharm_venv.Lib.encodings.cp1253",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp1253",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1254",
        "description": "pycharm_venv.Lib.encodings.cp1254",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp1254",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1254",
        "description": "pycharm_venv.Lib.encodings.cp1254",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp1254",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1254",
        "description": "pycharm_venv.Lib.encodings.cp1254",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp1254",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1254",
        "description": "pycharm_venv.Lib.encodings.cp1254",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1254',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp1254",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1254",
        "description": "pycharm_venv.Lib.encodings.cp1254",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1254',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp1254",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp1254",
        "description": "pycharm_venv.Lib.encodings.cp1254",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp1254',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp1254",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp1254",
        "description": "pycharm_venv.Lib.encodings.cp1254",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp1254",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1255",
        "description": "pycharm_venv.Lib.encodings.cp1255",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp1255",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1255",
        "description": "pycharm_venv.Lib.encodings.cp1255",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp1255",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1255",
        "description": "pycharm_venv.Lib.encodings.cp1255",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp1255",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1255",
        "description": "pycharm_venv.Lib.encodings.cp1255",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1255',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp1255",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1255",
        "description": "pycharm_venv.Lib.encodings.cp1255",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1255',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp1255",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp1255",
        "description": "pycharm_venv.Lib.encodings.cp1255",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp1255',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp1255",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp1255",
        "description": "pycharm_venv.Lib.encodings.cp1255",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp1255",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1256",
        "description": "pycharm_venv.Lib.encodings.cp1256",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp1256",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1256",
        "description": "pycharm_venv.Lib.encodings.cp1256",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp1256",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1256",
        "description": "pycharm_venv.Lib.encodings.cp1256",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp1256",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1256",
        "description": "pycharm_venv.Lib.encodings.cp1256",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1256',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp1256",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1256",
        "description": "pycharm_venv.Lib.encodings.cp1256",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1256',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp1256",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp1256",
        "description": "pycharm_venv.Lib.encodings.cp1256",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp1256',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp1256",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp1256",
        "description": "pycharm_venv.Lib.encodings.cp1256",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp1256",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1257",
        "description": "pycharm_venv.Lib.encodings.cp1257",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp1257",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1257",
        "description": "pycharm_venv.Lib.encodings.cp1257",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp1257",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1257",
        "description": "pycharm_venv.Lib.encodings.cp1257",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp1257",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1257",
        "description": "pycharm_venv.Lib.encodings.cp1257",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1257',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp1257",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1257",
        "description": "pycharm_venv.Lib.encodings.cp1257",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1257',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp1257",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp1257",
        "description": "pycharm_venv.Lib.encodings.cp1257",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp1257',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp1257",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp1257",
        "description": "pycharm_venv.Lib.encodings.cp1257",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp1257",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1258",
        "description": "pycharm_venv.Lib.encodings.cp1258",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp1258",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1258",
        "description": "pycharm_venv.Lib.encodings.cp1258",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp1258",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1258",
        "description": "pycharm_venv.Lib.encodings.cp1258",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp1258",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1258",
        "description": "pycharm_venv.Lib.encodings.cp1258",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1258',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp1258",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp1258",
        "description": "pycharm_venv.Lib.encodings.cp1258",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1258',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp1258",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp1258",
        "description": "pycharm_venv.Lib.encodings.cp1258",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp1258',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp1258",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp1258",
        "description": "pycharm_venv.Lib.encodings.cp1258",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp1258",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp273",
        "description": "pycharm_venv.Lib.encodings.cp273",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp273",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp273",
        "description": "pycharm_venv.Lib.encodings.cp273",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp273",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp273",
        "description": "pycharm_venv.Lib.encodings.cp273",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp273",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp273",
        "description": "pycharm_venv.Lib.encodings.cp273",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp273',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp273",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp273",
        "description": "pycharm_venv.Lib.encodings.cp273",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp273',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp273",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp273",
        "description": "pycharm_venv.Lib.encodings.cp273",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp273',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp273",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp273",
        "description": "pycharm_venv.Lib.encodings.cp273",
        "peekOfCode": "decoding_table = (\n    '\\x00'      #  0x00 -> NULL (NUL)\n    '\\x01'      #  0x01 -> START OF HEADING (SOH)\n    '\\x02'      #  0x02 -> START OF TEXT (STX)\n    '\\x03'      #  0x03 -> END OF TEXT (ETX)\n    '\\x9c'      #  0x04 -> STRING TERMINATOR (ST)\n    '\\t'        #  0x05 -> CHARACTER TABULATION (HT)\n    '\\x86'      #  0x06 -> START OF SELECTED AREA (SSA)\n    '\\x7f'      #  0x07 -> DELETE (DEL)\n    '\\x97'      #  0x08 -> END OF GUARDED AREA (EPA)",
        "detail": "pycharm_venv.Lib.encodings.cp273",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp424",
        "description": "pycharm_venv.Lib.encodings.cp424",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp424",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp424",
        "description": "pycharm_venv.Lib.encodings.cp424",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp424",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp424",
        "description": "pycharm_venv.Lib.encodings.cp424",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp424",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp424",
        "description": "pycharm_venv.Lib.encodings.cp424",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp424',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp424",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp424",
        "description": "pycharm_venv.Lib.encodings.cp424",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp424',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp424",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp424",
        "description": "pycharm_venv.Lib.encodings.cp424",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp424',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp424",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp424",
        "description": "pycharm_venv.Lib.encodings.cp424",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x9c'     #  0x04 -> SELECT\n    '\\t'       #  0x05 -> HORIZONTAL TABULATION\n    '\\x86'     #  0x06 -> REQUIRED NEW LINE\n    '\\x7f'     #  0x07 -> DELETE\n    '\\x97'     #  0x08 -> GRAPHIC ESCAPE",
        "detail": "pycharm_venv.Lib.encodings.cp424",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp437",
        "description": "pycharm_venv.Lib.encodings.cp437",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_map)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp437",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp437",
        "description": "pycharm_venv.Lib.encodings.cp437",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp437",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp437",
        "description": "pycharm_venv.Lib.encodings.cp437",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp437",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp437",
        "description": "pycharm_venv.Lib.encodings.cp437",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp437',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp437",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp437",
        "description": "pycharm_venv.Lib.encodings.cp437",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp437',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp437",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp437",
        "description": "pycharm_venv.Lib.encodings.cp437",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp437',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp437",
        "documentation": {}
    },
    {
        "label": "decoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp437",
        "description": "pycharm_venv.Lib.encodings.cp437",
        "peekOfCode": "decoding_map = codecs.make_identity_dict(range(256))\ndecoding_map.update({\n    0x0080: 0x00c7,     #  LATIN CAPITAL LETTER C WITH CEDILLA\n    0x0081: 0x00fc,     #  LATIN SMALL LETTER U WITH DIAERESIS\n    0x0082: 0x00e9,     #  LATIN SMALL LETTER E WITH ACUTE\n    0x0083: 0x00e2,     #  LATIN SMALL LETTER A WITH CIRCUMFLEX\n    0x0084: 0x00e4,     #  LATIN SMALL LETTER A WITH DIAERESIS\n    0x0085: 0x00e0,     #  LATIN SMALL LETTER A WITH GRAVE\n    0x0086: 0x00e5,     #  LATIN SMALL LETTER A WITH RING ABOVE\n    0x0087: 0x00e7,     #  LATIN SMALL LETTER C WITH CEDILLA",
        "detail": "pycharm_venv.Lib.encodings.cp437",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp437",
        "description": "pycharm_venv.Lib.encodings.cp437",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x0000 -> NULL\n    '\\x01'     #  0x0001 -> START OF HEADING\n    '\\x02'     #  0x0002 -> START OF TEXT\n    '\\x03'     #  0x0003 -> END OF TEXT\n    '\\x04'     #  0x0004 -> END OF TRANSMISSION\n    '\\x05'     #  0x0005 -> ENQUIRY\n    '\\x06'     #  0x0006 -> ACKNOWLEDGE\n    '\\x07'     #  0x0007 -> BELL\n    '\\x08'     #  0x0008 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp437",
        "documentation": {}
    },
    {
        "label": "encoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp437",
        "description": "pycharm_venv.Lib.encodings.cp437",
        "peekOfCode": "encoding_map = {\n    0x0000: 0x0000,     #  NULL\n    0x0001: 0x0001,     #  START OF HEADING\n    0x0002: 0x0002,     #  START OF TEXT\n    0x0003: 0x0003,     #  END OF TEXT\n    0x0004: 0x0004,     #  END OF TRANSMISSION\n    0x0005: 0x0005,     #  ENQUIRY\n    0x0006: 0x0006,     #  ACKNOWLEDGE\n    0x0007: 0x0007,     #  BELL\n    0x0008: 0x0008,     #  BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp437",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp500",
        "description": "pycharm_venv.Lib.encodings.cp500",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp500",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp500",
        "description": "pycharm_venv.Lib.encodings.cp500",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp500",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp500",
        "description": "pycharm_venv.Lib.encodings.cp500",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp500",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp500",
        "description": "pycharm_venv.Lib.encodings.cp500",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp500',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp500",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp500",
        "description": "pycharm_venv.Lib.encodings.cp500",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp500',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp500",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp500",
        "description": "pycharm_venv.Lib.encodings.cp500",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp500',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp500",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp500",
        "description": "pycharm_venv.Lib.encodings.cp500",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x9c'     #  0x04 -> CONTROL\n    '\\t'       #  0x05 -> HORIZONTAL TABULATION\n    '\\x86'     #  0x06 -> CONTROL\n    '\\x7f'     #  0x07 -> DELETE\n    '\\x97'     #  0x08 -> CONTROL",
        "detail": "pycharm_venv.Lib.encodings.cp500",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp720",
        "description": "pycharm_venv.Lib.encodings.cp720",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp720",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp720",
        "description": "pycharm_venv.Lib.encodings.cp720",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp720",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp720",
        "description": "pycharm_venv.Lib.encodings.cp720",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp720",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp720",
        "description": "pycharm_venv.Lib.encodings.cp720",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp720',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp720",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp720",
        "description": "pycharm_venv.Lib.encodings.cp720",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp720',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp720",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp720",
        "description": "pycharm_venv.Lib.encodings.cp720",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp720',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp720",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp720",
        "description": "pycharm_venv.Lib.encodings.cp720",
        "peekOfCode": "decoding_table = (\n    '\\x00'      #  0x00 -> CONTROL CHARACTER\n    '\\x01'      #  0x01 -> CONTROL CHARACTER\n    '\\x02'      #  0x02 -> CONTROL CHARACTER\n    '\\x03'      #  0x03 -> CONTROL CHARACTER\n    '\\x04'      #  0x04 -> CONTROL CHARACTER\n    '\\x05'      #  0x05 -> CONTROL CHARACTER\n    '\\x06'      #  0x06 -> CONTROL CHARACTER\n    '\\x07'      #  0x07 -> CONTROL CHARACTER\n    '\\x08'      #  0x08 -> CONTROL CHARACTER",
        "detail": "pycharm_venv.Lib.encodings.cp720",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp737",
        "description": "pycharm_venv.Lib.encodings.cp737",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_map)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp737",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp737",
        "description": "pycharm_venv.Lib.encodings.cp737",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp737",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp737",
        "description": "pycharm_venv.Lib.encodings.cp737",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp737",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp737",
        "description": "pycharm_venv.Lib.encodings.cp737",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp737',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp737",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp737",
        "description": "pycharm_venv.Lib.encodings.cp737",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp737',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp737",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp737",
        "description": "pycharm_venv.Lib.encodings.cp737",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp737',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp737",
        "documentation": {}
    },
    {
        "label": "decoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp737",
        "description": "pycharm_venv.Lib.encodings.cp737",
        "peekOfCode": "decoding_map = codecs.make_identity_dict(range(256))\ndecoding_map.update({\n    0x0080: 0x0391,     #  GREEK CAPITAL LETTER ALPHA\n    0x0081: 0x0392,     #  GREEK CAPITAL LETTER BETA\n    0x0082: 0x0393,     #  GREEK CAPITAL LETTER GAMMA\n    0x0083: 0x0394,     #  GREEK CAPITAL LETTER DELTA\n    0x0084: 0x0395,     #  GREEK CAPITAL LETTER EPSILON\n    0x0085: 0x0396,     #  GREEK CAPITAL LETTER ZETA\n    0x0086: 0x0397,     #  GREEK CAPITAL LETTER ETA\n    0x0087: 0x0398,     #  GREEK CAPITAL LETTER THETA",
        "detail": "pycharm_venv.Lib.encodings.cp737",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp737",
        "description": "pycharm_venv.Lib.encodings.cp737",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x0000 -> NULL\n    '\\x01'     #  0x0001 -> START OF HEADING\n    '\\x02'     #  0x0002 -> START OF TEXT\n    '\\x03'     #  0x0003 -> END OF TEXT\n    '\\x04'     #  0x0004 -> END OF TRANSMISSION\n    '\\x05'     #  0x0005 -> ENQUIRY\n    '\\x06'     #  0x0006 -> ACKNOWLEDGE\n    '\\x07'     #  0x0007 -> BELL\n    '\\x08'     #  0x0008 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp737",
        "documentation": {}
    },
    {
        "label": "encoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp737",
        "description": "pycharm_venv.Lib.encodings.cp737",
        "peekOfCode": "encoding_map = {\n    0x0000: 0x0000,     #  NULL\n    0x0001: 0x0001,     #  START OF HEADING\n    0x0002: 0x0002,     #  START OF TEXT\n    0x0003: 0x0003,     #  END OF TEXT\n    0x0004: 0x0004,     #  END OF TRANSMISSION\n    0x0005: 0x0005,     #  ENQUIRY\n    0x0006: 0x0006,     #  ACKNOWLEDGE\n    0x0007: 0x0007,     #  BELL\n    0x0008: 0x0008,     #  BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp737",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp775",
        "description": "pycharm_venv.Lib.encodings.cp775",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_map)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp775",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp775",
        "description": "pycharm_venv.Lib.encodings.cp775",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp775",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp775",
        "description": "pycharm_venv.Lib.encodings.cp775",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp775",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp775",
        "description": "pycharm_venv.Lib.encodings.cp775",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp775',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp775",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp775",
        "description": "pycharm_venv.Lib.encodings.cp775",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp775',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp775",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp775",
        "description": "pycharm_venv.Lib.encodings.cp775",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp775',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp775",
        "documentation": {}
    },
    {
        "label": "decoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp775",
        "description": "pycharm_venv.Lib.encodings.cp775",
        "peekOfCode": "decoding_map = codecs.make_identity_dict(range(256))\ndecoding_map.update({\n    0x0080: 0x0106,     #  LATIN CAPITAL LETTER C WITH ACUTE\n    0x0081: 0x00fc,     #  LATIN SMALL LETTER U WITH DIAERESIS\n    0x0082: 0x00e9,     #  LATIN SMALL LETTER E WITH ACUTE\n    0x0083: 0x0101,     #  LATIN SMALL LETTER A WITH MACRON\n    0x0084: 0x00e4,     #  LATIN SMALL LETTER A WITH DIAERESIS\n    0x0085: 0x0123,     #  LATIN SMALL LETTER G WITH CEDILLA\n    0x0086: 0x00e5,     #  LATIN SMALL LETTER A WITH RING ABOVE\n    0x0087: 0x0107,     #  LATIN SMALL LETTER C WITH ACUTE",
        "detail": "pycharm_venv.Lib.encodings.cp775",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp775",
        "description": "pycharm_venv.Lib.encodings.cp775",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x0000 -> NULL\n    '\\x01'     #  0x0001 -> START OF HEADING\n    '\\x02'     #  0x0002 -> START OF TEXT\n    '\\x03'     #  0x0003 -> END OF TEXT\n    '\\x04'     #  0x0004 -> END OF TRANSMISSION\n    '\\x05'     #  0x0005 -> ENQUIRY\n    '\\x06'     #  0x0006 -> ACKNOWLEDGE\n    '\\x07'     #  0x0007 -> BELL\n    '\\x08'     #  0x0008 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp775",
        "documentation": {}
    },
    {
        "label": "encoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp775",
        "description": "pycharm_venv.Lib.encodings.cp775",
        "peekOfCode": "encoding_map = {\n    0x0000: 0x0000,     #  NULL\n    0x0001: 0x0001,     #  START OF HEADING\n    0x0002: 0x0002,     #  START OF TEXT\n    0x0003: 0x0003,     #  END OF TEXT\n    0x0004: 0x0004,     #  END OF TRANSMISSION\n    0x0005: 0x0005,     #  ENQUIRY\n    0x0006: 0x0006,     #  ACKNOWLEDGE\n    0x0007: 0x0007,     #  BELL\n    0x0008: 0x0008,     #  BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp775",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp850",
        "description": "pycharm_venv.Lib.encodings.cp850",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_map)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp850",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp850",
        "description": "pycharm_venv.Lib.encodings.cp850",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp850",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp850",
        "description": "pycharm_venv.Lib.encodings.cp850",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp850",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp850",
        "description": "pycharm_venv.Lib.encodings.cp850",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp850',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp850",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp850",
        "description": "pycharm_venv.Lib.encodings.cp850",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp850',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp850",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp850",
        "description": "pycharm_venv.Lib.encodings.cp850",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp850',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp850",
        "documentation": {}
    },
    {
        "label": "decoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp850",
        "description": "pycharm_venv.Lib.encodings.cp850",
        "peekOfCode": "decoding_map = codecs.make_identity_dict(range(256))\ndecoding_map.update({\n    0x0080: 0x00c7,     #  LATIN CAPITAL LETTER C WITH CEDILLA\n    0x0081: 0x00fc,     #  LATIN SMALL LETTER U WITH DIAERESIS\n    0x0082: 0x00e9,     #  LATIN SMALL LETTER E WITH ACUTE\n    0x0083: 0x00e2,     #  LATIN SMALL LETTER A WITH CIRCUMFLEX\n    0x0084: 0x00e4,     #  LATIN SMALL LETTER A WITH DIAERESIS\n    0x0085: 0x00e0,     #  LATIN SMALL LETTER A WITH GRAVE\n    0x0086: 0x00e5,     #  LATIN SMALL LETTER A WITH RING ABOVE\n    0x0087: 0x00e7,     #  LATIN SMALL LETTER C WITH CEDILLA",
        "detail": "pycharm_venv.Lib.encodings.cp850",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp850",
        "description": "pycharm_venv.Lib.encodings.cp850",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x0000 -> NULL\n    '\\x01'     #  0x0001 -> START OF HEADING\n    '\\x02'     #  0x0002 -> START OF TEXT\n    '\\x03'     #  0x0003 -> END OF TEXT\n    '\\x04'     #  0x0004 -> END OF TRANSMISSION\n    '\\x05'     #  0x0005 -> ENQUIRY\n    '\\x06'     #  0x0006 -> ACKNOWLEDGE\n    '\\x07'     #  0x0007 -> BELL\n    '\\x08'     #  0x0008 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp850",
        "documentation": {}
    },
    {
        "label": "encoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp850",
        "description": "pycharm_venv.Lib.encodings.cp850",
        "peekOfCode": "encoding_map = {\n    0x0000: 0x0000,     #  NULL\n    0x0001: 0x0001,     #  START OF HEADING\n    0x0002: 0x0002,     #  START OF TEXT\n    0x0003: 0x0003,     #  END OF TEXT\n    0x0004: 0x0004,     #  END OF TRANSMISSION\n    0x0005: 0x0005,     #  ENQUIRY\n    0x0006: 0x0006,     #  ACKNOWLEDGE\n    0x0007: 0x0007,     #  BELL\n    0x0008: 0x0008,     #  BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp850",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp852",
        "description": "pycharm_venv.Lib.encodings.cp852",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_map)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp852",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp852",
        "description": "pycharm_venv.Lib.encodings.cp852",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp852",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp852",
        "description": "pycharm_venv.Lib.encodings.cp852",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp852",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp852",
        "description": "pycharm_venv.Lib.encodings.cp852",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp852',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp852",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp852",
        "description": "pycharm_venv.Lib.encodings.cp852",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp852',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp852",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp852",
        "description": "pycharm_venv.Lib.encodings.cp852",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp852',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp852",
        "documentation": {}
    },
    {
        "label": "decoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp852",
        "description": "pycharm_venv.Lib.encodings.cp852",
        "peekOfCode": "decoding_map = codecs.make_identity_dict(range(256))\ndecoding_map.update({\n    0x0080: 0x00c7,     #  LATIN CAPITAL LETTER C WITH CEDILLA\n    0x0081: 0x00fc,     #  LATIN SMALL LETTER U WITH DIAERESIS\n    0x0082: 0x00e9,     #  LATIN SMALL LETTER E WITH ACUTE\n    0x0083: 0x00e2,     #  LATIN SMALL LETTER A WITH CIRCUMFLEX\n    0x0084: 0x00e4,     #  LATIN SMALL LETTER A WITH DIAERESIS\n    0x0085: 0x016f,     #  LATIN SMALL LETTER U WITH RING ABOVE\n    0x0086: 0x0107,     #  LATIN SMALL LETTER C WITH ACUTE\n    0x0087: 0x00e7,     #  LATIN SMALL LETTER C WITH CEDILLA",
        "detail": "pycharm_venv.Lib.encodings.cp852",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp852",
        "description": "pycharm_venv.Lib.encodings.cp852",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x0000 -> NULL\n    '\\x01'     #  0x0001 -> START OF HEADING\n    '\\x02'     #  0x0002 -> START OF TEXT\n    '\\x03'     #  0x0003 -> END OF TEXT\n    '\\x04'     #  0x0004 -> END OF TRANSMISSION\n    '\\x05'     #  0x0005 -> ENQUIRY\n    '\\x06'     #  0x0006 -> ACKNOWLEDGE\n    '\\x07'     #  0x0007 -> BELL\n    '\\x08'     #  0x0008 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp852",
        "documentation": {}
    },
    {
        "label": "encoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp852",
        "description": "pycharm_venv.Lib.encodings.cp852",
        "peekOfCode": "encoding_map = {\n    0x0000: 0x0000,     #  NULL\n    0x0001: 0x0001,     #  START OF HEADING\n    0x0002: 0x0002,     #  START OF TEXT\n    0x0003: 0x0003,     #  END OF TEXT\n    0x0004: 0x0004,     #  END OF TRANSMISSION\n    0x0005: 0x0005,     #  ENQUIRY\n    0x0006: 0x0006,     #  ACKNOWLEDGE\n    0x0007: 0x0007,     #  BELL\n    0x0008: 0x0008,     #  BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp852",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp855",
        "description": "pycharm_venv.Lib.encodings.cp855",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_map)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp855",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp855",
        "description": "pycharm_venv.Lib.encodings.cp855",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp855",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp855",
        "description": "pycharm_venv.Lib.encodings.cp855",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp855",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp855",
        "description": "pycharm_venv.Lib.encodings.cp855",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp855',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp855",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp855",
        "description": "pycharm_venv.Lib.encodings.cp855",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp855',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp855",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp855",
        "description": "pycharm_venv.Lib.encodings.cp855",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp855',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp855",
        "documentation": {}
    },
    {
        "label": "decoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp855",
        "description": "pycharm_venv.Lib.encodings.cp855",
        "peekOfCode": "decoding_map = codecs.make_identity_dict(range(256))\ndecoding_map.update({\n    0x0080: 0x0452,     #  CYRILLIC SMALL LETTER DJE\n    0x0081: 0x0402,     #  CYRILLIC CAPITAL LETTER DJE\n    0x0082: 0x0453,     #  CYRILLIC SMALL LETTER GJE\n    0x0083: 0x0403,     #  CYRILLIC CAPITAL LETTER GJE\n    0x0084: 0x0451,     #  CYRILLIC SMALL LETTER IO\n    0x0085: 0x0401,     #  CYRILLIC CAPITAL LETTER IO\n    0x0086: 0x0454,     #  CYRILLIC SMALL LETTER UKRAINIAN IE\n    0x0087: 0x0404,     #  CYRILLIC CAPITAL LETTER UKRAINIAN IE",
        "detail": "pycharm_venv.Lib.encodings.cp855",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp855",
        "description": "pycharm_venv.Lib.encodings.cp855",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x0000 -> NULL\n    '\\x01'     #  0x0001 -> START OF HEADING\n    '\\x02'     #  0x0002 -> START OF TEXT\n    '\\x03'     #  0x0003 -> END OF TEXT\n    '\\x04'     #  0x0004 -> END OF TRANSMISSION\n    '\\x05'     #  0x0005 -> ENQUIRY\n    '\\x06'     #  0x0006 -> ACKNOWLEDGE\n    '\\x07'     #  0x0007 -> BELL\n    '\\x08'     #  0x0008 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp855",
        "documentation": {}
    },
    {
        "label": "encoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp855",
        "description": "pycharm_venv.Lib.encodings.cp855",
        "peekOfCode": "encoding_map = {\n    0x0000: 0x0000,     #  NULL\n    0x0001: 0x0001,     #  START OF HEADING\n    0x0002: 0x0002,     #  START OF TEXT\n    0x0003: 0x0003,     #  END OF TEXT\n    0x0004: 0x0004,     #  END OF TRANSMISSION\n    0x0005: 0x0005,     #  ENQUIRY\n    0x0006: 0x0006,     #  ACKNOWLEDGE\n    0x0007: 0x0007,     #  BELL\n    0x0008: 0x0008,     #  BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp855",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp856",
        "description": "pycharm_venv.Lib.encodings.cp856",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp856",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp856",
        "description": "pycharm_venv.Lib.encodings.cp856",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp856",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp856",
        "description": "pycharm_venv.Lib.encodings.cp856",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp856",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp856",
        "description": "pycharm_venv.Lib.encodings.cp856",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp856',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp856",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp856",
        "description": "pycharm_venv.Lib.encodings.cp856",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp856',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp856",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp856",
        "description": "pycharm_venv.Lib.encodings.cp856",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp856',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp856",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp856",
        "description": "pycharm_venv.Lib.encodings.cp856",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp856",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp857",
        "description": "pycharm_venv.Lib.encodings.cp857",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_map)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp857",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp857",
        "description": "pycharm_venv.Lib.encodings.cp857",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp857",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp857",
        "description": "pycharm_venv.Lib.encodings.cp857",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp857",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp857",
        "description": "pycharm_venv.Lib.encodings.cp857",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp857',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp857",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp857",
        "description": "pycharm_venv.Lib.encodings.cp857",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp857',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp857",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp857",
        "description": "pycharm_venv.Lib.encodings.cp857",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp857',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp857",
        "documentation": {}
    },
    {
        "label": "decoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp857",
        "description": "pycharm_venv.Lib.encodings.cp857",
        "peekOfCode": "decoding_map = codecs.make_identity_dict(range(256))\ndecoding_map.update({\n    0x0080: 0x00c7,     #  LATIN CAPITAL LETTER C WITH CEDILLA\n    0x0081: 0x00fc,     #  LATIN SMALL LETTER U WITH DIAERESIS\n    0x0082: 0x00e9,     #  LATIN SMALL LETTER E WITH ACUTE\n    0x0083: 0x00e2,     #  LATIN SMALL LETTER A WITH CIRCUMFLEX\n    0x0084: 0x00e4,     #  LATIN SMALL LETTER A WITH DIAERESIS\n    0x0085: 0x00e0,     #  LATIN SMALL LETTER A WITH GRAVE\n    0x0086: 0x00e5,     #  LATIN SMALL LETTER A WITH RING ABOVE\n    0x0087: 0x00e7,     #  LATIN SMALL LETTER C WITH CEDILLA",
        "detail": "pycharm_venv.Lib.encodings.cp857",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp857",
        "description": "pycharm_venv.Lib.encodings.cp857",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x0000 -> NULL\n    '\\x01'     #  0x0001 -> START OF HEADING\n    '\\x02'     #  0x0002 -> START OF TEXT\n    '\\x03'     #  0x0003 -> END OF TEXT\n    '\\x04'     #  0x0004 -> END OF TRANSMISSION\n    '\\x05'     #  0x0005 -> ENQUIRY\n    '\\x06'     #  0x0006 -> ACKNOWLEDGE\n    '\\x07'     #  0x0007 -> BELL\n    '\\x08'     #  0x0008 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp857",
        "documentation": {}
    },
    {
        "label": "encoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp857",
        "description": "pycharm_venv.Lib.encodings.cp857",
        "peekOfCode": "encoding_map = {\n    0x0000: 0x0000,     #  NULL\n    0x0001: 0x0001,     #  START OF HEADING\n    0x0002: 0x0002,     #  START OF TEXT\n    0x0003: 0x0003,     #  END OF TEXT\n    0x0004: 0x0004,     #  END OF TRANSMISSION\n    0x0005: 0x0005,     #  ENQUIRY\n    0x0006: 0x0006,     #  ACKNOWLEDGE\n    0x0007: 0x0007,     #  BELL\n    0x0008: 0x0008,     #  BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp857",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp858",
        "description": "pycharm_venv.Lib.encodings.cp858",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_map)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp858",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp858",
        "description": "pycharm_venv.Lib.encodings.cp858",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp858",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp858",
        "description": "pycharm_venv.Lib.encodings.cp858",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp858",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp858",
        "description": "pycharm_venv.Lib.encodings.cp858",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp858',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp858",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp858",
        "description": "pycharm_venv.Lib.encodings.cp858",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp858',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp858",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp858",
        "description": "pycharm_venv.Lib.encodings.cp858",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp858',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp858",
        "documentation": {}
    },
    {
        "label": "decoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp858",
        "description": "pycharm_venv.Lib.encodings.cp858",
        "peekOfCode": "decoding_map = codecs.make_identity_dict(range(256))\ndecoding_map.update({\n    0x0080: 0x00c7,     #  LATIN CAPITAL LETTER C WITH CEDILLA\n    0x0081: 0x00fc,     #  LATIN SMALL LETTER U WITH DIAERESIS\n    0x0082: 0x00e9,     #  LATIN SMALL LETTER E WITH ACUTE\n    0x0083: 0x00e2,     #  LATIN SMALL LETTER A WITH CIRCUMFLEX\n    0x0084: 0x00e4,     #  LATIN SMALL LETTER A WITH DIAERESIS\n    0x0085: 0x00e0,     #  LATIN SMALL LETTER A WITH GRAVE\n    0x0086: 0x00e5,     #  LATIN SMALL LETTER A WITH RING ABOVE\n    0x0087: 0x00e7,     #  LATIN SMALL LETTER C WITH CEDILLA",
        "detail": "pycharm_venv.Lib.encodings.cp858",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp858",
        "description": "pycharm_venv.Lib.encodings.cp858",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x0000 -> NULL\n    '\\x01'     #  0x0001 -> START OF HEADING\n    '\\x02'     #  0x0002 -> START OF TEXT\n    '\\x03'     #  0x0003 -> END OF TEXT\n    '\\x04'     #  0x0004 -> END OF TRANSMISSION\n    '\\x05'     #  0x0005 -> ENQUIRY\n    '\\x06'     #  0x0006 -> ACKNOWLEDGE\n    '\\x07'     #  0x0007 -> BELL\n    '\\x08'     #  0x0008 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp858",
        "documentation": {}
    },
    {
        "label": "encoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp858",
        "description": "pycharm_venv.Lib.encodings.cp858",
        "peekOfCode": "encoding_map = {\n    0x0000: 0x0000,     #  NULL\n    0x0001: 0x0001,     #  START OF HEADING\n    0x0002: 0x0002,     #  START OF TEXT\n    0x0003: 0x0003,     #  END OF TEXT\n    0x0004: 0x0004,     #  END OF TRANSMISSION\n    0x0005: 0x0005,     #  ENQUIRY\n    0x0006: 0x0006,     #  ACKNOWLEDGE\n    0x0007: 0x0007,     #  BELL\n    0x0008: 0x0008,     #  BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp858",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp860",
        "description": "pycharm_venv.Lib.encodings.cp860",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_map)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp860",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp860",
        "description": "pycharm_venv.Lib.encodings.cp860",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp860",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp860",
        "description": "pycharm_venv.Lib.encodings.cp860",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp860",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp860",
        "description": "pycharm_venv.Lib.encodings.cp860",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp860',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp860",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp860",
        "description": "pycharm_venv.Lib.encodings.cp860",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp860',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp860",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp860",
        "description": "pycharm_venv.Lib.encodings.cp860",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp860',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp860",
        "documentation": {}
    },
    {
        "label": "decoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp860",
        "description": "pycharm_venv.Lib.encodings.cp860",
        "peekOfCode": "decoding_map = codecs.make_identity_dict(range(256))\ndecoding_map.update({\n    0x0080: 0x00c7,     #  LATIN CAPITAL LETTER C WITH CEDILLA\n    0x0081: 0x00fc,     #  LATIN SMALL LETTER U WITH DIAERESIS\n    0x0082: 0x00e9,     #  LATIN SMALL LETTER E WITH ACUTE\n    0x0083: 0x00e2,     #  LATIN SMALL LETTER A WITH CIRCUMFLEX\n    0x0084: 0x00e3,     #  LATIN SMALL LETTER A WITH TILDE\n    0x0085: 0x00e0,     #  LATIN SMALL LETTER A WITH GRAVE\n    0x0086: 0x00c1,     #  LATIN CAPITAL LETTER A WITH ACUTE\n    0x0087: 0x00e7,     #  LATIN SMALL LETTER C WITH CEDILLA",
        "detail": "pycharm_venv.Lib.encodings.cp860",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp860",
        "description": "pycharm_venv.Lib.encodings.cp860",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x0000 -> NULL\n    '\\x01'     #  0x0001 -> START OF HEADING\n    '\\x02'     #  0x0002 -> START OF TEXT\n    '\\x03'     #  0x0003 -> END OF TEXT\n    '\\x04'     #  0x0004 -> END OF TRANSMISSION\n    '\\x05'     #  0x0005 -> ENQUIRY\n    '\\x06'     #  0x0006 -> ACKNOWLEDGE\n    '\\x07'     #  0x0007 -> BELL\n    '\\x08'     #  0x0008 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp860",
        "documentation": {}
    },
    {
        "label": "encoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp860",
        "description": "pycharm_venv.Lib.encodings.cp860",
        "peekOfCode": "encoding_map = {\n    0x0000: 0x0000,     #  NULL\n    0x0001: 0x0001,     #  START OF HEADING\n    0x0002: 0x0002,     #  START OF TEXT\n    0x0003: 0x0003,     #  END OF TEXT\n    0x0004: 0x0004,     #  END OF TRANSMISSION\n    0x0005: 0x0005,     #  ENQUIRY\n    0x0006: 0x0006,     #  ACKNOWLEDGE\n    0x0007: 0x0007,     #  BELL\n    0x0008: 0x0008,     #  BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp860",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp861",
        "description": "pycharm_venv.Lib.encodings.cp861",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_map)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp861",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp861",
        "description": "pycharm_venv.Lib.encodings.cp861",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp861",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp861",
        "description": "pycharm_venv.Lib.encodings.cp861",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp861",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp861",
        "description": "pycharm_venv.Lib.encodings.cp861",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp861',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp861",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp861",
        "description": "pycharm_venv.Lib.encodings.cp861",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp861',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp861",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp861",
        "description": "pycharm_venv.Lib.encodings.cp861",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp861',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp861",
        "documentation": {}
    },
    {
        "label": "decoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp861",
        "description": "pycharm_venv.Lib.encodings.cp861",
        "peekOfCode": "decoding_map = codecs.make_identity_dict(range(256))\ndecoding_map.update({\n    0x0080: 0x00c7,     #  LATIN CAPITAL LETTER C WITH CEDILLA\n    0x0081: 0x00fc,     #  LATIN SMALL LETTER U WITH DIAERESIS\n    0x0082: 0x00e9,     #  LATIN SMALL LETTER E WITH ACUTE\n    0x0083: 0x00e2,     #  LATIN SMALL LETTER A WITH CIRCUMFLEX\n    0x0084: 0x00e4,     #  LATIN SMALL LETTER A WITH DIAERESIS\n    0x0085: 0x00e0,     #  LATIN SMALL LETTER A WITH GRAVE\n    0x0086: 0x00e5,     #  LATIN SMALL LETTER A WITH RING ABOVE\n    0x0087: 0x00e7,     #  LATIN SMALL LETTER C WITH CEDILLA",
        "detail": "pycharm_venv.Lib.encodings.cp861",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp861",
        "description": "pycharm_venv.Lib.encodings.cp861",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x0000 -> NULL\n    '\\x01'     #  0x0001 -> START OF HEADING\n    '\\x02'     #  0x0002 -> START OF TEXT\n    '\\x03'     #  0x0003 -> END OF TEXT\n    '\\x04'     #  0x0004 -> END OF TRANSMISSION\n    '\\x05'     #  0x0005 -> ENQUIRY\n    '\\x06'     #  0x0006 -> ACKNOWLEDGE\n    '\\x07'     #  0x0007 -> BELL\n    '\\x08'     #  0x0008 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp861",
        "documentation": {}
    },
    {
        "label": "encoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp861",
        "description": "pycharm_venv.Lib.encodings.cp861",
        "peekOfCode": "encoding_map = {\n    0x0000: 0x0000,     #  NULL\n    0x0001: 0x0001,     #  START OF HEADING\n    0x0002: 0x0002,     #  START OF TEXT\n    0x0003: 0x0003,     #  END OF TEXT\n    0x0004: 0x0004,     #  END OF TRANSMISSION\n    0x0005: 0x0005,     #  ENQUIRY\n    0x0006: 0x0006,     #  ACKNOWLEDGE\n    0x0007: 0x0007,     #  BELL\n    0x0008: 0x0008,     #  BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp861",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp862",
        "description": "pycharm_venv.Lib.encodings.cp862",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_map)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp862",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp862",
        "description": "pycharm_venv.Lib.encodings.cp862",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp862",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp862",
        "description": "pycharm_venv.Lib.encodings.cp862",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp862",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp862",
        "description": "pycharm_venv.Lib.encodings.cp862",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp862',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp862",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp862",
        "description": "pycharm_venv.Lib.encodings.cp862",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp862',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp862",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp862",
        "description": "pycharm_venv.Lib.encodings.cp862",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp862',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp862",
        "documentation": {}
    },
    {
        "label": "decoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp862",
        "description": "pycharm_venv.Lib.encodings.cp862",
        "peekOfCode": "decoding_map = codecs.make_identity_dict(range(256))\ndecoding_map.update({\n    0x0080: 0x05d0,     #  HEBREW LETTER ALEF\n    0x0081: 0x05d1,     #  HEBREW LETTER BET\n    0x0082: 0x05d2,     #  HEBREW LETTER GIMEL\n    0x0083: 0x05d3,     #  HEBREW LETTER DALET\n    0x0084: 0x05d4,     #  HEBREW LETTER HE\n    0x0085: 0x05d5,     #  HEBREW LETTER VAV\n    0x0086: 0x05d6,     #  HEBREW LETTER ZAYIN\n    0x0087: 0x05d7,     #  HEBREW LETTER HET",
        "detail": "pycharm_venv.Lib.encodings.cp862",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp862",
        "description": "pycharm_venv.Lib.encodings.cp862",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x0000 -> NULL\n    '\\x01'     #  0x0001 -> START OF HEADING\n    '\\x02'     #  0x0002 -> START OF TEXT\n    '\\x03'     #  0x0003 -> END OF TEXT\n    '\\x04'     #  0x0004 -> END OF TRANSMISSION\n    '\\x05'     #  0x0005 -> ENQUIRY\n    '\\x06'     #  0x0006 -> ACKNOWLEDGE\n    '\\x07'     #  0x0007 -> BELL\n    '\\x08'     #  0x0008 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp862",
        "documentation": {}
    },
    {
        "label": "encoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp862",
        "description": "pycharm_venv.Lib.encodings.cp862",
        "peekOfCode": "encoding_map = {\n    0x0000: 0x0000,     #  NULL\n    0x0001: 0x0001,     #  START OF HEADING\n    0x0002: 0x0002,     #  START OF TEXT\n    0x0003: 0x0003,     #  END OF TEXT\n    0x0004: 0x0004,     #  END OF TRANSMISSION\n    0x0005: 0x0005,     #  ENQUIRY\n    0x0006: 0x0006,     #  ACKNOWLEDGE\n    0x0007: 0x0007,     #  BELL\n    0x0008: 0x0008,     #  BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp862",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp863",
        "description": "pycharm_venv.Lib.encodings.cp863",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_map)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp863",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp863",
        "description": "pycharm_venv.Lib.encodings.cp863",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp863",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp863",
        "description": "pycharm_venv.Lib.encodings.cp863",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp863",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp863",
        "description": "pycharm_venv.Lib.encodings.cp863",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp863',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp863",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp863",
        "description": "pycharm_venv.Lib.encodings.cp863",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp863',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp863",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp863",
        "description": "pycharm_venv.Lib.encodings.cp863",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp863',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp863",
        "documentation": {}
    },
    {
        "label": "decoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp863",
        "description": "pycharm_venv.Lib.encodings.cp863",
        "peekOfCode": "decoding_map = codecs.make_identity_dict(range(256))\ndecoding_map.update({\n    0x0080: 0x00c7,     #  LATIN CAPITAL LETTER C WITH CEDILLA\n    0x0081: 0x00fc,     #  LATIN SMALL LETTER U WITH DIAERESIS\n    0x0082: 0x00e9,     #  LATIN SMALL LETTER E WITH ACUTE\n    0x0083: 0x00e2,     #  LATIN SMALL LETTER A WITH CIRCUMFLEX\n    0x0084: 0x00c2,     #  LATIN CAPITAL LETTER A WITH CIRCUMFLEX\n    0x0085: 0x00e0,     #  LATIN SMALL LETTER A WITH GRAVE\n    0x0086: 0x00b6,     #  PILCROW SIGN\n    0x0087: 0x00e7,     #  LATIN SMALL LETTER C WITH CEDILLA",
        "detail": "pycharm_venv.Lib.encodings.cp863",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp863",
        "description": "pycharm_venv.Lib.encodings.cp863",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x0000 -> NULL\n    '\\x01'     #  0x0001 -> START OF HEADING\n    '\\x02'     #  0x0002 -> START OF TEXT\n    '\\x03'     #  0x0003 -> END OF TEXT\n    '\\x04'     #  0x0004 -> END OF TRANSMISSION\n    '\\x05'     #  0x0005 -> ENQUIRY\n    '\\x06'     #  0x0006 -> ACKNOWLEDGE\n    '\\x07'     #  0x0007 -> BELL\n    '\\x08'     #  0x0008 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp863",
        "documentation": {}
    },
    {
        "label": "encoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp863",
        "description": "pycharm_venv.Lib.encodings.cp863",
        "peekOfCode": "encoding_map = {\n    0x0000: 0x0000,     #  NULL\n    0x0001: 0x0001,     #  START OF HEADING\n    0x0002: 0x0002,     #  START OF TEXT\n    0x0003: 0x0003,     #  END OF TEXT\n    0x0004: 0x0004,     #  END OF TRANSMISSION\n    0x0005: 0x0005,     #  ENQUIRY\n    0x0006: 0x0006,     #  ACKNOWLEDGE\n    0x0007: 0x0007,     #  BELL\n    0x0008: 0x0008,     #  BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp863",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp864",
        "description": "pycharm_venv.Lib.encodings.cp864",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_map)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp864",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp864",
        "description": "pycharm_venv.Lib.encodings.cp864",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp864",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp864",
        "description": "pycharm_venv.Lib.encodings.cp864",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp864",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp864",
        "description": "pycharm_venv.Lib.encodings.cp864",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp864',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp864",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp864",
        "description": "pycharm_venv.Lib.encodings.cp864",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp864',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp864",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp864",
        "description": "pycharm_venv.Lib.encodings.cp864",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp864',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp864",
        "documentation": {}
    },
    {
        "label": "decoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp864",
        "description": "pycharm_venv.Lib.encodings.cp864",
        "peekOfCode": "decoding_map = codecs.make_identity_dict(range(256))\ndecoding_map.update({\n    0x0025: 0x066a,     #  ARABIC PERCENT SIGN\n    0x0080: 0x00b0,     #  DEGREE SIGN\n    0x0081: 0x00b7,     #  MIDDLE DOT\n    0x0082: 0x2219,     #  BULLET OPERATOR\n    0x0083: 0x221a,     #  SQUARE ROOT\n    0x0084: 0x2592,     #  MEDIUM SHADE\n    0x0085: 0x2500,     #  FORMS LIGHT HORIZONTAL\n    0x0086: 0x2502,     #  FORMS LIGHT VERTICAL",
        "detail": "pycharm_venv.Lib.encodings.cp864",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp864",
        "description": "pycharm_venv.Lib.encodings.cp864",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x0000 -> NULL\n    '\\x01'     #  0x0001 -> START OF HEADING\n    '\\x02'     #  0x0002 -> START OF TEXT\n    '\\x03'     #  0x0003 -> END OF TEXT\n    '\\x04'     #  0x0004 -> END OF TRANSMISSION\n    '\\x05'     #  0x0005 -> ENQUIRY\n    '\\x06'     #  0x0006 -> ACKNOWLEDGE\n    '\\x07'     #  0x0007 -> BELL\n    '\\x08'     #  0x0008 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp864",
        "documentation": {}
    },
    {
        "label": "encoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp864",
        "description": "pycharm_venv.Lib.encodings.cp864",
        "peekOfCode": "encoding_map = {\n    0x0000: 0x0000,     #  NULL\n    0x0001: 0x0001,     #  START OF HEADING\n    0x0002: 0x0002,     #  START OF TEXT\n    0x0003: 0x0003,     #  END OF TEXT\n    0x0004: 0x0004,     #  END OF TRANSMISSION\n    0x0005: 0x0005,     #  ENQUIRY\n    0x0006: 0x0006,     #  ACKNOWLEDGE\n    0x0007: 0x0007,     #  BELL\n    0x0008: 0x0008,     #  BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp864",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp865",
        "description": "pycharm_venv.Lib.encodings.cp865",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_map)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp865",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp865",
        "description": "pycharm_venv.Lib.encodings.cp865",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp865",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp865",
        "description": "pycharm_venv.Lib.encodings.cp865",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp865",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp865",
        "description": "pycharm_venv.Lib.encodings.cp865",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp865',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp865",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp865",
        "description": "pycharm_venv.Lib.encodings.cp865",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp865',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp865",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp865",
        "description": "pycharm_venv.Lib.encodings.cp865",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp865',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp865",
        "documentation": {}
    },
    {
        "label": "decoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp865",
        "description": "pycharm_venv.Lib.encodings.cp865",
        "peekOfCode": "decoding_map = codecs.make_identity_dict(range(256))\ndecoding_map.update({\n    0x0080: 0x00c7,     #  LATIN CAPITAL LETTER C WITH CEDILLA\n    0x0081: 0x00fc,     #  LATIN SMALL LETTER U WITH DIAERESIS\n    0x0082: 0x00e9,     #  LATIN SMALL LETTER E WITH ACUTE\n    0x0083: 0x00e2,     #  LATIN SMALL LETTER A WITH CIRCUMFLEX\n    0x0084: 0x00e4,     #  LATIN SMALL LETTER A WITH DIAERESIS\n    0x0085: 0x00e0,     #  LATIN SMALL LETTER A WITH GRAVE\n    0x0086: 0x00e5,     #  LATIN SMALL LETTER A WITH RING ABOVE\n    0x0087: 0x00e7,     #  LATIN SMALL LETTER C WITH CEDILLA",
        "detail": "pycharm_venv.Lib.encodings.cp865",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp865",
        "description": "pycharm_venv.Lib.encodings.cp865",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x0000 -> NULL\n    '\\x01'     #  0x0001 -> START OF HEADING\n    '\\x02'     #  0x0002 -> START OF TEXT\n    '\\x03'     #  0x0003 -> END OF TEXT\n    '\\x04'     #  0x0004 -> END OF TRANSMISSION\n    '\\x05'     #  0x0005 -> ENQUIRY\n    '\\x06'     #  0x0006 -> ACKNOWLEDGE\n    '\\x07'     #  0x0007 -> BELL\n    '\\x08'     #  0x0008 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp865",
        "documentation": {}
    },
    {
        "label": "encoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp865",
        "description": "pycharm_venv.Lib.encodings.cp865",
        "peekOfCode": "encoding_map = {\n    0x0000: 0x0000,     #  NULL\n    0x0001: 0x0001,     #  START OF HEADING\n    0x0002: 0x0002,     #  START OF TEXT\n    0x0003: 0x0003,     #  END OF TEXT\n    0x0004: 0x0004,     #  END OF TRANSMISSION\n    0x0005: 0x0005,     #  ENQUIRY\n    0x0006: 0x0006,     #  ACKNOWLEDGE\n    0x0007: 0x0007,     #  BELL\n    0x0008: 0x0008,     #  BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp865",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp866",
        "description": "pycharm_venv.Lib.encodings.cp866",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_map)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp866",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp866",
        "description": "pycharm_venv.Lib.encodings.cp866",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp866",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp866",
        "description": "pycharm_venv.Lib.encodings.cp866",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp866",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp866",
        "description": "pycharm_venv.Lib.encodings.cp866",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp866',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp866",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp866",
        "description": "pycharm_venv.Lib.encodings.cp866",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp866',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp866",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp866",
        "description": "pycharm_venv.Lib.encodings.cp866",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp866',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp866",
        "documentation": {}
    },
    {
        "label": "decoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp866",
        "description": "pycharm_venv.Lib.encodings.cp866",
        "peekOfCode": "decoding_map = codecs.make_identity_dict(range(256))\ndecoding_map.update({\n    0x0080: 0x0410,     #  CYRILLIC CAPITAL LETTER A\n    0x0081: 0x0411,     #  CYRILLIC CAPITAL LETTER BE\n    0x0082: 0x0412,     #  CYRILLIC CAPITAL LETTER VE\n    0x0083: 0x0413,     #  CYRILLIC CAPITAL LETTER GHE\n    0x0084: 0x0414,     #  CYRILLIC CAPITAL LETTER DE\n    0x0085: 0x0415,     #  CYRILLIC CAPITAL LETTER IE\n    0x0086: 0x0416,     #  CYRILLIC CAPITAL LETTER ZHE\n    0x0087: 0x0417,     #  CYRILLIC CAPITAL LETTER ZE",
        "detail": "pycharm_venv.Lib.encodings.cp866",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp866",
        "description": "pycharm_venv.Lib.encodings.cp866",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x0000 -> NULL\n    '\\x01'     #  0x0001 -> START OF HEADING\n    '\\x02'     #  0x0002 -> START OF TEXT\n    '\\x03'     #  0x0003 -> END OF TEXT\n    '\\x04'     #  0x0004 -> END OF TRANSMISSION\n    '\\x05'     #  0x0005 -> ENQUIRY\n    '\\x06'     #  0x0006 -> ACKNOWLEDGE\n    '\\x07'     #  0x0007 -> BELL\n    '\\x08'     #  0x0008 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp866",
        "documentation": {}
    },
    {
        "label": "encoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp866",
        "description": "pycharm_venv.Lib.encodings.cp866",
        "peekOfCode": "encoding_map = {\n    0x0000: 0x0000,     #  NULL\n    0x0001: 0x0001,     #  START OF HEADING\n    0x0002: 0x0002,     #  START OF TEXT\n    0x0003: 0x0003,     #  END OF TEXT\n    0x0004: 0x0004,     #  END OF TRANSMISSION\n    0x0005: 0x0005,     #  ENQUIRY\n    0x0006: 0x0006,     #  ACKNOWLEDGE\n    0x0007: 0x0007,     #  BELL\n    0x0008: 0x0008,     #  BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp866",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp869",
        "description": "pycharm_venv.Lib.encodings.cp869",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_map)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp869",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp869",
        "description": "pycharm_venv.Lib.encodings.cp869",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp869",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp869",
        "description": "pycharm_venv.Lib.encodings.cp869",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp869",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp869",
        "description": "pycharm_venv.Lib.encodings.cp869",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp869',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp869",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp869",
        "description": "pycharm_venv.Lib.encodings.cp869",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp869',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp869",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp869",
        "description": "pycharm_venv.Lib.encodings.cp869",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp869',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp869",
        "documentation": {}
    },
    {
        "label": "decoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp869",
        "description": "pycharm_venv.Lib.encodings.cp869",
        "peekOfCode": "decoding_map = codecs.make_identity_dict(range(256))\ndecoding_map.update({\n    0x0080: None,       #  UNDEFINED\n    0x0081: None,       #  UNDEFINED\n    0x0082: None,       #  UNDEFINED\n    0x0083: None,       #  UNDEFINED\n    0x0084: None,       #  UNDEFINED\n    0x0085: None,       #  UNDEFINED\n    0x0086: 0x0386,     #  GREEK CAPITAL LETTER ALPHA WITH TONOS\n    0x0087: None,       #  UNDEFINED",
        "detail": "pycharm_venv.Lib.encodings.cp869",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp869",
        "description": "pycharm_venv.Lib.encodings.cp869",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x0000 -> NULL\n    '\\x01'     #  0x0001 -> START OF HEADING\n    '\\x02'     #  0x0002 -> START OF TEXT\n    '\\x03'     #  0x0003 -> END OF TEXT\n    '\\x04'     #  0x0004 -> END OF TRANSMISSION\n    '\\x05'     #  0x0005 -> ENQUIRY\n    '\\x06'     #  0x0006 -> ACKNOWLEDGE\n    '\\x07'     #  0x0007 -> BELL\n    '\\x08'     #  0x0008 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp869",
        "documentation": {}
    },
    {
        "label": "encoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp869",
        "description": "pycharm_venv.Lib.encodings.cp869",
        "peekOfCode": "encoding_map = {\n    0x0000: 0x0000,     #  NULL\n    0x0001: 0x0001,     #  START OF HEADING\n    0x0002: 0x0002,     #  START OF TEXT\n    0x0003: 0x0003,     #  END OF TEXT\n    0x0004: 0x0004,     #  END OF TRANSMISSION\n    0x0005: 0x0005,     #  ENQUIRY\n    0x0006: 0x0006,     #  ACKNOWLEDGE\n    0x0007: 0x0007,     #  BELL\n    0x0008: 0x0008,     #  BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp869",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp874",
        "description": "pycharm_venv.Lib.encodings.cp874",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp874",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp874",
        "description": "pycharm_venv.Lib.encodings.cp874",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp874",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp874",
        "description": "pycharm_venv.Lib.encodings.cp874",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp874",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp874",
        "description": "pycharm_venv.Lib.encodings.cp874",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp874',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp874",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp874",
        "description": "pycharm_venv.Lib.encodings.cp874",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp874',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp874",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp874",
        "description": "pycharm_venv.Lib.encodings.cp874",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp874',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp874",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp874",
        "description": "pycharm_venv.Lib.encodings.cp874",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.cp874",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp875",
        "description": "pycharm_venv.Lib.encodings.cp875",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.cp875",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp875",
        "description": "pycharm_venv.Lib.encodings.cp875",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.cp875",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp875",
        "description": "pycharm_venv.Lib.encodings.cp875",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.cp875",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp875",
        "description": "pycharm_venv.Lib.encodings.cp875",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp875',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.cp875",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp875",
        "description": "pycharm_venv.Lib.encodings.cp875",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp875',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.cp875",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp875",
        "description": "pycharm_venv.Lib.encodings.cp875",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp875',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp875",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp875",
        "description": "pycharm_venv.Lib.encodings.cp875",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x9c'     #  0x04 -> CONTROL\n    '\\t'       #  0x05 -> HORIZONTAL TABULATION\n    '\\x86'     #  0x06 -> CONTROL\n    '\\x7f'     #  0x07 -> DELETE\n    '\\x97'     #  0x08 -> CONTROL",
        "detail": "pycharm_venv.Lib.encodings.cp875",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp932",
        "description": "pycharm_venv.Lib.encodings.cp932",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.cp932",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp932",
        "description": "pycharm_venv.Lib.encodings.cp932",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.cp932",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp932",
        "description": "pycharm_venv.Lib.encodings.cp932",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp932',",
        "detail": "pycharm_venv.Lib.encodings.cp932",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp932",
        "description": "pycharm_venv.Lib.encodings.cp932",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp932',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.cp932",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp932",
        "description": "pycharm_venv.Lib.encodings.cp932",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp932',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.cp932",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp932",
        "description": "pycharm_venv.Lib.encodings.cp932",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp932',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp932",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp932",
        "description": "pycharm_venv.Lib.encodings.cp932",
        "peekOfCode": "codec = _codecs_jp.getcodec('cp932')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.cp932",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp949",
        "description": "pycharm_venv.Lib.encodings.cp949",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.cp949",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp949",
        "description": "pycharm_venv.Lib.encodings.cp949",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.cp949",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp949",
        "description": "pycharm_venv.Lib.encodings.cp949",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp949',",
        "detail": "pycharm_venv.Lib.encodings.cp949",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp949",
        "description": "pycharm_venv.Lib.encodings.cp949",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp949',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.cp949",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp949",
        "description": "pycharm_venv.Lib.encodings.cp949",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp949',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.cp949",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp949",
        "description": "pycharm_venv.Lib.encodings.cp949",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp949',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp949",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp949",
        "description": "pycharm_venv.Lib.encodings.cp949",
        "peekOfCode": "codec = _codecs_kr.getcodec('cp949')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.cp949",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp950",
        "description": "pycharm_venv.Lib.encodings.cp950",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.cp950",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp950",
        "description": "pycharm_venv.Lib.encodings.cp950",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.cp950",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp950",
        "description": "pycharm_venv.Lib.encodings.cp950",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp950',",
        "detail": "pycharm_venv.Lib.encodings.cp950",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp950",
        "description": "pycharm_venv.Lib.encodings.cp950",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp950',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.cp950",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.cp950",
        "description": "pycharm_venv.Lib.encodings.cp950",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp950',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.cp950",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.cp950",
        "description": "pycharm_venv.Lib.encodings.cp950",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='cp950',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.cp950",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.cp950",
        "description": "pycharm_venv.Lib.encodings.cp950",
        "peekOfCode": "codec = _codecs_tw.getcodec('cp950')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.cp950",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "description": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "description": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "description": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='euc_jisx0213',",
        "detail": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "description": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='euc_jisx0213',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "description": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='euc_jisx0213',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "description": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='euc_jisx0213',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "description": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "peekOfCode": "codec = _codecs_jp.getcodec('euc_jisx0213')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.euc_jisx0213",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "description": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "description": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "description": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='euc_jis_2004',",
        "detail": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "description": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='euc_jis_2004',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "description": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='euc_jis_2004',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "description": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='euc_jis_2004',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "description": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "peekOfCode": "codec = _codecs_jp.getcodec('euc_jis_2004')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.euc_jis_2004",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_jp",
        "description": "pycharm_venv.Lib.encodings.euc_jp",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.euc_jp",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_jp",
        "description": "pycharm_venv.Lib.encodings.euc_jp",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.euc_jp",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_jp",
        "description": "pycharm_venv.Lib.encodings.euc_jp",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='euc_jp',",
        "detail": "pycharm_venv.Lib.encodings.euc_jp",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_jp",
        "description": "pycharm_venv.Lib.encodings.euc_jp",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='euc_jp',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.euc_jp",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_jp",
        "description": "pycharm_venv.Lib.encodings.euc_jp",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='euc_jp',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.euc_jp",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.euc_jp",
        "description": "pycharm_venv.Lib.encodings.euc_jp",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='euc_jp',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.euc_jp",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.euc_jp",
        "description": "pycharm_venv.Lib.encodings.euc_jp",
        "peekOfCode": "codec = _codecs_jp.getcodec('euc_jp')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.euc_jp",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_kr",
        "description": "pycharm_venv.Lib.encodings.euc_kr",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.euc_kr",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_kr",
        "description": "pycharm_venv.Lib.encodings.euc_kr",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.euc_kr",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_kr",
        "description": "pycharm_venv.Lib.encodings.euc_kr",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='euc_kr',",
        "detail": "pycharm_venv.Lib.encodings.euc_kr",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_kr",
        "description": "pycharm_venv.Lib.encodings.euc_kr",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='euc_kr',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.euc_kr",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.euc_kr",
        "description": "pycharm_venv.Lib.encodings.euc_kr",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='euc_kr',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.euc_kr",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.euc_kr",
        "description": "pycharm_venv.Lib.encodings.euc_kr",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='euc_kr',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.euc_kr",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.euc_kr",
        "description": "pycharm_venv.Lib.encodings.euc_kr",
        "peekOfCode": "codec = _codecs_kr.getcodec('euc_kr')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.euc_kr",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.gb18030",
        "description": "pycharm_venv.Lib.encodings.gb18030",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.gb18030",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.gb18030",
        "description": "pycharm_venv.Lib.encodings.gb18030",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.gb18030",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.gb18030",
        "description": "pycharm_venv.Lib.encodings.gb18030",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='gb18030',",
        "detail": "pycharm_venv.Lib.encodings.gb18030",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.gb18030",
        "description": "pycharm_venv.Lib.encodings.gb18030",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='gb18030',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.gb18030",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.gb18030",
        "description": "pycharm_venv.Lib.encodings.gb18030",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='gb18030',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.gb18030",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.gb18030",
        "description": "pycharm_venv.Lib.encodings.gb18030",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='gb18030',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.gb18030",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.gb18030",
        "description": "pycharm_venv.Lib.encodings.gb18030",
        "peekOfCode": "codec = _codecs_cn.getcodec('gb18030')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.gb18030",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.gb2312",
        "description": "pycharm_venv.Lib.encodings.gb2312",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.gb2312",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.gb2312",
        "description": "pycharm_venv.Lib.encodings.gb2312",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.gb2312",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.gb2312",
        "description": "pycharm_venv.Lib.encodings.gb2312",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='gb2312',",
        "detail": "pycharm_venv.Lib.encodings.gb2312",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.gb2312",
        "description": "pycharm_venv.Lib.encodings.gb2312",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='gb2312',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.gb2312",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.gb2312",
        "description": "pycharm_venv.Lib.encodings.gb2312",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='gb2312',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.gb2312",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.gb2312",
        "description": "pycharm_venv.Lib.encodings.gb2312",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='gb2312',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.gb2312",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.gb2312",
        "description": "pycharm_venv.Lib.encodings.gb2312",
        "peekOfCode": "codec = _codecs_cn.getcodec('gb2312')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.gb2312",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.gbk",
        "description": "pycharm_venv.Lib.encodings.gbk",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.gbk",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.gbk",
        "description": "pycharm_venv.Lib.encodings.gbk",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.gbk",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.gbk",
        "description": "pycharm_venv.Lib.encodings.gbk",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='gbk',",
        "detail": "pycharm_venv.Lib.encodings.gbk",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.gbk",
        "description": "pycharm_venv.Lib.encodings.gbk",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='gbk',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.gbk",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.gbk",
        "description": "pycharm_venv.Lib.encodings.gbk",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='gbk',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.gbk",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.gbk",
        "description": "pycharm_venv.Lib.encodings.gbk",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='gbk',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.gbk",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.gbk",
        "description": "pycharm_venv.Lib.encodings.gbk",
        "peekOfCode": "codec = _codecs_cn.getcodec('gbk')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.gbk",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.hex_codec",
        "description": "pycharm_venv.Lib.encodings.hex_codec",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        return hex_encode(input, errors)\n    def decode(self, input, errors='strict'):\n        return hex_decode(input, errors)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        assert self.errors == 'strict'\n        return binascii.b2a_hex(input)\nclass IncrementalDecoder(codecs.IncrementalDecoder):",
        "detail": "pycharm_venv.Lib.encodings.hex_codec",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.hex_codec",
        "description": "pycharm_venv.Lib.encodings.hex_codec",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        assert self.errors == 'strict'\n        return binascii.b2a_hex(input)\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        assert self.errors == 'strict'\n        return binascii.a2b_hex(input)\nclass StreamWriter(Codec, codecs.StreamWriter):\n    charbuffertype = bytes",
        "detail": "pycharm_venv.Lib.encodings.hex_codec",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.hex_codec",
        "description": "pycharm_venv.Lib.encodings.hex_codec",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        assert self.errors == 'strict'\n        return binascii.a2b_hex(input)\nclass StreamWriter(Codec, codecs.StreamWriter):\n    charbuffertype = bytes\nclass StreamReader(Codec, codecs.StreamReader):\n    charbuffertype = bytes\n### encodings module API\ndef getregentry():",
        "detail": "pycharm_venv.Lib.encodings.hex_codec",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.hex_codec",
        "description": "pycharm_venv.Lib.encodings.hex_codec",
        "peekOfCode": "class StreamWriter(Codec, codecs.StreamWriter):\n    charbuffertype = bytes\nclass StreamReader(Codec, codecs.StreamReader):\n    charbuffertype = bytes\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='hex',\n        encode=hex_encode,\n        decode=hex_decode,",
        "detail": "pycharm_venv.Lib.encodings.hex_codec",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.hex_codec",
        "description": "pycharm_venv.Lib.encodings.hex_codec",
        "peekOfCode": "class StreamReader(Codec, codecs.StreamReader):\n    charbuffertype = bytes\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='hex',\n        encode=hex_encode,\n        decode=hex_decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.hex_codec",
        "documentation": {}
    },
    {
        "label": "hex_encode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.hex_codec",
        "description": "pycharm_venv.Lib.encodings.hex_codec",
        "peekOfCode": "def hex_encode(input, errors='strict'):\n    assert errors == 'strict'\n    return (binascii.b2a_hex(input), len(input))\ndef hex_decode(input, errors='strict'):\n    assert errors == 'strict'\n    return (binascii.a2b_hex(input), len(input))\nclass Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        return hex_encode(input, errors)\n    def decode(self, input, errors='strict'):",
        "detail": "pycharm_venv.Lib.encodings.hex_codec",
        "documentation": {}
    },
    {
        "label": "hex_decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.hex_codec",
        "description": "pycharm_venv.Lib.encodings.hex_codec",
        "peekOfCode": "def hex_decode(input, errors='strict'):\n    assert errors == 'strict'\n    return (binascii.a2b_hex(input), len(input))\nclass Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        return hex_encode(input, errors)\n    def decode(self, input, errors='strict'):\n        return hex_decode(input, errors)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.hex_codec",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.hex_codec",
        "description": "pycharm_venv.Lib.encodings.hex_codec",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='hex',\n        encode=hex_encode,\n        decode=hex_decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,\n        streamreader=StreamReader,\n        _is_text_encoding=False,",
        "detail": "pycharm_venv.Lib.encodings.hex_codec",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.hp_roman8",
        "description": "pycharm_venv.Lib.encodings.hp_roman8",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.hp_roman8",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.hp_roman8",
        "description": "pycharm_venv.Lib.encodings.hp_roman8",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.hp_roman8",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.hp_roman8",
        "description": "pycharm_venv.Lib.encodings.hp_roman8",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.hp_roman8",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.hp_roman8",
        "description": "pycharm_venv.Lib.encodings.hp_roman8",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='hp-roman8',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.hp_roman8",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.hp_roman8",
        "description": "pycharm_venv.Lib.encodings.hp_roman8",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='hp-roman8',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.hp_roman8",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.hp_roman8",
        "description": "pycharm_venv.Lib.encodings.hp_roman8",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='hp-roman8',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,\n        streamreader=StreamReader,\n    )",
        "detail": "pycharm_venv.Lib.encodings.hp_roman8",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.hp_roman8",
        "description": "pycharm_venv.Lib.encodings.hp_roman8",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.hp_roman8",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.hz",
        "description": "pycharm_venv.Lib.encodings.hz",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.hz",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.hz",
        "description": "pycharm_venv.Lib.encodings.hz",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.hz",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.hz",
        "description": "pycharm_venv.Lib.encodings.hz",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='hz',",
        "detail": "pycharm_venv.Lib.encodings.hz",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.hz",
        "description": "pycharm_venv.Lib.encodings.hz",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='hz',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.hz",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.hz",
        "description": "pycharm_venv.Lib.encodings.hz",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='hz',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.hz",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.hz",
        "description": "pycharm_venv.Lib.encodings.hz",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='hz',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.hz",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.hz",
        "description": "pycharm_venv.Lib.encodings.hz",
        "peekOfCode": "codec = _codecs_cn.getcodec('hz')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.hz",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.idna",
        "description": "pycharm_venv.Lib.encodings.idna",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        if errors != 'strict':\n            # IDNA is quite clear that implementations must be strict\n            raise UnicodeError(f\"Unsupported error handling: {errors}\")\n        if not input:\n            return b'', 0\n        try:\n            result = input.encode('ascii')\n        except UnicodeEncodeError:",
        "detail": "pycharm_venv.Lib.encodings.idna",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.idna",
        "description": "pycharm_venv.Lib.encodings.idna",
        "peekOfCode": "class IncrementalEncoder(codecs.BufferedIncrementalEncoder):\n    def _buffer_encode(self, input, errors, final):\n        if errors != 'strict':\n            # IDNA is quite clear that implementations must be strict\n            raise UnicodeError(f\"Unsupported error handling: {errors}\")\n        if not input:\n            return (b'', 0)\n        labels = dots.split(input)\n        trailing_dot = b''\n        if labels:",
        "detail": "pycharm_venv.Lib.encodings.idna",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.idna",
        "description": "pycharm_venv.Lib.encodings.idna",
        "peekOfCode": "class IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    def _buffer_decode(self, input, errors, final):\n        if errors != 'strict':\n            raise UnicodeError(\"Unsupported error handling: {errors}\")\n        if not input:\n            return (\"\", 0)\n        # IDNA allows decoding to operate on Unicode strings, too.\n        if isinstance(input, str):\n            labels = dots.split(input)\n        else:",
        "detail": "pycharm_venv.Lib.encodings.idna",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.idna",
        "description": "pycharm_venv.Lib.encodings.idna",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='idna',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.idna",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.idna",
        "description": "pycharm_venv.Lib.encodings.idna",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='idna',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.idna",
        "documentation": {}
    },
    {
        "label": "nameprep",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.idna",
        "description": "pycharm_venv.Lib.encodings.idna",
        "peekOfCode": "def nameprep(label):  # type: (str) -> str\n    # Map\n    newlabel = []\n    for c in label:\n        if stringprep.in_table_b1(c):\n            # Map to nothing\n            continue\n        newlabel.append(stringprep.map_table_b2(c))\n    label = \"\".join(newlabel)\n    # Normalize",
        "detail": "pycharm_venv.Lib.encodings.idna",
        "documentation": {}
    },
    {
        "label": "ToASCII",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.idna",
        "description": "pycharm_venv.Lib.encodings.idna",
        "peekOfCode": "def ToASCII(label):  # type: (str) -> bytes\n    try:\n        # Step 1: try ASCII\n        label_ascii = label.encode(\"ascii\")\n    except UnicodeEncodeError:\n        pass\n    else:\n        # Skip to step 3: UseSTD3ASCIIRules is false, so\n        # Skip to step 8.\n        if 0 < len(label_ascii) < 64:",
        "detail": "pycharm_venv.Lib.encodings.idna",
        "documentation": {}
    },
    {
        "label": "ToUnicode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.idna",
        "description": "pycharm_venv.Lib.encodings.idna",
        "peekOfCode": "def ToUnicode(label):\n    if len(label) > 1024:\n        # Protection from https://github.com/python/cpython/issues/98433.\n        # https://datatracker.ietf.org/doc/html/rfc5894#section-6\n        # doesn't specify a label size limit prior to NAMEPREP. But having\n        # one makes practical sense.\n        # This leaves ample room for nameprep() to remove Nothing characters\n        # per https://www.rfc-editor.org/rfc/rfc3454#section-3.1 while still\n        # preventing us from wasting time decoding a big thing that'll just\n        # hit the actual <= 63 length limit in Step 6.",
        "detail": "pycharm_venv.Lib.encodings.idna",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.idna",
        "description": "pycharm_venv.Lib.encodings.idna",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='idna',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,\n        streamreader=StreamReader,\n    )",
        "detail": "pycharm_venv.Lib.encodings.idna",
        "documentation": {}
    },
    {
        "label": "dots",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.idna",
        "description": "pycharm_venv.Lib.encodings.idna",
        "peekOfCode": "dots = re.compile(\"[\\u002E\\u3002\\uFF0E\\uFF61]\")\n# IDNA section 5\nace_prefix = b\"xn--\"\nsace_prefix = \"xn--\"\n# This assumes query strings, so AllowUnassigned is true\ndef nameprep(label):  # type: (str) -> str\n    # Map\n    newlabel = []\n    for c in label:\n        if stringprep.in_table_b1(c):",
        "detail": "pycharm_venv.Lib.encodings.idna",
        "documentation": {}
    },
    {
        "label": "ace_prefix",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.idna",
        "description": "pycharm_venv.Lib.encodings.idna",
        "peekOfCode": "ace_prefix = b\"xn--\"\nsace_prefix = \"xn--\"\n# This assumes query strings, so AllowUnassigned is true\ndef nameprep(label):  # type: (str) -> str\n    # Map\n    newlabel = []\n    for c in label:\n        if stringprep.in_table_b1(c):\n            # Map to nothing\n            continue",
        "detail": "pycharm_venv.Lib.encodings.idna",
        "documentation": {}
    },
    {
        "label": "sace_prefix",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.idna",
        "description": "pycharm_venv.Lib.encodings.idna",
        "peekOfCode": "sace_prefix = \"xn--\"\n# This assumes query strings, so AllowUnassigned is true\ndef nameprep(label):  # type: (str) -> str\n    # Map\n    newlabel = []\n    for c in label:\n        if stringprep.in_table_b1(c):\n            # Map to nothing\n            continue\n        newlabel.append(stringprep.map_table_b2(c))",
        "detail": "pycharm_venv.Lib.encodings.idna",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp',",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp",
        "peekOfCode": "codec = _codecs_iso2022.getcodec('iso2022_jp')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_1',",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_1',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_1',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_1',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "peekOfCode": "codec = _codecs_iso2022.getcodec('iso2022_jp_1')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_1",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_2',",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_2',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_2',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_2',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "peekOfCode": "codec = _codecs_iso2022.getcodec('iso2022_jp_2')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_2",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_2004',",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_2004',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_2004',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_2004',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "peekOfCode": "codec = _codecs_iso2022.getcodec('iso2022_jp_2004')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_2004",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_3',",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_3',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_3',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_3',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "peekOfCode": "codec = _codecs_iso2022.getcodec('iso2022_jp_3')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_3",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_ext',",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_ext',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_ext',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_jp_ext',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "description": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "peekOfCode": "codec = _codecs_iso2022.getcodec('iso2022_jp_ext')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.iso2022_jp_ext",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_kr",
        "description": "pycharm_venv.Lib.encodings.iso2022_kr",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.iso2022_kr",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_kr",
        "description": "pycharm_venv.Lib.encodings.iso2022_kr",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.iso2022_kr",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_kr",
        "description": "pycharm_venv.Lib.encodings.iso2022_kr",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_kr',",
        "detail": "pycharm_venv.Lib.encodings.iso2022_kr",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_kr",
        "description": "pycharm_venv.Lib.encodings.iso2022_kr",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_kr',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.iso2022_kr",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_kr",
        "description": "pycharm_venv.Lib.encodings.iso2022_kr",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_kr',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.iso2022_kr",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_kr",
        "description": "pycharm_venv.Lib.encodings.iso2022_kr",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso2022_kr',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso2022_kr",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso2022_kr",
        "description": "pycharm_venv.Lib.encodings.iso2022_kr",
        "peekOfCode": "codec = _codecs_iso2022.getcodec('iso2022_kr')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.iso2022_kr",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_1",
        "description": "pycharm_venv.Lib.encodings.iso8859_1",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.iso8859_1",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_1",
        "description": "pycharm_venv.Lib.encodings.iso8859_1",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.iso8859_1",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_1",
        "description": "pycharm_venv.Lib.encodings.iso8859_1",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.iso8859_1",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_1",
        "description": "pycharm_venv.Lib.encodings.iso8859_1",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-1',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_1",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_1",
        "description": "pycharm_venv.Lib.encodings.iso8859_1",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-1',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_1",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_1",
        "description": "pycharm_venv.Lib.encodings.iso8859_1",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-1',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso8859_1",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_1",
        "description": "pycharm_venv.Lib.encodings.iso8859_1",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.iso8859_1",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_10",
        "description": "pycharm_venv.Lib.encodings.iso8859_10",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.iso8859_10",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_10",
        "description": "pycharm_venv.Lib.encodings.iso8859_10",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.iso8859_10",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_10",
        "description": "pycharm_venv.Lib.encodings.iso8859_10",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.iso8859_10",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_10",
        "description": "pycharm_venv.Lib.encodings.iso8859_10",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-10',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_10",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_10",
        "description": "pycharm_venv.Lib.encodings.iso8859_10",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-10',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_10",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_10",
        "description": "pycharm_venv.Lib.encodings.iso8859_10",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-10',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso8859_10",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_10",
        "description": "pycharm_venv.Lib.encodings.iso8859_10",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.iso8859_10",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_11",
        "description": "pycharm_venv.Lib.encodings.iso8859_11",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.iso8859_11",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_11",
        "description": "pycharm_venv.Lib.encodings.iso8859_11",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.iso8859_11",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_11",
        "description": "pycharm_venv.Lib.encodings.iso8859_11",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.iso8859_11",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_11",
        "description": "pycharm_venv.Lib.encodings.iso8859_11",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-11',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_11",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_11",
        "description": "pycharm_venv.Lib.encodings.iso8859_11",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-11',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_11",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_11",
        "description": "pycharm_venv.Lib.encodings.iso8859_11",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-11',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso8859_11",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_11",
        "description": "pycharm_venv.Lib.encodings.iso8859_11",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.iso8859_11",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_13",
        "description": "pycharm_venv.Lib.encodings.iso8859_13",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.iso8859_13",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_13",
        "description": "pycharm_venv.Lib.encodings.iso8859_13",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.iso8859_13",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_13",
        "description": "pycharm_venv.Lib.encodings.iso8859_13",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.iso8859_13",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_13",
        "description": "pycharm_venv.Lib.encodings.iso8859_13",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-13',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_13",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_13",
        "description": "pycharm_venv.Lib.encodings.iso8859_13",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-13',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_13",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_13",
        "description": "pycharm_venv.Lib.encodings.iso8859_13",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-13',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso8859_13",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_13",
        "description": "pycharm_venv.Lib.encodings.iso8859_13",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.iso8859_13",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_14",
        "description": "pycharm_venv.Lib.encodings.iso8859_14",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.iso8859_14",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_14",
        "description": "pycharm_venv.Lib.encodings.iso8859_14",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.iso8859_14",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_14",
        "description": "pycharm_venv.Lib.encodings.iso8859_14",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.iso8859_14",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_14",
        "description": "pycharm_venv.Lib.encodings.iso8859_14",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-14',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_14",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_14",
        "description": "pycharm_venv.Lib.encodings.iso8859_14",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-14',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_14",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_14",
        "description": "pycharm_venv.Lib.encodings.iso8859_14",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-14',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso8859_14",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_14",
        "description": "pycharm_venv.Lib.encodings.iso8859_14",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.iso8859_14",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_15",
        "description": "pycharm_venv.Lib.encodings.iso8859_15",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.iso8859_15",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_15",
        "description": "pycharm_venv.Lib.encodings.iso8859_15",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.iso8859_15",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_15",
        "description": "pycharm_venv.Lib.encodings.iso8859_15",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.iso8859_15",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_15",
        "description": "pycharm_venv.Lib.encodings.iso8859_15",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-15',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_15",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_15",
        "description": "pycharm_venv.Lib.encodings.iso8859_15",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-15',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_15",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_15",
        "description": "pycharm_venv.Lib.encodings.iso8859_15",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-15',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso8859_15",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_15",
        "description": "pycharm_venv.Lib.encodings.iso8859_15",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.iso8859_15",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_16",
        "description": "pycharm_venv.Lib.encodings.iso8859_16",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.iso8859_16",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_16",
        "description": "pycharm_venv.Lib.encodings.iso8859_16",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.iso8859_16",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_16",
        "description": "pycharm_venv.Lib.encodings.iso8859_16",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.iso8859_16",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_16",
        "description": "pycharm_venv.Lib.encodings.iso8859_16",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-16',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_16",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_16",
        "description": "pycharm_venv.Lib.encodings.iso8859_16",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-16',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_16",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_16",
        "description": "pycharm_venv.Lib.encodings.iso8859_16",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-16',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso8859_16",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_16",
        "description": "pycharm_venv.Lib.encodings.iso8859_16",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.iso8859_16",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_2",
        "description": "pycharm_venv.Lib.encodings.iso8859_2",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.iso8859_2",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_2",
        "description": "pycharm_venv.Lib.encodings.iso8859_2",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.iso8859_2",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_2",
        "description": "pycharm_venv.Lib.encodings.iso8859_2",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.iso8859_2",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_2",
        "description": "pycharm_venv.Lib.encodings.iso8859_2",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-2',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_2",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_2",
        "description": "pycharm_venv.Lib.encodings.iso8859_2",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-2',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_2",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_2",
        "description": "pycharm_venv.Lib.encodings.iso8859_2",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-2',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso8859_2",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_2",
        "description": "pycharm_venv.Lib.encodings.iso8859_2",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.iso8859_2",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_3",
        "description": "pycharm_venv.Lib.encodings.iso8859_3",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.iso8859_3",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_3",
        "description": "pycharm_venv.Lib.encodings.iso8859_3",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.iso8859_3",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_3",
        "description": "pycharm_venv.Lib.encodings.iso8859_3",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.iso8859_3",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_3",
        "description": "pycharm_venv.Lib.encodings.iso8859_3",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-3',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_3",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_3",
        "description": "pycharm_venv.Lib.encodings.iso8859_3",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-3',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_3",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_3",
        "description": "pycharm_venv.Lib.encodings.iso8859_3",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-3',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso8859_3",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_3",
        "description": "pycharm_venv.Lib.encodings.iso8859_3",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.iso8859_3",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_4",
        "description": "pycharm_venv.Lib.encodings.iso8859_4",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.iso8859_4",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_4",
        "description": "pycharm_venv.Lib.encodings.iso8859_4",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.iso8859_4",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_4",
        "description": "pycharm_venv.Lib.encodings.iso8859_4",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.iso8859_4",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_4",
        "description": "pycharm_venv.Lib.encodings.iso8859_4",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-4',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_4",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_4",
        "description": "pycharm_venv.Lib.encodings.iso8859_4",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-4',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_4",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_4",
        "description": "pycharm_venv.Lib.encodings.iso8859_4",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-4',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso8859_4",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_4",
        "description": "pycharm_venv.Lib.encodings.iso8859_4",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.iso8859_4",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_5",
        "description": "pycharm_venv.Lib.encodings.iso8859_5",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.iso8859_5",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_5",
        "description": "pycharm_venv.Lib.encodings.iso8859_5",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.iso8859_5",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_5",
        "description": "pycharm_venv.Lib.encodings.iso8859_5",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.iso8859_5",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_5",
        "description": "pycharm_venv.Lib.encodings.iso8859_5",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-5',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_5",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_5",
        "description": "pycharm_venv.Lib.encodings.iso8859_5",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-5',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_5",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_5",
        "description": "pycharm_venv.Lib.encodings.iso8859_5",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-5',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso8859_5",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_5",
        "description": "pycharm_venv.Lib.encodings.iso8859_5",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.iso8859_5",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_6",
        "description": "pycharm_venv.Lib.encodings.iso8859_6",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.iso8859_6",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_6",
        "description": "pycharm_venv.Lib.encodings.iso8859_6",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.iso8859_6",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_6",
        "description": "pycharm_venv.Lib.encodings.iso8859_6",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.iso8859_6",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_6",
        "description": "pycharm_venv.Lib.encodings.iso8859_6",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-6',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_6",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_6",
        "description": "pycharm_venv.Lib.encodings.iso8859_6",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-6',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_6",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_6",
        "description": "pycharm_venv.Lib.encodings.iso8859_6",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-6',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso8859_6",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_6",
        "description": "pycharm_venv.Lib.encodings.iso8859_6",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.iso8859_6",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_7",
        "description": "pycharm_venv.Lib.encodings.iso8859_7",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.iso8859_7",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_7",
        "description": "pycharm_venv.Lib.encodings.iso8859_7",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.iso8859_7",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_7",
        "description": "pycharm_venv.Lib.encodings.iso8859_7",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.iso8859_7",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_7",
        "description": "pycharm_venv.Lib.encodings.iso8859_7",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-7',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_7",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_7",
        "description": "pycharm_venv.Lib.encodings.iso8859_7",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-7',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_7",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_7",
        "description": "pycharm_venv.Lib.encodings.iso8859_7",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-7',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso8859_7",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_7",
        "description": "pycharm_venv.Lib.encodings.iso8859_7",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.iso8859_7",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_8",
        "description": "pycharm_venv.Lib.encodings.iso8859_8",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.iso8859_8",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_8",
        "description": "pycharm_venv.Lib.encodings.iso8859_8",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.iso8859_8",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_8",
        "description": "pycharm_venv.Lib.encodings.iso8859_8",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.iso8859_8",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_8",
        "description": "pycharm_venv.Lib.encodings.iso8859_8",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-8',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_8",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_8",
        "description": "pycharm_venv.Lib.encodings.iso8859_8",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-8',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_8",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_8",
        "description": "pycharm_venv.Lib.encodings.iso8859_8",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-8',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso8859_8",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_8",
        "description": "pycharm_venv.Lib.encodings.iso8859_8",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.iso8859_8",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_9",
        "description": "pycharm_venv.Lib.encodings.iso8859_9",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.iso8859_9",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_9",
        "description": "pycharm_venv.Lib.encodings.iso8859_9",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.iso8859_9",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_9",
        "description": "pycharm_venv.Lib.encodings.iso8859_9",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.iso8859_9",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_9",
        "description": "pycharm_venv.Lib.encodings.iso8859_9",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-9',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_9",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_9",
        "description": "pycharm_venv.Lib.encodings.iso8859_9",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-9',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.iso8859_9",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_9",
        "description": "pycharm_venv.Lib.encodings.iso8859_9",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-9',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.iso8859_9",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.iso8859_9",
        "description": "pycharm_venv.Lib.encodings.iso8859_9",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.iso8859_9",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.johab",
        "description": "pycharm_venv.Lib.encodings.johab",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.johab",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.johab",
        "description": "pycharm_venv.Lib.encodings.johab",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.johab",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.johab",
        "description": "pycharm_venv.Lib.encodings.johab",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='johab',",
        "detail": "pycharm_venv.Lib.encodings.johab",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.johab",
        "description": "pycharm_venv.Lib.encodings.johab",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='johab',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.johab",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.johab",
        "description": "pycharm_venv.Lib.encodings.johab",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='johab',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.johab",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.johab",
        "description": "pycharm_venv.Lib.encodings.johab",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='johab',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.johab",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.johab",
        "description": "pycharm_venv.Lib.encodings.johab",
        "peekOfCode": "codec = _codecs_kr.getcodec('johab')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.johab",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.koi8_r",
        "description": "pycharm_venv.Lib.encodings.koi8_r",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.koi8_r",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.koi8_r",
        "description": "pycharm_venv.Lib.encodings.koi8_r",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.koi8_r",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.koi8_r",
        "description": "pycharm_venv.Lib.encodings.koi8_r",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.koi8_r",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.koi8_r",
        "description": "pycharm_venv.Lib.encodings.koi8_r",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='koi8-r',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.koi8_r",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.koi8_r",
        "description": "pycharm_venv.Lib.encodings.koi8_r",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='koi8-r',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.koi8_r",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.koi8_r",
        "description": "pycharm_venv.Lib.encodings.koi8_r",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='koi8-r',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.koi8_r",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.koi8_r",
        "description": "pycharm_venv.Lib.encodings.koi8_r",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.koi8_r",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.koi8_t",
        "description": "pycharm_venv.Lib.encodings.koi8_t",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.koi8_t",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.koi8_t",
        "description": "pycharm_venv.Lib.encodings.koi8_t",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.koi8_t",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.koi8_t",
        "description": "pycharm_venv.Lib.encodings.koi8_t",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.koi8_t",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.koi8_t",
        "description": "pycharm_venv.Lib.encodings.koi8_t",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='koi8-t',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.koi8_t",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.koi8_t",
        "description": "pycharm_venv.Lib.encodings.koi8_t",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='koi8-t',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.koi8_t",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.koi8_t",
        "description": "pycharm_venv.Lib.encodings.koi8_t",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='koi8-t',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.koi8_t",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.koi8_t",
        "description": "pycharm_venv.Lib.encodings.koi8_t",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.koi8_t",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.koi8_u",
        "description": "pycharm_venv.Lib.encodings.koi8_u",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.koi8_u",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.koi8_u",
        "description": "pycharm_venv.Lib.encodings.koi8_u",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.koi8_u",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.koi8_u",
        "description": "pycharm_venv.Lib.encodings.koi8_u",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.koi8_u",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.koi8_u",
        "description": "pycharm_venv.Lib.encodings.koi8_u",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='koi8-u',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.koi8_u",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.koi8_u",
        "description": "pycharm_venv.Lib.encodings.koi8_u",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='koi8-u',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.koi8_u",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.koi8_u",
        "description": "pycharm_venv.Lib.encodings.koi8_u",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='koi8-u',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.koi8_u",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.koi8_u",
        "description": "pycharm_venv.Lib.encodings.koi8_u",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.koi8_u",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.kz1048",
        "description": "pycharm_venv.Lib.encodings.kz1048",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        return codecs.charmap_encode(input, errors, encoding_table)\n    def decode(self, input, errors='strict'):\n        return codecs.charmap_decode(input, errors, decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input, self.errors, encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.kz1048",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.kz1048",
        "description": "pycharm_venv.Lib.encodings.kz1048",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input, self.errors, encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input, self.errors, decoding_table)[0]\nclass StreamWriter(Codec, codecs.StreamWriter):\n    pass\nclass StreamReader(Codec, codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.kz1048",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.kz1048",
        "description": "pycharm_venv.Lib.encodings.kz1048",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input, self.errors, decoding_table)[0]\nclass StreamWriter(Codec, codecs.StreamWriter):\n    pass\nclass StreamReader(Codec, codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.kz1048",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.kz1048",
        "description": "pycharm_venv.Lib.encodings.kz1048",
        "peekOfCode": "class StreamWriter(Codec, codecs.StreamWriter):\n    pass\nclass StreamReader(Codec, codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='kz1048',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.kz1048",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.kz1048",
        "description": "pycharm_venv.Lib.encodings.kz1048",
        "peekOfCode": "class StreamReader(Codec, codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='kz1048',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.kz1048",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.kz1048",
        "description": "pycharm_venv.Lib.encodings.kz1048",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='kz1048',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.kz1048",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.kz1048",
        "description": "pycharm_venv.Lib.encodings.kz1048",
        "peekOfCode": "decoding_table = (\n    '\\x00'      #  0x00 -> NULL\n    '\\x01'      #  0x01 -> START OF HEADING\n    '\\x02'      #  0x02 -> START OF TEXT\n    '\\x03'      #  0x03 -> END OF TEXT\n    '\\x04'      #  0x04 -> END OF TRANSMISSION\n    '\\x05'      #  0x05 -> ENQUIRY\n    '\\x06'      #  0x06 -> ACKNOWLEDGE\n    '\\x07'      #  0x07 -> BELL\n    '\\x08'      #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.kz1048",
        "documentation": {}
    },
    {
        "label": "encoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.kz1048",
        "description": "pycharm_venv.Lib.encodings.kz1048",
        "peekOfCode": "encoding_table = codecs.charmap_build(decoding_table)",
        "detail": "pycharm_venv.Lib.encodings.kz1048",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.latin_1",
        "description": "pycharm_venv.Lib.encodings.latin_1",
        "peekOfCode": "class Codec(codecs.Codec):\n    # Note: Binding these as C functions will result in the class not\n    # converting them to methods. This is intended.\n    encode = codecs.latin_1_encode\n    decode = codecs.latin_1_decode\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.latin_1_encode(input,self.errors)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.latin_1",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.latin_1",
        "description": "pycharm_venv.Lib.encodings.latin_1",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.latin_1_encode(input,self.errors)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.latin_1_decode(input,self.errors)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.latin_1",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.latin_1",
        "description": "pycharm_venv.Lib.encodings.latin_1",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.latin_1_decode(input,self.errors)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\nclass StreamConverter(StreamWriter,StreamReader):\n    encode = codecs.latin_1_decode\n    decode = codecs.latin_1_encode",
        "detail": "pycharm_venv.Lib.encodings.latin_1",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.latin_1",
        "description": "pycharm_venv.Lib.encodings.latin_1",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\nclass StreamConverter(StreamWriter,StreamReader):\n    encode = codecs.latin_1_decode\n    decode = codecs.latin_1_encode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.latin_1",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.latin_1",
        "description": "pycharm_venv.Lib.encodings.latin_1",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\nclass StreamConverter(StreamWriter,StreamReader):\n    encode = codecs.latin_1_decode\n    decode = codecs.latin_1_encode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-1',\n        encode=Codec.encode,",
        "detail": "pycharm_venv.Lib.encodings.latin_1",
        "documentation": {}
    },
    {
        "label": "StreamConverter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.latin_1",
        "description": "pycharm_venv.Lib.encodings.latin_1",
        "peekOfCode": "class StreamConverter(StreamWriter,StreamReader):\n    encode = codecs.latin_1_decode\n    decode = codecs.latin_1_encode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-1',\n        encode=Codec.encode,\n        decode=Codec.decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.latin_1",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.latin_1",
        "description": "pycharm_venv.Lib.encodings.latin_1",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='iso8859-1',\n        encode=Codec.encode,\n        decode=Codec.decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.latin_1",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_arabic",
        "description": "pycharm_venv.Lib.encodings.mac_arabic",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_map)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.mac_arabic",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_arabic",
        "description": "pycharm_venv.Lib.encodings.mac_arabic",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.mac_arabic",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_arabic",
        "description": "pycharm_venv.Lib.encodings.mac_arabic",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.mac_arabic",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_arabic",
        "description": "pycharm_venv.Lib.encodings.mac_arabic",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-arabic',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.mac_arabic",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_arabic",
        "description": "pycharm_venv.Lib.encodings.mac_arabic",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-arabic',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.mac_arabic",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.mac_arabic",
        "description": "pycharm_venv.Lib.encodings.mac_arabic",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='mac-arabic',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.mac_arabic",
        "documentation": {}
    },
    {
        "label": "decoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.mac_arabic",
        "description": "pycharm_venv.Lib.encodings.mac_arabic",
        "peekOfCode": "decoding_map = codecs.make_identity_dict(range(256))\ndecoding_map.update({\n    0x0080: 0x00c4,     #  LATIN CAPITAL LETTER A WITH DIAERESIS\n    0x0081: 0x00a0,     #  NO-BREAK SPACE, right-left\n    0x0082: 0x00c7,     #  LATIN CAPITAL LETTER C WITH CEDILLA\n    0x0083: 0x00c9,     #  LATIN CAPITAL LETTER E WITH ACUTE\n    0x0084: 0x00d1,     #  LATIN CAPITAL LETTER N WITH TILDE\n    0x0085: 0x00d6,     #  LATIN CAPITAL LETTER O WITH DIAERESIS\n    0x0086: 0x00dc,     #  LATIN CAPITAL LETTER U WITH DIAERESIS\n    0x0087: 0x00e1,     #  LATIN SMALL LETTER A WITH ACUTE",
        "detail": "pycharm_venv.Lib.encodings.mac_arabic",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.mac_arabic",
        "description": "pycharm_venv.Lib.encodings.mac_arabic",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x0000 -> CONTROL CHARACTER\n    '\\x01'     #  0x0001 -> CONTROL CHARACTER\n    '\\x02'     #  0x0002 -> CONTROL CHARACTER\n    '\\x03'     #  0x0003 -> CONTROL CHARACTER\n    '\\x04'     #  0x0004 -> CONTROL CHARACTER\n    '\\x05'     #  0x0005 -> CONTROL CHARACTER\n    '\\x06'     #  0x0006 -> CONTROL CHARACTER\n    '\\x07'     #  0x0007 -> CONTROL CHARACTER\n    '\\x08'     #  0x0008 -> CONTROL CHARACTER",
        "detail": "pycharm_venv.Lib.encodings.mac_arabic",
        "documentation": {}
    },
    {
        "label": "encoding_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.mac_arabic",
        "description": "pycharm_venv.Lib.encodings.mac_arabic",
        "peekOfCode": "encoding_map = {\n    0x0000: 0x0000,     #  CONTROL CHARACTER\n    0x0001: 0x0001,     #  CONTROL CHARACTER\n    0x0002: 0x0002,     #  CONTROL CHARACTER\n    0x0003: 0x0003,     #  CONTROL CHARACTER\n    0x0004: 0x0004,     #  CONTROL CHARACTER\n    0x0005: 0x0005,     #  CONTROL CHARACTER\n    0x0006: 0x0006,     #  CONTROL CHARACTER\n    0x0007: 0x0007,     #  CONTROL CHARACTER\n    0x0008: 0x0008,     #  CONTROL CHARACTER",
        "detail": "pycharm_venv.Lib.encodings.mac_arabic",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_croatian",
        "description": "pycharm_venv.Lib.encodings.mac_croatian",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.mac_croatian",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_croatian",
        "description": "pycharm_venv.Lib.encodings.mac_croatian",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.mac_croatian",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_croatian",
        "description": "pycharm_venv.Lib.encodings.mac_croatian",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.mac_croatian",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_croatian",
        "description": "pycharm_venv.Lib.encodings.mac_croatian",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-croatian',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.mac_croatian",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_croatian",
        "description": "pycharm_venv.Lib.encodings.mac_croatian",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-croatian',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.mac_croatian",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.mac_croatian",
        "description": "pycharm_venv.Lib.encodings.mac_croatian",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='mac-croatian',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.mac_croatian",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.mac_croatian",
        "description": "pycharm_venv.Lib.encodings.mac_croatian",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> CONTROL CHARACTER\n    '\\x01'     #  0x01 -> CONTROL CHARACTER\n    '\\x02'     #  0x02 -> CONTROL CHARACTER\n    '\\x03'     #  0x03 -> CONTROL CHARACTER\n    '\\x04'     #  0x04 -> CONTROL CHARACTER\n    '\\x05'     #  0x05 -> CONTROL CHARACTER\n    '\\x06'     #  0x06 -> CONTROL CHARACTER\n    '\\x07'     #  0x07 -> CONTROL CHARACTER\n    '\\x08'     #  0x08 -> CONTROL CHARACTER",
        "detail": "pycharm_venv.Lib.encodings.mac_croatian",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "description": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "description": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "description": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "description": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-cyrillic',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "description": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-cyrillic',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "description": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='mac-cyrillic',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "description": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> CONTROL CHARACTER\n    '\\x01'     #  0x01 -> CONTROL CHARACTER\n    '\\x02'     #  0x02 -> CONTROL CHARACTER\n    '\\x03'     #  0x03 -> CONTROL CHARACTER\n    '\\x04'     #  0x04 -> CONTROL CHARACTER\n    '\\x05'     #  0x05 -> CONTROL CHARACTER\n    '\\x06'     #  0x06 -> CONTROL CHARACTER\n    '\\x07'     #  0x07 -> CONTROL CHARACTER\n    '\\x08'     #  0x08 -> CONTROL CHARACTER",
        "detail": "pycharm_venv.Lib.encodings.mac_cyrillic",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_farsi",
        "description": "pycharm_venv.Lib.encodings.mac_farsi",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.mac_farsi",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_farsi",
        "description": "pycharm_venv.Lib.encodings.mac_farsi",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.mac_farsi",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_farsi",
        "description": "pycharm_venv.Lib.encodings.mac_farsi",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.mac_farsi",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_farsi",
        "description": "pycharm_venv.Lib.encodings.mac_farsi",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-farsi',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.mac_farsi",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_farsi",
        "description": "pycharm_venv.Lib.encodings.mac_farsi",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-farsi',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.mac_farsi",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.mac_farsi",
        "description": "pycharm_venv.Lib.encodings.mac_farsi",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='mac-farsi',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.mac_farsi",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.mac_farsi",
        "description": "pycharm_venv.Lib.encodings.mac_farsi",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> CONTROL CHARACTER\n    '\\x01'     #  0x01 -> CONTROL CHARACTER\n    '\\x02'     #  0x02 -> CONTROL CHARACTER\n    '\\x03'     #  0x03 -> CONTROL CHARACTER\n    '\\x04'     #  0x04 -> CONTROL CHARACTER\n    '\\x05'     #  0x05 -> CONTROL CHARACTER\n    '\\x06'     #  0x06 -> CONTROL CHARACTER\n    '\\x07'     #  0x07 -> CONTROL CHARACTER\n    '\\x08'     #  0x08 -> CONTROL CHARACTER",
        "detail": "pycharm_venv.Lib.encodings.mac_farsi",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_greek",
        "description": "pycharm_venv.Lib.encodings.mac_greek",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.mac_greek",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_greek",
        "description": "pycharm_venv.Lib.encodings.mac_greek",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.mac_greek",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_greek",
        "description": "pycharm_venv.Lib.encodings.mac_greek",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.mac_greek",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_greek",
        "description": "pycharm_venv.Lib.encodings.mac_greek",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-greek',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.mac_greek",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_greek",
        "description": "pycharm_venv.Lib.encodings.mac_greek",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-greek',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.mac_greek",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.mac_greek",
        "description": "pycharm_venv.Lib.encodings.mac_greek",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='mac-greek',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.mac_greek",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.mac_greek",
        "description": "pycharm_venv.Lib.encodings.mac_greek",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> CONTROL CHARACTER\n    '\\x01'     #  0x01 -> CONTROL CHARACTER\n    '\\x02'     #  0x02 -> CONTROL CHARACTER\n    '\\x03'     #  0x03 -> CONTROL CHARACTER\n    '\\x04'     #  0x04 -> CONTROL CHARACTER\n    '\\x05'     #  0x05 -> CONTROL CHARACTER\n    '\\x06'     #  0x06 -> CONTROL CHARACTER\n    '\\x07'     #  0x07 -> CONTROL CHARACTER\n    '\\x08'     #  0x08 -> CONTROL CHARACTER",
        "detail": "pycharm_venv.Lib.encodings.mac_greek",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_iceland",
        "description": "pycharm_venv.Lib.encodings.mac_iceland",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.mac_iceland",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_iceland",
        "description": "pycharm_venv.Lib.encodings.mac_iceland",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.mac_iceland",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_iceland",
        "description": "pycharm_venv.Lib.encodings.mac_iceland",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.mac_iceland",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_iceland",
        "description": "pycharm_venv.Lib.encodings.mac_iceland",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-iceland',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.mac_iceland",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_iceland",
        "description": "pycharm_venv.Lib.encodings.mac_iceland",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-iceland',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.mac_iceland",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.mac_iceland",
        "description": "pycharm_venv.Lib.encodings.mac_iceland",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='mac-iceland',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.mac_iceland",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.mac_iceland",
        "description": "pycharm_venv.Lib.encodings.mac_iceland",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> CONTROL CHARACTER\n    '\\x01'     #  0x01 -> CONTROL CHARACTER\n    '\\x02'     #  0x02 -> CONTROL CHARACTER\n    '\\x03'     #  0x03 -> CONTROL CHARACTER\n    '\\x04'     #  0x04 -> CONTROL CHARACTER\n    '\\x05'     #  0x05 -> CONTROL CHARACTER\n    '\\x06'     #  0x06 -> CONTROL CHARACTER\n    '\\x07'     #  0x07 -> CONTROL CHARACTER\n    '\\x08'     #  0x08 -> CONTROL CHARACTER",
        "detail": "pycharm_venv.Lib.encodings.mac_iceland",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_latin2",
        "description": "pycharm_venv.Lib.encodings.mac_latin2",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.mac_latin2",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_latin2",
        "description": "pycharm_venv.Lib.encodings.mac_latin2",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.mac_latin2",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_latin2",
        "description": "pycharm_venv.Lib.encodings.mac_latin2",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.mac_latin2",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_latin2",
        "description": "pycharm_venv.Lib.encodings.mac_latin2",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-latin2',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.mac_latin2",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_latin2",
        "description": "pycharm_venv.Lib.encodings.mac_latin2",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-latin2',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.mac_latin2",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.mac_latin2",
        "description": "pycharm_venv.Lib.encodings.mac_latin2",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='mac-latin2',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.mac_latin2",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.mac_latin2",
        "description": "pycharm_venv.Lib.encodings.mac_latin2",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.mac_latin2",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_roman",
        "description": "pycharm_venv.Lib.encodings.mac_roman",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.mac_roman",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_roman",
        "description": "pycharm_venv.Lib.encodings.mac_roman",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.mac_roman",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_roman",
        "description": "pycharm_venv.Lib.encodings.mac_roman",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.mac_roman",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_roman",
        "description": "pycharm_venv.Lib.encodings.mac_roman",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-roman',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.mac_roman",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_roman",
        "description": "pycharm_venv.Lib.encodings.mac_roman",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-roman',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.mac_roman",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.mac_roman",
        "description": "pycharm_venv.Lib.encodings.mac_roman",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='mac-roman',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.mac_roman",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.mac_roman",
        "description": "pycharm_venv.Lib.encodings.mac_roman",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> CONTROL CHARACTER\n    '\\x01'     #  0x01 -> CONTROL CHARACTER\n    '\\x02'     #  0x02 -> CONTROL CHARACTER\n    '\\x03'     #  0x03 -> CONTROL CHARACTER\n    '\\x04'     #  0x04 -> CONTROL CHARACTER\n    '\\x05'     #  0x05 -> CONTROL CHARACTER\n    '\\x06'     #  0x06 -> CONTROL CHARACTER\n    '\\x07'     #  0x07 -> CONTROL CHARACTER\n    '\\x08'     #  0x08 -> CONTROL CHARACTER",
        "detail": "pycharm_venv.Lib.encodings.mac_roman",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_romanian",
        "description": "pycharm_venv.Lib.encodings.mac_romanian",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.mac_romanian",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_romanian",
        "description": "pycharm_venv.Lib.encodings.mac_romanian",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.mac_romanian",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_romanian",
        "description": "pycharm_venv.Lib.encodings.mac_romanian",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.mac_romanian",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_romanian",
        "description": "pycharm_venv.Lib.encodings.mac_romanian",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-romanian',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.mac_romanian",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_romanian",
        "description": "pycharm_venv.Lib.encodings.mac_romanian",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-romanian',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.mac_romanian",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.mac_romanian",
        "description": "pycharm_venv.Lib.encodings.mac_romanian",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='mac-romanian',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.mac_romanian",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.mac_romanian",
        "description": "pycharm_venv.Lib.encodings.mac_romanian",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> CONTROL CHARACTER\n    '\\x01'     #  0x01 -> CONTROL CHARACTER\n    '\\x02'     #  0x02 -> CONTROL CHARACTER\n    '\\x03'     #  0x03 -> CONTROL CHARACTER\n    '\\x04'     #  0x04 -> CONTROL CHARACTER\n    '\\x05'     #  0x05 -> CONTROL CHARACTER\n    '\\x06'     #  0x06 -> CONTROL CHARACTER\n    '\\x07'     #  0x07 -> CONTROL CHARACTER\n    '\\x08'     #  0x08 -> CONTROL CHARACTER",
        "detail": "pycharm_venv.Lib.encodings.mac_romanian",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_turkish",
        "description": "pycharm_venv.Lib.encodings.mac_turkish",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.mac_turkish",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_turkish",
        "description": "pycharm_venv.Lib.encodings.mac_turkish",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.mac_turkish",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_turkish",
        "description": "pycharm_venv.Lib.encodings.mac_turkish",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.mac_turkish",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_turkish",
        "description": "pycharm_venv.Lib.encodings.mac_turkish",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-turkish',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.mac_turkish",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mac_turkish",
        "description": "pycharm_venv.Lib.encodings.mac_turkish",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mac-turkish',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.mac_turkish",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.mac_turkish",
        "description": "pycharm_venv.Lib.encodings.mac_turkish",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='mac-turkish',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.mac_turkish",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.mac_turkish",
        "description": "pycharm_venv.Lib.encodings.mac_turkish",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> CONTROL CHARACTER\n    '\\x01'     #  0x01 -> CONTROL CHARACTER\n    '\\x02'     #  0x02 -> CONTROL CHARACTER\n    '\\x03'     #  0x03 -> CONTROL CHARACTER\n    '\\x04'     #  0x04 -> CONTROL CHARACTER\n    '\\x05'     #  0x05 -> CONTROL CHARACTER\n    '\\x06'     #  0x06 -> CONTROL CHARACTER\n    '\\x07'     #  0x07 -> CONTROL CHARACTER\n    '\\x08'     #  0x08 -> CONTROL CHARACTER",
        "detail": "pycharm_venv.Lib.encodings.mac_turkish",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mbcs",
        "description": "pycharm_venv.Lib.encodings.mbcs",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return mbcs_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = mbcs_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = mbcs_encode\nclass StreamReader(codecs.StreamReader):\n    decode = mbcs_decode\n### encodings module API",
        "detail": "pycharm_venv.Lib.encodings.mbcs",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mbcs",
        "description": "pycharm_venv.Lib.encodings.mbcs",
        "peekOfCode": "class IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = mbcs_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = mbcs_encode\nclass StreamReader(codecs.StreamReader):\n    decode = mbcs_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mbcs',",
        "detail": "pycharm_venv.Lib.encodings.mbcs",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mbcs",
        "description": "pycharm_venv.Lib.encodings.mbcs",
        "peekOfCode": "class StreamWriter(codecs.StreamWriter):\n    encode = mbcs_encode\nclass StreamReader(codecs.StreamReader):\n    decode = mbcs_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mbcs',\n        encode=encode,\n        decode=decode,",
        "detail": "pycharm_venv.Lib.encodings.mbcs",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.mbcs",
        "description": "pycharm_venv.Lib.encodings.mbcs",
        "peekOfCode": "class StreamReader(codecs.StreamReader):\n    decode = mbcs_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='mbcs',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.mbcs",
        "documentation": {}
    },
    {
        "label": "decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.mbcs",
        "description": "pycharm_venv.Lib.encodings.mbcs",
        "peekOfCode": "def decode(input, errors='strict'):\n    return mbcs_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return mbcs_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = mbcs_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = mbcs_encode\nclass StreamReader(codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.mbcs",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.mbcs",
        "description": "pycharm_venv.Lib.encodings.mbcs",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='mbcs',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.mbcs",
        "documentation": {}
    },
    {
        "label": "encode",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.mbcs",
        "description": "pycharm_venv.Lib.encodings.mbcs",
        "peekOfCode": "encode = mbcs_encode\ndef decode(input, errors='strict'):\n    return mbcs_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return mbcs_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = mbcs_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = mbcs_encode",
        "detail": "pycharm_venv.Lib.encodings.mbcs",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.oem",
        "description": "pycharm_venv.Lib.encodings.oem",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return oem_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = oem_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = oem_encode\nclass StreamReader(codecs.StreamReader):\n    decode = oem_decode\n### encodings module API",
        "detail": "pycharm_venv.Lib.encodings.oem",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.oem",
        "description": "pycharm_venv.Lib.encodings.oem",
        "peekOfCode": "class IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = oem_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = oem_encode\nclass StreamReader(codecs.StreamReader):\n    decode = oem_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='oem',",
        "detail": "pycharm_venv.Lib.encodings.oem",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.oem",
        "description": "pycharm_venv.Lib.encodings.oem",
        "peekOfCode": "class StreamWriter(codecs.StreamWriter):\n    encode = oem_encode\nclass StreamReader(codecs.StreamReader):\n    decode = oem_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='oem',\n        encode=encode,\n        decode=decode,",
        "detail": "pycharm_venv.Lib.encodings.oem",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.oem",
        "description": "pycharm_venv.Lib.encodings.oem",
        "peekOfCode": "class StreamReader(codecs.StreamReader):\n    decode = oem_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='oem',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.oem",
        "documentation": {}
    },
    {
        "label": "decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.oem",
        "description": "pycharm_venv.Lib.encodings.oem",
        "peekOfCode": "def decode(input, errors='strict'):\n    return oem_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return oem_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = oem_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = oem_encode\nclass StreamReader(codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.oem",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.oem",
        "description": "pycharm_venv.Lib.encodings.oem",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='oem',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.oem",
        "documentation": {}
    },
    {
        "label": "encode",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.oem",
        "description": "pycharm_venv.Lib.encodings.oem",
        "peekOfCode": "encode = oem_encode\ndef decode(input, errors='strict'):\n    return oem_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return oem_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = oem_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = oem_encode",
        "detail": "pycharm_venv.Lib.encodings.oem",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.palmos",
        "description": "pycharm_venv.Lib.encodings.palmos",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.palmos",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.palmos",
        "description": "pycharm_venv.Lib.encodings.palmos",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.palmos",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.palmos",
        "description": "pycharm_venv.Lib.encodings.palmos",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.palmos",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.palmos",
        "description": "pycharm_venv.Lib.encodings.palmos",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='palmos',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.palmos",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.palmos",
        "description": "pycharm_venv.Lib.encodings.palmos",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='palmos',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.palmos",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.palmos",
        "description": "pycharm_venv.Lib.encodings.palmos",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='palmos',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.palmos",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.palmos",
        "description": "pycharm_venv.Lib.encodings.palmos",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.palmos",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.ptcp154",
        "description": "pycharm_venv.Lib.encodings.ptcp154",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.ptcp154",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.ptcp154",
        "description": "pycharm_venv.Lib.encodings.ptcp154",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.ptcp154",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.ptcp154",
        "description": "pycharm_venv.Lib.encodings.ptcp154",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.ptcp154",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.ptcp154",
        "description": "pycharm_venv.Lib.encodings.ptcp154",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='ptcp154',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.ptcp154",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.ptcp154",
        "description": "pycharm_venv.Lib.encodings.ptcp154",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='ptcp154',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.ptcp154",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.ptcp154",
        "description": "pycharm_venv.Lib.encodings.ptcp154",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='ptcp154',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.ptcp154",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.ptcp154",
        "description": "pycharm_venv.Lib.encodings.ptcp154",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.ptcp154",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        res = punycode_encode(input)\n        return res, len(input)\n    def decode(self, input, errors='strict'):\n        if errors not in ('strict', 'replace', 'ignore'):\n            raise UnicodeError(f\"Unsupported error handling: {errors}\")\n        res = punycode_decode(input, errors)\n        return res, len(input)\nclass IncrementalEncoder(codecs.IncrementalEncoder):",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return punycode_encode(input)\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        if self.errors not in ('strict', 'replace', 'ignore'):\n            raise UnicodeError(f\"Unsupported error handling: {self.errors}\")\n        return punycode_decode(input, self.errors)\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        if self.errors not in ('strict', 'replace', 'ignore'):\n            raise UnicodeError(f\"Unsupported error handling: {self.errors}\")\n        return punycode_decode(input, self.errors)\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='punycode',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='punycode',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "segregate",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "def segregate(str):\n    \"\"\"3.1 Basic code point segregation\"\"\"\n    base = bytearray()\n    extended = set()\n    for c in str:\n        if ord(c) < 128:\n            base.append(ord(c))\n        else:\n            extended.add(c)\n    extended = sorted(extended)",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "selective_len",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "def selective_len(str, max):\n    \"\"\"Return the length of str, considering only characters below max.\"\"\"\n    res = 0\n    for c in str:\n        if ord(c) < max:\n            res += 1\n    return res\ndef selective_find(str, char, index, pos):\n    \"\"\"Return a pair (index, pos), indicating the next occurrence of\n    char in str. index is the position of the character considering",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "selective_find",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "def selective_find(str, char, index, pos):\n    \"\"\"Return a pair (index, pos), indicating the next occurrence of\n    char in str. index is the position of the character considering\n    only ordinals up to and including char, and pos is the position in\n    the full string. index/pos is the starting position in the full\n    string.\"\"\"\n    l = len(str)\n    while 1:\n        pos += 1\n        if pos == l:",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "insertion_unsort",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "def insertion_unsort(str, extended):\n    \"\"\"3.2 Insertion unsort coding\"\"\"\n    oldchar = 0x80\n    result = []\n    oldindex = -1\n    for c in extended:\n        index = pos = -1\n        char = ord(c)\n        curlen = selective_len(str, char)\n        delta = (curlen+1) * (char - oldchar)",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "def T(j, bias):\n    # Punycode parameters: tmin = 1, tmax = 26, base = 36\n    res = 36 * (j + 1) - bias\n    if res < 1: return 1\n    if res > 26: return 26\n    return res\ndigits = b\"abcdefghijklmnopqrstuvwxyz0123456789\"\ndef generate_generalized_integer(N, bias):\n    \"\"\"3.3 Generalized variable-length integers\"\"\"\n    result = bytearray()",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "generate_generalized_integer",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "def generate_generalized_integer(N, bias):\n    \"\"\"3.3 Generalized variable-length integers\"\"\"\n    result = bytearray()\n    j = 0\n    while 1:\n        t = T(j, bias)\n        if N < t:\n            result.append(digits[N])\n            return bytes(result)\n        result.append(digits[t + ((N - t) % (36 - t))])",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "adapt",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "def adapt(delta, first, numchars):\n    if first:\n        delta //= 700\n    else:\n        delta //= 2\n    delta += delta // numchars\n    # ((base - tmin) * tmax) // 2 == 455\n    divisions = 0\n    while delta > 455:\n        delta = delta // 35 # base - tmin",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "generate_integers",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "def generate_integers(baselen, deltas):\n    \"\"\"3.4 Bias adaptation\"\"\"\n    # Punycode parameters: initial bias = 72, damp = 700, skew = 38\n    result = bytearray()\n    bias = 72\n    for points, delta in enumerate(deltas):\n        s = generate_generalized_integer(delta, bias)\n        result.extend(s)\n        bias = adapt(delta, points==0, baselen+points+1)\n    return bytes(result)",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "punycode_encode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "def punycode_encode(text):\n    base, extended = segregate(text)\n    deltas = insertion_unsort(text, extended)\n    extended = generate_integers(len(base), deltas)\n    if base:\n        return base + b\"-\" + extended\n    return extended\n##################### Decoding #####################################\ndef decode_generalized_number(extended, extpos, bias, errors):\n    \"\"\"3.3 Generalized variable-length integers\"\"\"",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "decode_generalized_number",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "def decode_generalized_number(extended, extpos, bias, errors):\n    \"\"\"3.3 Generalized variable-length integers\"\"\"\n    result = 0\n    w = 1\n    j = 0\n    while 1:\n        try:\n            char = extended[extpos]\n        except IndexError:\n            if errors == \"strict\":",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "insertion_sort",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "def insertion_sort(base, extended, errors):\n    \"\"\"3.2 Insertion sort coding\"\"\"\n    # This function raises UnicodeDecodeError with position in the extended.\n    # Caller should add the offset.\n    char = 0x80\n    pos = -1\n    bias = 72\n    extpos = 0\n    while extpos < len(extended):\n        newpos, delta = decode_generalized_number(extended, extpos,",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "punycode_decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "def punycode_decode(text, errors):\n    if isinstance(text, str):\n        text = text.encode(\"ascii\")\n    if isinstance(text, memoryview):\n        text = bytes(text)\n    pos = text.rfind(b\"-\")\n    if pos == -1:\n        base = \"\"\n        extended = text.upper()\n    else:",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='punycode',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,\n        streamreader=StreamReader,\n    )",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "digits",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.punycode",
        "description": "pycharm_venv.Lib.encodings.punycode",
        "peekOfCode": "digits = b\"abcdefghijklmnopqrstuvwxyz0123456789\"\ndef generate_generalized_integer(N, bias):\n    \"\"\"3.3 Generalized variable-length integers\"\"\"\n    result = bytearray()\n    j = 0\n    while 1:\n        t = T(j, bias)\n        if N < t:\n            result.append(digits[N])\n            return bytes(result)",
        "detail": "pycharm_venv.Lib.encodings.punycode",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.quopri_codec",
        "description": "pycharm_venv.Lib.encodings.quopri_codec",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        return quopri_encode(input, errors)\n    def decode(self, input, errors='strict'):\n        return quopri_decode(input, errors)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return quopri_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.quopri_codec",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.quopri_codec",
        "description": "pycharm_venv.Lib.encodings.quopri_codec",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return quopri_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return quopri_decode(input, self.errors)[0]\nclass StreamWriter(Codec, codecs.StreamWriter):\n    charbuffertype = bytes\nclass StreamReader(Codec, codecs.StreamReader):\n    charbuffertype = bytes",
        "detail": "pycharm_venv.Lib.encodings.quopri_codec",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.quopri_codec",
        "description": "pycharm_venv.Lib.encodings.quopri_codec",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return quopri_decode(input, self.errors)[0]\nclass StreamWriter(Codec, codecs.StreamWriter):\n    charbuffertype = bytes\nclass StreamReader(Codec, codecs.StreamReader):\n    charbuffertype = bytes\n# encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.quopri_codec",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.quopri_codec",
        "description": "pycharm_venv.Lib.encodings.quopri_codec",
        "peekOfCode": "class StreamWriter(Codec, codecs.StreamWriter):\n    charbuffertype = bytes\nclass StreamReader(Codec, codecs.StreamReader):\n    charbuffertype = bytes\n# encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='quopri',\n        encode=quopri_encode,\n        decode=quopri_decode,",
        "detail": "pycharm_venv.Lib.encodings.quopri_codec",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.quopri_codec",
        "description": "pycharm_venv.Lib.encodings.quopri_codec",
        "peekOfCode": "class StreamReader(Codec, codecs.StreamReader):\n    charbuffertype = bytes\n# encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='quopri',\n        encode=quopri_encode,\n        decode=quopri_decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.quopri_codec",
        "documentation": {}
    },
    {
        "label": "quopri_encode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.quopri_codec",
        "description": "pycharm_venv.Lib.encodings.quopri_codec",
        "peekOfCode": "def quopri_encode(input, errors='strict'):\n    assert errors == 'strict'\n    f = BytesIO(input)\n    g = BytesIO()\n    quopri.encode(f, g, quotetabs=True)\n    return (g.getvalue(), len(input))\ndef quopri_decode(input, errors='strict'):\n    assert errors == 'strict'\n    f = BytesIO(input)\n    g = BytesIO()",
        "detail": "pycharm_venv.Lib.encodings.quopri_codec",
        "documentation": {}
    },
    {
        "label": "quopri_decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.quopri_codec",
        "description": "pycharm_venv.Lib.encodings.quopri_codec",
        "peekOfCode": "def quopri_decode(input, errors='strict'):\n    assert errors == 'strict'\n    f = BytesIO(input)\n    g = BytesIO()\n    quopri.decode(f, g)\n    return (g.getvalue(), len(input))\nclass Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        return quopri_encode(input, errors)\n    def decode(self, input, errors='strict'):",
        "detail": "pycharm_venv.Lib.encodings.quopri_codec",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.quopri_codec",
        "description": "pycharm_venv.Lib.encodings.quopri_codec",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='quopri',\n        encode=quopri_encode,\n        decode=quopri_decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,\n        streamreader=StreamReader,\n        _is_text_encoding=False,",
        "detail": "pycharm_venv.Lib.encodings.quopri_codec",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.raw_unicode_escape",
        "description": "pycharm_venv.Lib.encodings.raw_unicode_escape",
        "peekOfCode": "class Codec(codecs.Codec):\n    # Note: Binding these as C functions will result in the class not\n    # converting them to methods. This is intended.\n    encode = codecs.raw_unicode_escape_encode\n    decode = codecs.raw_unicode_escape_decode\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.raw_unicode_escape_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    def _buffer_decode(self, input, errors, final):",
        "detail": "pycharm_venv.Lib.encodings.raw_unicode_escape",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.raw_unicode_escape",
        "description": "pycharm_venv.Lib.encodings.raw_unicode_escape",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.raw_unicode_escape_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    def _buffer_decode(self, input, errors, final):\n        return codecs.raw_unicode_escape_decode(input, errors, final)\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    def decode(self, input, errors='strict'):",
        "detail": "pycharm_venv.Lib.encodings.raw_unicode_escape",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.raw_unicode_escape",
        "description": "pycharm_venv.Lib.encodings.raw_unicode_escape",
        "peekOfCode": "class IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    def _buffer_decode(self, input, errors, final):\n        return codecs.raw_unicode_escape_decode(input, errors, final)\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    def decode(self, input, errors='strict'):\n        return codecs.raw_unicode_escape_decode(input, errors, False)\n### encodings module API\ndef getregentry():",
        "detail": "pycharm_venv.Lib.encodings.raw_unicode_escape",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.raw_unicode_escape",
        "description": "pycharm_venv.Lib.encodings.raw_unicode_escape",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    def decode(self, input, errors='strict'):\n        return codecs.raw_unicode_escape_decode(input, errors, False)\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='raw-unicode-escape',\n        encode=Codec.encode,",
        "detail": "pycharm_venv.Lib.encodings.raw_unicode_escape",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.raw_unicode_escape",
        "description": "pycharm_venv.Lib.encodings.raw_unicode_escape",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    def decode(self, input, errors='strict'):\n        return codecs.raw_unicode_escape_decode(input, errors, False)\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='raw-unicode-escape',\n        encode=Codec.encode,\n        decode=Codec.decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.raw_unicode_escape",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.raw_unicode_escape",
        "description": "pycharm_venv.Lib.encodings.raw_unicode_escape",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='raw-unicode-escape',\n        encode=Codec.encode,\n        decode=Codec.decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,\n        streamreader=StreamReader,\n    )",
        "detail": "pycharm_venv.Lib.encodings.raw_unicode_escape",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.rot_13",
        "description": "pycharm_venv.Lib.encodings.rot_13",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        return (str.translate(input, rot13_map), len(input))\n    def decode(self, input, errors='strict'):\n        return (str.translate(input, rot13_map), len(input))\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return str.translate(input, rot13_map)\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.rot_13",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.rot_13",
        "description": "pycharm_venv.Lib.encodings.rot_13",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return str.translate(input, rot13_map)\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return str.translate(input, rot13_map)\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.rot_13",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.rot_13",
        "description": "pycharm_venv.Lib.encodings.rot_13",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return str.translate(input, rot13_map)\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.rot_13",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.rot_13",
        "description": "pycharm_venv.Lib.encodings.rot_13",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='rot-13',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.rot_13",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.rot_13",
        "description": "pycharm_venv.Lib.encodings.rot_13",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='rot-13',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.rot_13",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.rot_13",
        "description": "pycharm_venv.Lib.encodings.rot_13",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='rot-13',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,\n        streamreader=StreamReader,\n        _is_text_encoding=False,",
        "detail": "pycharm_venv.Lib.encodings.rot_13",
        "documentation": {}
    },
    {
        "label": "rot13",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.rot_13",
        "description": "pycharm_venv.Lib.encodings.rot_13",
        "peekOfCode": "def rot13(infile, outfile):\n    outfile.write(codecs.encode(infile.read(), 'rot-13'))\nif __name__ == '__main__':\n    import sys\n    rot13(sys.stdin, sys.stdout)",
        "detail": "pycharm_venv.Lib.encodings.rot_13",
        "documentation": {}
    },
    {
        "label": "rot13_map",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.rot_13",
        "description": "pycharm_venv.Lib.encodings.rot_13",
        "peekOfCode": "rot13_map = codecs.make_identity_dict(range(256))\nrot13_map.update({\n   0x0041: 0x004e,\n   0x0042: 0x004f,\n   0x0043: 0x0050,\n   0x0044: 0x0051,\n   0x0045: 0x0052,\n   0x0046: 0x0053,\n   0x0047: 0x0054,\n   0x0048: 0x0055,",
        "detail": "pycharm_venv.Lib.encodings.rot_13",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.shift_jis",
        "description": "pycharm_venv.Lib.encodings.shift_jis",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.shift_jis",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.shift_jis",
        "description": "pycharm_venv.Lib.encodings.shift_jis",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.shift_jis",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.shift_jis",
        "description": "pycharm_venv.Lib.encodings.shift_jis",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='shift_jis',",
        "detail": "pycharm_venv.Lib.encodings.shift_jis",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.shift_jis",
        "description": "pycharm_venv.Lib.encodings.shift_jis",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='shift_jis',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.shift_jis",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.shift_jis",
        "description": "pycharm_venv.Lib.encodings.shift_jis",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='shift_jis',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.shift_jis",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.shift_jis",
        "description": "pycharm_venv.Lib.encodings.shift_jis",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='shift_jis',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.shift_jis",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.shift_jis",
        "description": "pycharm_venv.Lib.encodings.shift_jis",
        "peekOfCode": "codec = _codecs_jp.getcodec('shift_jis')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.shift_jis",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "description": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "description": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "description": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='shift_jisx0213',",
        "detail": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "description": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='shift_jisx0213',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "description": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='shift_jisx0213',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "description": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='shift_jisx0213',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "description": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "peekOfCode": "codec = _codecs_jp.getcodec('shift_jisx0213')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.shift_jisx0213",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "description": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "peekOfCode": "class Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "description": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "peekOfCode": "class IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "description": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "peekOfCode": "class IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec\nclass StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='shift_jis_2004',",
        "detail": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "description": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "peekOfCode": "class StreamReader(Codec, mbc.MultibyteStreamReader, codecs.StreamReader):\n    codec = codec\nclass StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='shift_jis_2004',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "description": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "peekOfCode": "class StreamWriter(Codec, mbc.MultibyteStreamWriter, codecs.StreamWriter):\n    codec = codec\ndef getregentry():\n    return codecs.CodecInfo(\n        name='shift_jis_2004',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,",
        "detail": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "description": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='shift_jis_2004',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "documentation": {}
    },
    {
        "label": "codec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "description": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "peekOfCode": "codec = _codecs_jp.getcodec('shift_jis_2004')\nclass Codec(codecs.Codec):\n    encode = codec.encode\n    decode = codec.decode\nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\n                         codecs.IncrementalEncoder):\n    codec = codec\nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\n                         codecs.IncrementalDecoder):\n    codec = codec",
        "detail": "pycharm_venv.Lib.encodings.shift_jis_2004",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.tis_620",
        "description": "pycharm_venv.Lib.encodings.tis_620",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.tis_620",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.tis_620",
        "description": "pycharm_venv.Lib.encodings.tis_620",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.tis_620",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.tis_620",
        "description": "pycharm_venv.Lib.encodings.tis_620",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.tis_620",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.tis_620",
        "description": "pycharm_venv.Lib.encodings.tis_620",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='tis-620',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.tis_620",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.tis_620",
        "description": "pycharm_venv.Lib.encodings.tis_620",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='tis-620',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.tis_620",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.tis_620",
        "description": "pycharm_venv.Lib.encodings.tis_620",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='tis-620',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.tis_620",
        "documentation": {}
    },
    {
        "label": "decoding_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.tis_620",
        "description": "pycharm_venv.Lib.encodings.tis_620",
        "peekOfCode": "decoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE",
        "detail": "pycharm_venv.Lib.encodings.tis_620",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.undefined",
        "description": "pycharm_venv.Lib.encodings.undefined",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self,input,errors='strict'):\n        raise UnicodeError(\"undefined encoding\")\n    def decode(self,input,errors='strict'):\n        raise UnicodeError(\"undefined encoding\")\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        raise UnicodeError(\"undefined encoding\")\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.undefined",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.undefined",
        "description": "pycharm_venv.Lib.encodings.undefined",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        raise UnicodeError(\"undefined encoding\")\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        raise UnicodeError(\"undefined encoding\")\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass",
        "detail": "pycharm_venv.Lib.encodings.undefined",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.undefined",
        "description": "pycharm_venv.Lib.encodings.undefined",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        raise UnicodeError(\"undefined encoding\")\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.undefined",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.undefined",
        "description": "pycharm_venv.Lib.encodings.undefined",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='undefined',\n        encode=Codec().encode,\n        decode=Codec().decode,",
        "detail": "pycharm_venv.Lib.encodings.undefined",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.undefined",
        "description": "pycharm_venv.Lib.encodings.undefined",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    pass\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='undefined',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.undefined",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.undefined",
        "description": "pycharm_venv.Lib.encodings.undefined",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='undefined',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,\n        streamreader=StreamReader,\n    )",
        "detail": "pycharm_venv.Lib.encodings.undefined",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.unicode_escape",
        "description": "pycharm_venv.Lib.encodings.unicode_escape",
        "peekOfCode": "class Codec(codecs.Codec):\n    # Note: Binding these as C functions will result in the class not\n    # converting them to methods. This is intended.\n    encode = codecs.unicode_escape_encode\n    decode = codecs.unicode_escape_decode\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.unicode_escape_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    def _buffer_decode(self, input, errors, final):",
        "detail": "pycharm_venv.Lib.encodings.unicode_escape",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.unicode_escape",
        "description": "pycharm_venv.Lib.encodings.unicode_escape",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.unicode_escape_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    def _buffer_decode(self, input, errors, final):\n        return codecs.unicode_escape_decode(input, errors, final)\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    def decode(self, input, errors='strict'):",
        "detail": "pycharm_venv.Lib.encodings.unicode_escape",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.unicode_escape",
        "description": "pycharm_venv.Lib.encodings.unicode_escape",
        "peekOfCode": "class IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    def _buffer_decode(self, input, errors, final):\n        return codecs.unicode_escape_decode(input, errors, final)\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    def decode(self, input, errors='strict'):\n        return codecs.unicode_escape_decode(input, errors, False)\n### encodings module API\ndef getregentry():",
        "detail": "pycharm_venv.Lib.encodings.unicode_escape",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.unicode_escape",
        "description": "pycharm_venv.Lib.encodings.unicode_escape",
        "peekOfCode": "class StreamWriter(Codec,codecs.StreamWriter):\n    pass\nclass StreamReader(Codec,codecs.StreamReader):\n    def decode(self, input, errors='strict'):\n        return codecs.unicode_escape_decode(input, errors, False)\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='unicode-escape',\n        encode=Codec.encode,",
        "detail": "pycharm_venv.Lib.encodings.unicode_escape",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.unicode_escape",
        "description": "pycharm_venv.Lib.encodings.unicode_escape",
        "peekOfCode": "class StreamReader(Codec,codecs.StreamReader):\n    def decode(self, input, errors='strict'):\n        return codecs.unicode_escape_decode(input, errors, False)\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='unicode-escape',\n        encode=Codec.encode,\n        decode=Codec.decode,\n        incrementalencoder=IncrementalEncoder,",
        "detail": "pycharm_venv.Lib.encodings.unicode_escape",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.unicode_escape",
        "description": "pycharm_venv.Lib.encodings.unicode_escape",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='unicode-escape',\n        encode=Codec.encode,\n        decode=Codec.decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,\n        streamreader=StreamReader,\n    )",
        "detail": "pycharm_venv.Lib.encodings.unicode_escape",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_16",
        "description": "pycharm_venv.Lib.encodings.utf_16",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def __init__(self, errors='strict'):\n        codecs.IncrementalEncoder.__init__(self, errors)\n        self.encoder = None\n    def encode(self, input, final=False):\n        if self.encoder is None:\n            result = codecs.utf_16_encode(input, self.errors)[0]\n            if sys.byteorder == 'little':\n                self.encoder = codecs.utf_16_le_encode\n            else:",
        "detail": "pycharm_venv.Lib.encodings.utf_16",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_16",
        "description": "pycharm_venv.Lib.encodings.utf_16",
        "peekOfCode": "class IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    def __init__(self, errors='strict'):\n        codecs.BufferedIncrementalDecoder.__init__(self, errors)\n        self.decoder = None\n    def _buffer_decode(self, input, errors, final):\n        if self.decoder is None:\n            (output, consumed, byteorder) = \\\n                codecs.utf_16_ex_decode(input, errors, 0, final)\n            if byteorder == -1:\n                self.decoder = codecs.utf_16_le_decode",
        "detail": "pycharm_venv.Lib.encodings.utf_16",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_16",
        "description": "pycharm_venv.Lib.encodings.utf_16",
        "peekOfCode": "class StreamWriter(codecs.StreamWriter):\n    def __init__(self, stream, errors='strict'):\n        codecs.StreamWriter.__init__(self, stream, errors)\n        self.encoder = None\n    def reset(self):\n        codecs.StreamWriter.reset(self)\n        self.encoder = None\n    def encode(self, input, errors='strict'):\n        if self.encoder is None:\n            result = codecs.utf_16_encode(input, errors)",
        "detail": "pycharm_venv.Lib.encodings.utf_16",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_16",
        "description": "pycharm_venv.Lib.encodings.utf_16",
        "peekOfCode": "class StreamReader(codecs.StreamReader):\n    def reset(self):\n        codecs.StreamReader.reset(self)\n        try:\n            del self.decode\n        except AttributeError:\n            pass\n    def decode(self, input, errors='strict'):\n        (object, consumed, byteorder) = \\\n            codecs.utf_16_ex_decode(input, errors, 0, False)",
        "detail": "pycharm_venv.Lib.encodings.utf_16",
        "documentation": {}
    },
    {
        "label": "decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_16",
        "description": "pycharm_venv.Lib.encodings.utf_16",
        "peekOfCode": "def decode(input, errors='strict'):\n    return codecs.utf_16_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def __init__(self, errors='strict'):\n        codecs.IncrementalEncoder.__init__(self, errors)\n        self.encoder = None\n    def encode(self, input, final=False):\n        if self.encoder is None:\n            result = codecs.utf_16_encode(input, self.errors)[0]\n            if sys.byteorder == 'little':",
        "detail": "pycharm_venv.Lib.encodings.utf_16",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_16",
        "description": "pycharm_venv.Lib.encodings.utf_16",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='utf-16',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.utf_16",
        "documentation": {}
    },
    {
        "label": "encode",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.utf_16",
        "description": "pycharm_venv.Lib.encodings.utf_16",
        "peekOfCode": "encode = codecs.utf_16_encode\ndef decode(input, errors='strict'):\n    return codecs.utf_16_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def __init__(self, errors='strict'):\n        codecs.IncrementalEncoder.__init__(self, errors)\n        self.encoder = None\n    def encode(self, input, final=False):\n        if self.encoder is None:\n            result = codecs.utf_16_encode(input, self.errors)[0]",
        "detail": "pycharm_venv.Lib.encodings.utf_16",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_16_be",
        "description": "pycharm_venv.Lib.encodings.utf_16_be",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.utf_16_be_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_16_be_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_16_be_encode\nclass StreamReader(codecs.StreamReader):\n    decode = codecs.utf_16_be_decode\n### encodings module API",
        "detail": "pycharm_venv.Lib.encodings.utf_16_be",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_16_be",
        "description": "pycharm_venv.Lib.encodings.utf_16_be",
        "peekOfCode": "class IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_16_be_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_16_be_encode\nclass StreamReader(codecs.StreamReader):\n    decode = codecs.utf_16_be_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='utf-16-be',",
        "detail": "pycharm_venv.Lib.encodings.utf_16_be",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_16_be",
        "description": "pycharm_venv.Lib.encodings.utf_16_be",
        "peekOfCode": "class StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_16_be_encode\nclass StreamReader(codecs.StreamReader):\n    decode = codecs.utf_16_be_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='utf-16-be',\n        encode=encode,\n        decode=decode,",
        "detail": "pycharm_venv.Lib.encodings.utf_16_be",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_16_be",
        "description": "pycharm_venv.Lib.encodings.utf_16_be",
        "peekOfCode": "class StreamReader(codecs.StreamReader):\n    decode = codecs.utf_16_be_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='utf-16-be',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.utf_16_be",
        "documentation": {}
    },
    {
        "label": "decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_16_be",
        "description": "pycharm_venv.Lib.encodings.utf_16_be",
        "peekOfCode": "def decode(input, errors='strict'):\n    return codecs.utf_16_be_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.utf_16_be_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_16_be_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_16_be_encode\nclass StreamReader(codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.utf_16_be",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_16_be",
        "description": "pycharm_venv.Lib.encodings.utf_16_be",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='utf-16-be',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.utf_16_be",
        "documentation": {}
    },
    {
        "label": "encode",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.utf_16_be",
        "description": "pycharm_venv.Lib.encodings.utf_16_be",
        "peekOfCode": "encode = codecs.utf_16_be_encode\ndef decode(input, errors='strict'):\n    return codecs.utf_16_be_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.utf_16_be_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_16_be_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_16_be_encode",
        "detail": "pycharm_venv.Lib.encodings.utf_16_be",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_16_le",
        "description": "pycharm_venv.Lib.encodings.utf_16_le",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.utf_16_le_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_16_le_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_16_le_encode\nclass StreamReader(codecs.StreamReader):\n    decode = codecs.utf_16_le_decode\n### encodings module API",
        "detail": "pycharm_venv.Lib.encodings.utf_16_le",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_16_le",
        "description": "pycharm_venv.Lib.encodings.utf_16_le",
        "peekOfCode": "class IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_16_le_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_16_le_encode\nclass StreamReader(codecs.StreamReader):\n    decode = codecs.utf_16_le_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='utf-16-le',",
        "detail": "pycharm_venv.Lib.encodings.utf_16_le",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_16_le",
        "description": "pycharm_venv.Lib.encodings.utf_16_le",
        "peekOfCode": "class StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_16_le_encode\nclass StreamReader(codecs.StreamReader):\n    decode = codecs.utf_16_le_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='utf-16-le',\n        encode=encode,\n        decode=decode,",
        "detail": "pycharm_venv.Lib.encodings.utf_16_le",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_16_le",
        "description": "pycharm_venv.Lib.encodings.utf_16_le",
        "peekOfCode": "class StreamReader(codecs.StreamReader):\n    decode = codecs.utf_16_le_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='utf-16-le',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.utf_16_le",
        "documentation": {}
    },
    {
        "label": "decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_16_le",
        "description": "pycharm_venv.Lib.encodings.utf_16_le",
        "peekOfCode": "def decode(input, errors='strict'):\n    return codecs.utf_16_le_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.utf_16_le_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_16_le_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_16_le_encode\nclass StreamReader(codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.utf_16_le",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_16_le",
        "description": "pycharm_venv.Lib.encodings.utf_16_le",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='utf-16-le',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.utf_16_le",
        "documentation": {}
    },
    {
        "label": "encode",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.utf_16_le",
        "description": "pycharm_venv.Lib.encodings.utf_16_le",
        "peekOfCode": "encode = codecs.utf_16_le_encode\ndef decode(input, errors='strict'):\n    return codecs.utf_16_le_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.utf_16_le_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_16_le_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_16_le_encode",
        "detail": "pycharm_venv.Lib.encodings.utf_16_le",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_32",
        "description": "pycharm_venv.Lib.encodings.utf_32",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def __init__(self, errors='strict'):\n        codecs.IncrementalEncoder.__init__(self, errors)\n        self.encoder = None\n    def encode(self, input, final=False):\n        if self.encoder is None:\n            result = codecs.utf_32_encode(input, self.errors)[0]\n            if sys.byteorder == 'little':\n                self.encoder = codecs.utf_32_le_encode\n            else:",
        "detail": "pycharm_venv.Lib.encodings.utf_32",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_32",
        "description": "pycharm_venv.Lib.encodings.utf_32",
        "peekOfCode": "class IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    def __init__(self, errors='strict'):\n        codecs.BufferedIncrementalDecoder.__init__(self, errors)\n        self.decoder = None\n    def _buffer_decode(self, input, errors, final):\n        if self.decoder is None:\n            (output, consumed, byteorder) = \\\n                codecs.utf_32_ex_decode(input, errors, 0, final)\n            if byteorder == -1:\n                self.decoder = codecs.utf_32_le_decode",
        "detail": "pycharm_venv.Lib.encodings.utf_32",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_32",
        "description": "pycharm_venv.Lib.encodings.utf_32",
        "peekOfCode": "class StreamWriter(codecs.StreamWriter):\n    def __init__(self, stream, errors='strict'):\n        self.encoder = None\n        codecs.StreamWriter.__init__(self, stream, errors)\n    def reset(self):\n        codecs.StreamWriter.reset(self)\n        self.encoder = None\n    def encode(self, input, errors='strict'):\n        if self.encoder is None:\n            result = codecs.utf_32_encode(input, errors)",
        "detail": "pycharm_venv.Lib.encodings.utf_32",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_32",
        "description": "pycharm_venv.Lib.encodings.utf_32",
        "peekOfCode": "class StreamReader(codecs.StreamReader):\n    def reset(self):\n        codecs.StreamReader.reset(self)\n        try:\n            del self.decode\n        except AttributeError:\n            pass\n    def decode(self, input, errors='strict'):\n        (object, consumed, byteorder) = \\\n            codecs.utf_32_ex_decode(input, errors, 0, False)",
        "detail": "pycharm_venv.Lib.encodings.utf_32",
        "documentation": {}
    },
    {
        "label": "decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_32",
        "description": "pycharm_venv.Lib.encodings.utf_32",
        "peekOfCode": "def decode(input, errors='strict'):\n    return codecs.utf_32_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def __init__(self, errors='strict'):\n        codecs.IncrementalEncoder.__init__(self, errors)\n        self.encoder = None\n    def encode(self, input, final=False):\n        if self.encoder is None:\n            result = codecs.utf_32_encode(input, self.errors)[0]\n            if sys.byteorder == 'little':",
        "detail": "pycharm_venv.Lib.encodings.utf_32",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_32",
        "description": "pycharm_venv.Lib.encodings.utf_32",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='utf-32',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.utf_32",
        "documentation": {}
    },
    {
        "label": "encode",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.utf_32",
        "description": "pycharm_venv.Lib.encodings.utf_32",
        "peekOfCode": "encode = codecs.utf_32_encode\ndef decode(input, errors='strict'):\n    return codecs.utf_32_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def __init__(self, errors='strict'):\n        codecs.IncrementalEncoder.__init__(self, errors)\n        self.encoder = None\n    def encode(self, input, final=False):\n        if self.encoder is None:\n            result = codecs.utf_32_encode(input, self.errors)[0]",
        "detail": "pycharm_venv.Lib.encodings.utf_32",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_32_be",
        "description": "pycharm_venv.Lib.encodings.utf_32_be",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.utf_32_be_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_32_be_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_32_be_encode\nclass StreamReader(codecs.StreamReader):\n    decode = codecs.utf_32_be_decode\n### encodings module API",
        "detail": "pycharm_venv.Lib.encodings.utf_32_be",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_32_be",
        "description": "pycharm_venv.Lib.encodings.utf_32_be",
        "peekOfCode": "class IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_32_be_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_32_be_encode\nclass StreamReader(codecs.StreamReader):\n    decode = codecs.utf_32_be_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='utf-32-be',",
        "detail": "pycharm_venv.Lib.encodings.utf_32_be",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_32_be",
        "description": "pycharm_venv.Lib.encodings.utf_32_be",
        "peekOfCode": "class StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_32_be_encode\nclass StreamReader(codecs.StreamReader):\n    decode = codecs.utf_32_be_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='utf-32-be',\n        encode=encode,\n        decode=decode,",
        "detail": "pycharm_venv.Lib.encodings.utf_32_be",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_32_be",
        "description": "pycharm_venv.Lib.encodings.utf_32_be",
        "peekOfCode": "class StreamReader(codecs.StreamReader):\n    decode = codecs.utf_32_be_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='utf-32-be',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.utf_32_be",
        "documentation": {}
    },
    {
        "label": "decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_32_be",
        "description": "pycharm_venv.Lib.encodings.utf_32_be",
        "peekOfCode": "def decode(input, errors='strict'):\n    return codecs.utf_32_be_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.utf_32_be_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_32_be_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_32_be_encode\nclass StreamReader(codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.utf_32_be",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_32_be",
        "description": "pycharm_venv.Lib.encodings.utf_32_be",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='utf-32-be',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.utf_32_be",
        "documentation": {}
    },
    {
        "label": "encode",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.utf_32_be",
        "description": "pycharm_venv.Lib.encodings.utf_32_be",
        "peekOfCode": "encode = codecs.utf_32_be_encode\ndef decode(input, errors='strict'):\n    return codecs.utf_32_be_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.utf_32_be_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_32_be_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_32_be_encode",
        "detail": "pycharm_venv.Lib.encodings.utf_32_be",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_32_le",
        "description": "pycharm_venv.Lib.encodings.utf_32_le",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.utf_32_le_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_32_le_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_32_le_encode\nclass StreamReader(codecs.StreamReader):\n    decode = codecs.utf_32_le_decode\n### encodings module API",
        "detail": "pycharm_venv.Lib.encodings.utf_32_le",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_32_le",
        "description": "pycharm_venv.Lib.encodings.utf_32_le",
        "peekOfCode": "class IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_32_le_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_32_le_encode\nclass StreamReader(codecs.StreamReader):\n    decode = codecs.utf_32_le_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='utf-32-le',",
        "detail": "pycharm_venv.Lib.encodings.utf_32_le",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_32_le",
        "description": "pycharm_venv.Lib.encodings.utf_32_le",
        "peekOfCode": "class StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_32_le_encode\nclass StreamReader(codecs.StreamReader):\n    decode = codecs.utf_32_le_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='utf-32-le',\n        encode=encode,\n        decode=decode,",
        "detail": "pycharm_venv.Lib.encodings.utf_32_le",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_32_le",
        "description": "pycharm_venv.Lib.encodings.utf_32_le",
        "peekOfCode": "class StreamReader(codecs.StreamReader):\n    decode = codecs.utf_32_le_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='utf-32-le',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.utf_32_le",
        "documentation": {}
    },
    {
        "label": "decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_32_le",
        "description": "pycharm_venv.Lib.encodings.utf_32_le",
        "peekOfCode": "def decode(input, errors='strict'):\n    return codecs.utf_32_le_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.utf_32_le_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_32_le_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_32_le_encode\nclass StreamReader(codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.utf_32_le",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_32_le",
        "description": "pycharm_venv.Lib.encodings.utf_32_le",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='utf-32-le',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.utf_32_le",
        "documentation": {}
    },
    {
        "label": "encode",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.utf_32_le",
        "description": "pycharm_venv.Lib.encodings.utf_32_le",
        "peekOfCode": "encode = codecs.utf_32_le_encode\ndef decode(input, errors='strict'):\n    return codecs.utf_32_le_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.utf_32_le_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_32_le_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_32_le_encode",
        "detail": "pycharm_venv.Lib.encodings.utf_32_le",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_7",
        "description": "pycharm_venv.Lib.encodings.utf_7",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.utf_7_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_7_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_7_encode\nclass StreamReader(codecs.StreamReader):\n    decode = codecs.utf_7_decode\n### encodings module API",
        "detail": "pycharm_venv.Lib.encodings.utf_7",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_7",
        "description": "pycharm_venv.Lib.encodings.utf_7",
        "peekOfCode": "class IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_7_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_7_encode\nclass StreamReader(codecs.StreamReader):\n    decode = codecs.utf_7_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='utf-7',",
        "detail": "pycharm_venv.Lib.encodings.utf_7",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_7",
        "description": "pycharm_venv.Lib.encodings.utf_7",
        "peekOfCode": "class StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_7_encode\nclass StreamReader(codecs.StreamReader):\n    decode = codecs.utf_7_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='utf-7',\n        encode=encode,\n        decode=decode,",
        "detail": "pycharm_venv.Lib.encodings.utf_7",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_7",
        "description": "pycharm_venv.Lib.encodings.utf_7",
        "peekOfCode": "class StreamReader(codecs.StreamReader):\n    decode = codecs.utf_7_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='utf-7',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.utf_7",
        "documentation": {}
    },
    {
        "label": "decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_7",
        "description": "pycharm_venv.Lib.encodings.utf_7",
        "peekOfCode": "def decode(input, errors='strict'):\n    return codecs.utf_7_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.utf_7_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_7_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_7_encode\nclass StreamReader(codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.utf_7",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_7",
        "description": "pycharm_venv.Lib.encodings.utf_7",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='utf-7',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.utf_7",
        "documentation": {}
    },
    {
        "label": "encode",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.utf_7",
        "description": "pycharm_venv.Lib.encodings.utf_7",
        "peekOfCode": "encode = codecs.utf_7_encode\ndef decode(input, errors='strict'):\n    return codecs.utf_7_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.utf_7_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_7_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_7_encode",
        "detail": "pycharm_venv.Lib.encodings.utf_7",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_8",
        "description": "pycharm_venv.Lib.encodings.utf_8",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.utf_8_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_8_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_8_encode\nclass StreamReader(codecs.StreamReader):\n    decode = codecs.utf_8_decode\n### encodings module API",
        "detail": "pycharm_venv.Lib.encodings.utf_8",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_8",
        "description": "pycharm_venv.Lib.encodings.utf_8",
        "peekOfCode": "class IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_8_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_8_encode\nclass StreamReader(codecs.StreamReader):\n    decode = codecs.utf_8_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='utf-8',",
        "detail": "pycharm_venv.Lib.encodings.utf_8",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_8",
        "description": "pycharm_venv.Lib.encodings.utf_8",
        "peekOfCode": "class StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_8_encode\nclass StreamReader(codecs.StreamReader):\n    decode = codecs.utf_8_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='utf-8',\n        encode=encode,\n        decode=decode,",
        "detail": "pycharm_venv.Lib.encodings.utf_8",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_8",
        "description": "pycharm_venv.Lib.encodings.utf_8",
        "peekOfCode": "class StreamReader(codecs.StreamReader):\n    decode = codecs.utf_8_decode\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='utf-8',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.utf_8",
        "documentation": {}
    },
    {
        "label": "decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_8",
        "description": "pycharm_venv.Lib.encodings.utf_8",
        "peekOfCode": "def decode(input, errors='strict'):\n    return codecs.utf_8_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.utf_8_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_8_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_8_encode\nclass StreamReader(codecs.StreamReader):",
        "detail": "pycharm_venv.Lib.encodings.utf_8",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_8",
        "description": "pycharm_venv.Lib.encodings.utf_8",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='utf-8',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.utf_8",
        "documentation": {}
    },
    {
        "label": "encode",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.encodings.utf_8",
        "description": "pycharm_venv.Lib.encodings.utf_8",
        "peekOfCode": "encode = codecs.utf_8_encode\ndef decode(input, errors='strict'):\n    return codecs.utf_8_decode(input, errors, True)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.utf_8_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    _buffer_decode = codecs.utf_8_decode\nclass StreamWriter(codecs.StreamWriter):\n    encode = codecs.utf_8_encode",
        "detail": "pycharm_venv.Lib.encodings.utf_8",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_8_sig",
        "description": "pycharm_venv.Lib.encodings.utf_8_sig",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def __init__(self, errors='strict'):\n        codecs.IncrementalEncoder.__init__(self, errors)\n        self.first = 1\n    def encode(self, input, final=False):\n        if self.first:\n            self.first = 0\n            return codecs.BOM_UTF8 + \\\n                   codecs.utf_8_encode(input, self.errors)[0]\n        else:",
        "detail": "pycharm_venv.Lib.encodings.utf_8_sig",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_8_sig",
        "description": "pycharm_venv.Lib.encodings.utf_8_sig",
        "peekOfCode": "class IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    def __init__(self, errors='strict'):\n        codecs.BufferedIncrementalDecoder.__init__(self, errors)\n        self.first = 1\n    def _buffer_decode(self, input, errors, final):\n        if self.first:\n            if len(input) < 3:\n                if codecs.BOM_UTF8.startswith(input):\n                    # not enough data to decide if this really is a BOM\n                    # => try again on the next call",
        "detail": "pycharm_venv.Lib.encodings.utf_8_sig",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_8_sig",
        "description": "pycharm_venv.Lib.encodings.utf_8_sig",
        "peekOfCode": "class StreamWriter(codecs.StreamWriter):\n    def reset(self):\n        codecs.StreamWriter.reset(self)\n        try:\n            del self.encode\n        except AttributeError:\n            pass\n    def encode(self, input, errors='strict'):\n        self.encode = codecs.utf_8_encode\n        return encode(input, errors)",
        "detail": "pycharm_venv.Lib.encodings.utf_8_sig",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.utf_8_sig",
        "description": "pycharm_venv.Lib.encodings.utf_8_sig",
        "peekOfCode": "class StreamReader(codecs.StreamReader):\n    def reset(self):\n        codecs.StreamReader.reset(self)\n        try:\n            del self.decode\n        except AttributeError:\n            pass\n    def decode(self, input, errors='strict'):\n        if len(input) < 3:\n            if codecs.BOM_UTF8.startswith(input):",
        "detail": "pycharm_venv.Lib.encodings.utf_8_sig",
        "documentation": {}
    },
    {
        "label": "encode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_8_sig",
        "description": "pycharm_venv.Lib.encodings.utf_8_sig",
        "peekOfCode": "def encode(input, errors='strict'):\n    return (codecs.BOM_UTF8 + codecs.utf_8_encode(input, errors)[0],\n            len(input))\ndef decode(input, errors='strict'):\n    prefix = 0\n    if input[:3] == codecs.BOM_UTF8:\n        input = input[3:]\n        prefix = 3\n    (output, consumed) = codecs.utf_8_decode(input, errors, True)\n    return (output, consumed+prefix)",
        "detail": "pycharm_venv.Lib.encodings.utf_8_sig",
        "documentation": {}
    },
    {
        "label": "decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_8_sig",
        "description": "pycharm_venv.Lib.encodings.utf_8_sig",
        "peekOfCode": "def decode(input, errors='strict'):\n    prefix = 0\n    if input[:3] == codecs.BOM_UTF8:\n        input = input[3:]\n        prefix = 3\n    (output, consumed) = codecs.utf_8_decode(input, errors, True)\n    return (output, consumed+prefix)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def __init__(self, errors='strict'):\n        codecs.IncrementalEncoder.__init__(self, errors)",
        "detail": "pycharm_venv.Lib.encodings.utf_8_sig",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.utf_8_sig",
        "description": "pycharm_venv.Lib.encodings.utf_8_sig",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='utf-8-sig',\n        encode=encode,\n        decode=decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )",
        "detail": "pycharm_venv.Lib.encodings.utf_8_sig",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.uu_codec",
        "description": "pycharm_venv.Lib.encodings.uu_codec",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        return uu_encode(input, errors)\n    def decode(self, input, errors='strict'):\n        return uu_decode(input, errors)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return uu_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):",
        "detail": "pycharm_venv.Lib.encodings.uu_codec",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.uu_codec",
        "description": "pycharm_venv.Lib.encodings.uu_codec",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return uu_encode(input, self.errors)[0]\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return uu_decode(input, self.errors)[0]\nclass StreamWriter(Codec, codecs.StreamWriter):\n    charbuffertype = bytes\nclass StreamReader(Codec, codecs.StreamReader):\n    charbuffertype = bytes",
        "detail": "pycharm_venv.Lib.encodings.uu_codec",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.uu_codec",
        "description": "pycharm_venv.Lib.encodings.uu_codec",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return uu_decode(input, self.errors)[0]\nclass StreamWriter(Codec, codecs.StreamWriter):\n    charbuffertype = bytes\nclass StreamReader(Codec, codecs.StreamReader):\n    charbuffertype = bytes\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(",
        "detail": "pycharm_venv.Lib.encodings.uu_codec",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.uu_codec",
        "description": "pycharm_venv.Lib.encodings.uu_codec",
        "peekOfCode": "class StreamWriter(Codec, codecs.StreamWriter):\n    charbuffertype = bytes\nclass StreamReader(Codec, codecs.StreamReader):\n    charbuffertype = bytes\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='uu',\n        encode=uu_encode,\n        decode=uu_decode,",
        "detail": "pycharm_venv.Lib.encodings.uu_codec",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.uu_codec",
        "description": "pycharm_venv.Lib.encodings.uu_codec",
        "peekOfCode": "class StreamReader(Codec, codecs.StreamReader):\n    charbuffertype = bytes\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='uu',\n        encode=uu_encode,\n        decode=uu_decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.uu_codec",
        "documentation": {}
    },
    {
        "label": "uu_encode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.uu_codec",
        "description": "pycharm_venv.Lib.encodings.uu_codec",
        "peekOfCode": "def uu_encode(input, errors='strict', filename='<data>', mode=0o666):\n    assert errors == 'strict'\n    infile = BytesIO(input)\n    outfile = BytesIO()\n    read = infile.read\n    write = outfile.write\n    # Remove newline chars from filename\n    filename = filename.replace('\\n','\\\\n')\n    filename = filename.replace('\\r','\\\\r')\n    # Encode",
        "detail": "pycharm_venv.Lib.encodings.uu_codec",
        "documentation": {}
    },
    {
        "label": "uu_decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.uu_codec",
        "description": "pycharm_venv.Lib.encodings.uu_codec",
        "peekOfCode": "def uu_decode(input, errors='strict'):\n    assert errors == 'strict'\n    infile = BytesIO(input)\n    outfile = BytesIO()\n    readline = infile.readline\n    write = outfile.write\n    # Find start of encoded data\n    while 1:\n        s = readline()\n        if not s:",
        "detail": "pycharm_venv.Lib.encodings.uu_codec",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.uu_codec",
        "description": "pycharm_venv.Lib.encodings.uu_codec",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='uu',\n        encode=uu_encode,\n        decode=uu_decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n        _is_text_encoding=False,",
        "detail": "pycharm_venv.Lib.encodings.uu_codec",
        "documentation": {}
    },
    {
        "label": "Codec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.zlib_codec",
        "description": "pycharm_venv.Lib.encodings.zlib_codec",
        "peekOfCode": "class Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        return zlib_encode(input, errors)\n    def decode(self, input, errors='strict'):\n        return zlib_decode(input, errors)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def __init__(self, errors='strict'):\n        assert errors == 'strict'\n        self.errors = errors\n        self.compressobj = zlib.compressobj()",
        "detail": "pycharm_venv.Lib.encodings.zlib_codec",
        "documentation": {}
    },
    {
        "label": "IncrementalEncoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.zlib_codec",
        "description": "pycharm_venv.Lib.encodings.zlib_codec",
        "peekOfCode": "class IncrementalEncoder(codecs.IncrementalEncoder):\n    def __init__(self, errors='strict'):\n        assert errors == 'strict'\n        self.errors = errors\n        self.compressobj = zlib.compressobj()\n    def encode(self, input, final=False):\n        if final:\n            c = self.compressobj.compress(input)\n            return c + self.compressobj.flush()\n        else:",
        "detail": "pycharm_venv.Lib.encodings.zlib_codec",
        "documentation": {}
    },
    {
        "label": "IncrementalDecoder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.zlib_codec",
        "description": "pycharm_venv.Lib.encodings.zlib_codec",
        "peekOfCode": "class IncrementalDecoder(codecs.IncrementalDecoder):\n    def __init__(self, errors='strict'):\n        assert errors == 'strict'\n        self.errors = errors\n        self.decompressobj = zlib.decompressobj()\n    def decode(self, input, final=False):\n        if final:\n            c = self.decompressobj.decompress(input)\n            return c + self.decompressobj.flush()\n        else:",
        "detail": "pycharm_venv.Lib.encodings.zlib_codec",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.zlib_codec",
        "description": "pycharm_venv.Lib.encodings.zlib_codec",
        "peekOfCode": "class StreamWriter(Codec, codecs.StreamWriter):\n    charbuffertype = bytes\nclass StreamReader(Codec, codecs.StreamReader):\n    charbuffertype = bytes\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='zlib',\n        encode=zlib_encode,\n        decode=zlib_decode,",
        "detail": "pycharm_venv.Lib.encodings.zlib_codec",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.encodings.zlib_codec",
        "description": "pycharm_venv.Lib.encodings.zlib_codec",
        "peekOfCode": "class StreamReader(Codec, codecs.StreamReader):\n    charbuffertype = bytes\n### encodings module API\ndef getregentry():\n    return codecs.CodecInfo(\n        name='zlib',\n        encode=zlib_encode,\n        decode=zlib_decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,",
        "detail": "pycharm_venv.Lib.encodings.zlib_codec",
        "documentation": {}
    },
    {
        "label": "zlib_encode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.zlib_codec",
        "description": "pycharm_venv.Lib.encodings.zlib_codec",
        "peekOfCode": "def zlib_encode(input, errors='strict'):\n    assert errors == 'strict'\n    return (zlib.compress(input), len(input))\ndef zlib_decode(input, errors='strict'):\n    assert errors == 'strict'\n    return (zlib.decompress(input), len(input))\nclass Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        return zlib_encode(input, errors)\n    def decode(self, input, errors='strict'):",
        "detail": "pycharm_venv.Lib.encodings.zlib_codec",
        "documentation": {}
    },
    {
        "label": "zlib_decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.zlib_codec",
        "description": "pycharm_venv.Lib.encodings.zlib_codec",
        "peekOfCode": "def zlib_decode(input, errors='strict'):\n    assert errors == 'strict'\n    return (zlib.decompress(input), len(input))\nclass Codec(codecs.Codec):\n    def encode(self, input, errors='strict'):\n        return zlib_encode(input, errors)\n    def decode(self, input, errors='strict'):\n        return zlib_decode(input, errors)\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def __init__(self, errors='strict'):",
        "detail": "pycharm_venv.Lib.encodings.zlib_codec",
        "documentation": {}
    },
    {
        "label": "getregentry",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.encodings.zlib_codec",
        "description": "pycharm_venv.Lib.encodings.zlib_codec",
        "peekOfCode": "def getregentry():\n    return codecs.CodecInfo(\n        name='zlib',\n        encode=zlib_encode,\n        decode=zlib_decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n        _is_text_encoding=False,",
        "detail": "pycharm_venv.Lib.encodings.zlib_codec",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.metadata.diagnose",
        "description": "pycharm_venv.Lib.importlib.metadata.diagnose",
        "peekOfCode": "def inspect(path):\n    print(\"Inspecting\", path)\n    dists = list(Distribution.discover(path=[path]))\n    if not dists:\n        return\n    print(\"Found\", len(dists), \"packages:\", end=' ')\n    print(', '.join(dist.name for dist in dists))\ndef run():\n    for path in sys.path:\n        inspect(path)",
        "detail": "pycharm_venv.Lib.importlib.metadata.diagnose",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.metadata.diagnose",
        "description": "pycharm_venv.Lib.importlib.metadata.diagnose",
        "peekOfCode": "def run():\n    for path in sys.path:\n        inspect(path)\nif __name__ == '__main__':\n    run()",
        "detail": "pycharm_venv.Lib.importlib.metadata.diagnose",
        "documentation": {}
    },
    {
        "label": "Message",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.metadata._adapters",
        "description": "pycharm_venv.Lib.importlib.metadata._adapters",
        "peekOfCode": "class Message(email.message.Message):\n    multiple_use_keys = set(\n        map(\n            FoldedCase,\n            [\n                'Classifier',\n                'Obsoletes-Dist',\n                'Platform',\n                'Project-URL',\n                'Provides-Dist',",
        "detail": "pycharm_venv.Lib.importlib.metadata._adapters",
        "documentation": {}
    },
    {
        "label": "_warn",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib.metadata._adapters",
        "description": "pycharm_venv.Lib.importlib.metadata._adapters",
        "peekOfCode": "_warn = functools.partial(\n    warnings.warn,\n    \"Implicit None on return values is deprecated and will raise KeyErrors.\",\n    DeprecationWarning,\n    stacklevel=2,\n)\nclass Message(email.message.Message):\n    multiple_use_keys = set(\n        map(\n            FoldedCase,",
        "detail": "pycharm_venv.Lib.importlib.metadata._adapters",
        "documentation": {}
    },
    {
        "label": "FreezableDefaultDict",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.metadata._collections",
        "description": "pycharm_venv.Lib.importlib.metadata._collections",
        "peekOfCode": "class FreezableDefaultDict(collections.defaultdict):\n    \"\"\"\n    Often it is desirable to prevent the mutation of\n    a default dict after its initial construction, such\n    as to prevent mutation during iteration.\n    >>> dd = FreezableDefaultDict(list)\n    >>> dd[0].append('1')\n    >>> dd.freeze()\n    >>> dd[1]\n    []",
        "detail": "pycharm_venv.Lib.importlib.metadata._collections",
        "documentation": {}
    },
    {
        "label": "Pair",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.metadata._collections",
        "description": "pycharm_venv.Lib.importlib.metadata._collections",
        "peekOfCode": "class Pair(collections.namedtuple('Pair', 'name value')):\n    @classmethod\n    def parse(cls, text):\n        return cls(*map(str.strip, text.split(\"=\", 1)))",
        "detail": "pycharm_venv.Lib.importlib.metadata._collections",
        "documentation": {}
    },
    {
        "label": "method_cache",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.metadata._functools",
        "description": "pycharm_venv.Lib.importlib.metadata._functools",
        "peekOfCode": "def method_cache(method, cache_wrapper=None):\n    \"\"\"\n    Wrap lru_cache to support storing the cache data in the object instances.\n    Abstracts the common paradigm where the method explicitly saves an\n    underscore-prefixed protected property on first call and returns that\n    subsequently.\n    >>> class MyClass:\n    ...     calls = 0\n    ...\n    ...     @method_cache",
        "detail": "pycharm_venv.Lib.importlib.metadata._functools",
        "documentation": {}
    },
    {
        "label": "pass_none",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.metadata._functools",
        "description": "pycharm_venv.Lib.importlib.metadata._functools",
        "peekOfCode": "def pass_none(func):\n    \"\"\"\n    Wrap func so it's not called if its first param is None\n    >>> print_text = pass_none(print)\n    >>> print_text('text')\n    text\n    >>> print_text(None)\n    \"\"\"\n    @functools.wraps(func)\n    def wrapper(param, *args, **kwargs):",
        "detail": "pycharm_venv.Lib.importlib.metadata._functools",
        "documentation": {}
    },
    {
        "label": "unique_everseen",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.metadata._itertools",
        "description": "pycharm_venv.Lib.importlib.metadata._itertools",
        "peekOfCode": "def unique_everseen(iterable, key=None):\n    \"List unique elements, preserving order. Remember all elements ever seen.\"\n    # unique_everseen('AAAABBBCCDAABBB') --> A B C D\n    # unique_everseen('ABBCcAD', str.lower) --> A B C D\n    seen = set()\n    seen_add = seen.add\n    if key is None:\n        for element in filterfalse(seen.__contains__, iterable):\n            seen_add(element)\n            yield element",
        "detail": "pycharm_venv.Lib.importlib.metadata._itertools",
        "documentation": {}
    },
    {
        "label": "always_iterable",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.metadata._itertools",
        "description": "pycharm_venv.Lib.importlib.metadata._itertools",
        "peekOfCode": "def always_iterable(obj, base_type=(str, bytes)):\n    \"\"\"If *obj* is iterable, return an iterator over its items::\n        >>> obj = (1, 2, 3)\n        >>> list(always_iterable(obj))\n        [1, 2, 3]\n    If *obj* is not iterable, return a one-item iterable containing *obj*::\n        >>> obj = 1\n        >>> list(always_iterable(obj))\n        [1]\n    If *obj* is ``None``, return an empty iterable:",
        "detail": "pycharm_venv.Lib.importlib.metadata._itertools",
        "documentation": {}
    },
    {
        "label": "PackageMetadata",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.metadata._meta",
        "description": "pycharm_venv.Lib.importlib.metadata._meta",
        "peekOfCode": "class PackageMetadata(Protocol):\n    def __len__(self) -> int: ...  # pragma: no cover\n    def __contains__(self, item: str) -> bool: ...  # pragma: no cover\n    def __getitem__(self, key: str) -> str: ...  # pragma: no cover\n    def __iter__(self) -> Iterator[str]: ...  # pragma: no cover\n    @overload\n    def get(\n        self, name: str, failobj: None = None\n    ) -> Optional[str]: ...  # pragma: no cover\n    @overload",
        "detail": "pycharm_venv.Lib.importlib.metadata._meta",
        "documentation": {}
    },
    {
        "label": "SimplePath",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.metadata._meta",
        "description": "pycharm_venv.Lib.importlib.metadata._meta",
        "peekOfCode": "class SimplePath(Protocol):\n    \"\"\"\n    A minimal subset of pathlib.Path required by Distribution.\n    \"\"\"\n    def joinpath(\n        self, other: Union[str, os.PathLike[str]]\n    ) -> SimplePath: ...  # pragma: no cover\n    def __truediv__(\n        self, other: Union[str, os.PathLike[str]]\n    ) -> SimplePath: ...  # pragma: no cover",
        "detail": "pycharm_venv.Lib.importlib.metadata._meta",
        "documentation": {}
    },
    {
        "label": "_T",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib.metadata._meta",
        "description": "pycharm_venv.Lib.importlib.metadata._meta",
        "peekOfCode": "_T = TypeVar(\"_T\")\nclass PackageMetadata(Protocol):\n    def __len__(self) -> int: ...  # pragma: no cover\n    def __contains__(self, item: str) -> bool: ...  # pragma: no cover\n    def __getitem__(self, key: str) -> str: ...  # pragma: no cover\n    def __iter__(self) -> Iterator[str]: ...  # pragma: no cover\n    @overload\n    def get(\n        self, name: str, failobj: None = None\n    ) -> Optional[str]: ...  # pragma: no cover",
        "detail": "pycharm_venv.Lib.importlib.metadata._meta",
        "documentation": {}
    },
    {
        "label": "FoldedCase",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.metadata._text",
        "description": "pycharm_venv.Lib.importlib.metadata._text",
        "peekOfCode": "class FoldedCase(str):\n    \"\"\"\n    A case insensitive string class; behaves just like str\n    except compares equal when the only variation is case.\n    >>> s = FoldedCase('hello world')\n    >>> s == 'Hello World'\n    True\n    >>> 'Hello World' == s\n    True\n    >>> s != 'Hello World'",
        "detail": "pycharm_venv.Lib.importlib.metadata._text",
        "documentation": {}
    },
    {
        "label": "ResourceReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.resources.abc",
        "description": "pycharm_venv.Lib.importlib.resources.abc",
        "peekOfCode": "class ResourceReader(metaclass=abc.ABCMeta):\n    \"\"\"Abstract base class for loaders to provide resource reading support.\"\"\"\n    @abc.abstractmethod\n    def open_resource(self, resource: Text) -> BinaryIO:\n        \"\"\"Return an opened, file-like object for binary reading.\n        The 'resource' argument is expected to represent only a file name.\n        If the resource cannot be found, FileNotFoundError is raised.\n        \"\"\"\n        # This deliberately raises FileNotFoundError instead of\n        # NotImplementedError so that if this method is accidentally called,",
        "detail": "pycharm_venv.Lib.importlib.resources.abc",
        "documentation": {}
    },
    {
        "label": "TraversalError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.resources.abc",
        "description": "pycharm_venv.Lib.importlib.resources.abc",
        "peekOfCode": "class TraversalError(Exception):\n    pass\n@runtime_checkable\nclass Traversable(Protocol):\n    \"\"\"\n    An object with a subset of pathlib.Path methods suitable for\n    traversing directories and opening files.\n    Any exceptions that occur when accessing the backing resource\n    may propagate unaltered.\n    \"\"\"",
        "detail": "pycharm_venv.Lib.importlib.resources.abc",
        "documentation": {}
    },
    {
        "label": "Traversable",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.resources.abc",
        "description": "pycharm_venv.Lib.importlib.resources.abc",
        "peekOfCode": "class Traversable(Protocol):\n    \"\"\"\n    An object with a subset of pathlib.Path methods suitable for\n    traversing directories and opening files.\n    Any exceptions that occur when accessing the backing resource\n    may propagate unaltered.\n    \"\"\"\n    @abc.abstractmethod\n    def iterdir(self) -> Iterator[\"Traversable\"]:\n        \"\"\"",
        "detail": "pycharm_venv.Lib.importlib.resources.abc",
        "documentation": {}
    },
    {
        "label": "TraversableResources",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.resources.abc",
        "description": "pycharm_venv.Lib.importlib.resources.abc",
        "peekOfCode": "class TraversableResources(ResourceReader):\n    \"\"\"\n    The required interface for providing traversable\n    resources.\n    \"\"\"\n    @abc.abstractmethod\n    def files(self) -> \"Traversable\":\n        \"\"\"Return a Traversable object for the loaded package.\"\"\"\n    def open_resource(self, resource: StrPath) -> io.BufferedReader:\n        return self.files().joinpath(resource).open('rb')",
        "detail": "pycharm_venv.Lib.importlib.resources.abc",
        "documentation": {}
    },
    {
        "label": "StrPath",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib.resources.abc",
        "description": "pycharm_venv.Lib.importlib.resources.abc",
        "peekOfCode": "StrPath = Union[str, os.PathLike[str]]\n__all__ = [\"ResourceReader\", \"Traversable\", \"TraversableResources\"]\nclass ResourceReader(metaclass=abc.ABCMeta):\n    \"\"\"Abstract base class for loaders to provide resource reading support.\"\"\"\n    @abc.abstractmethod\n    def open_resource(self, resource: Text) -> BinaryIO:\n        \"\"\"Return an opened, file-like object for binary reading.\n        The 'resource' argument is expected to represent only a file name.\n        If the resource cannot be found, FileNotFoundError is raised.\n        \"\"\"",
        "detail": "pycharm_venv.Lib.importlib.resources.abc",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib.resources.abc",
        "description": "pycharm_venv.Lib.importlib.resources.abc",
        "peekOfCode": "__all__ = [\"ResourceReader\", \"Traversable\", \"TraversableResources\"]\nclass ResourceReader(metaclass=abc.ABCMeta):\n    \"\"\"Abstract base class for loaders to provide resource reading support.\"\"\"\n    @abc.abstractmethod\n    def open_resource(self, resource: Text) -> BinaryIO:\n        \"\"\"Return an opened, file-like object for binary reading.\n        The 'resource' argument is expected to represent only a file name.\n        If the resource cannot be found, FileNotFoundError is raised.\n        \"\"\"\n        # This deliberately raises FileNotFoundError instead of",
        "detail": "pycharm_venv.Lib.importlib.resources.abc",
        "documentation": {}
    },
    {
        "label": "FileReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.resources.readers",
        "description": "pycharm_venv.Lib.importlib.resources.readers",
        "peekOfCode": "class FileReader(abc.TraversableResources):\n    def __init__(self, loader):\n        self.path = pathlib.Path(loader.path).parent\n    def resource_path(self, resource):\n        \"\"\"\n        Return the file system path to prevent\n        `resources.path()` from creating a temporary\n        copy.\n        \"\"\"\n        return str(self.path.joinpath(resource))",
        "detail": "pycharm_venv.Lib.importlib.resources.readers",
        "documentation": {}
    },
    {
        "label": "ZipReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.resources.readers",
        "description": "pycharm_venv.Lib.importlib.resources.readers",
        "peekOfCode": "class ZipReader(abc.TraversableResources):\n    def __init__(self, loader, module):\n        self.prefix = loader.prefix.replace('\\\\', '/')\n        if loader.is_package(module):\n            _, _, name = module.rpartition('.')\n            self.prefix += name + '/'\n        self.archive = loader.archive\n    def open_resource(self, resource):\n        try:\n            return super().open_resource(resource)",
        "detail": "pycharm_venv.Lib.importlib.resources.readers",
        "documentation": {}
    },
    {
        "label": "MultiplexedPath",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.resources.readers",
        "description": "pycharm_venv.Lib.importlib.resources.readers",
        "peekOfCode": "class MultiplexedPath(abc.Traversable):\n    \"\"\"\n    Given a series of Traversable objects, implement a merged\n    version of the interface across all objects. Useful for\n    namespace packages which may be multihomed at a single\n    name.\n    \"\"\"\n    def __init__(self, *paths):\n        self._paths = list(map(_ensure_traversable, remove_duplicates(paths)))\n        if not self._paths:",
        "detail": "pycharm_venv.Lib.importlib.resources.readers",
        "documentation": {}
    },
    {
        "label": "NamespaceReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.resources.readers",
        "description": "pycharm_venv.Lib.importlib.resources.readers",
        "peekOfCode": "class NamespaceReader(abc.TraversableResources):\n    def __init__(self, namespace_path):\n        if 'NamespacePath' not in str(namespace_path):\n            raise ValueError('Invalid path')\n        self.path = MultiplexedPath(*map(self._resolve, namespace_path))\n    @classmethod\n    def _resolve(cls, path_str) -> abc.Traversable:\n        r\"\"\"\n        Given an item from a namespace path, resolve it to a Traversable.\n        path_str might be a directory on the filesystem or a path to a",
        "detail": "pycharm_venv.Lib.importlib.resources.readers",
        "documentation": {}
    },
    {
        "label": "remove_duplicates",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.resources.readers",
        "description": "pycharm_venv.Lib.importlib.resources.readers",
        "peekOfCode": "def remove_duplicates(items):\n    return iter(collections.OrderedDict.fromkeys(items))\nclass FileReader(abc.TraversableResources):\n    def __init__(self, loader):\n        self.path = pathlib.Path(loader.path).parent\n    def resource_path(self, resource):\n        \"\"\"\n        Return the file system path to prevent\n        `resources.path()` from creating a temporary\n        copy.",
        "detail": "pycharm_venv.Lib.importlib.resources.readers",
        "documentation": {}
    },
    {
        "label": "SimpleReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.resources.simple",
        "description": "pycharm_venv.Lib.importlib.resources.simple",
        "peekOfCode": "class SimpleReader(abc.ABC):\n    \"\"\"\n    The minimum, low-level interface required from a resource\n    provider.\n    \"\"\"\n    @property\n    @abc.abstractmethod\n    def package(self) -> str:\n        \"\"\"\n        The name of the package for which this reader loads resources.",
        "detail": "pycharm_venv.Lib.importlib.resources.simple",
        "documentation": {}
    },
    {
        "label": "ResourceContainer",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.resources.simple",
        "description": "pycharm_venv.Lib.importlib.resources.simple",
        "peekOfCode": "class ResourceContainer(Traversable):\n    \"\"\"\n    Traversable container for a package's resources via its reader.\n    \"\"\"\n    def __init__(self, reader: SimpleReader):\n        self.reader = reader\n    def is_dir(self):\n        return True\n    def is_file(self):\n        return False",
        "detail": "pycharm_venv.Lib.importlib.resources.simple",
        "documentation": {}
    },
    {
        "label": "ResourceHandle",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.resources.simple",
        "description": "pycharm_venv.Lib.importlib.resources.simple",
        "peekOfCode": "class ResourceHandle(Traversable):\n    \"\"\"\n    Handle to a named resource in a ResourceReader.\n    \"\"\"\n    def __init__(self, parent: ResourceContainer, name: str):\n        self.parent = parent\n        self.name = name  # type: ignore\n    def is_file(self):\n        return True\n    def is_dir(self):",
        "detail": "pycharm_venv.Lib.importlib.resources.simple",
        "documentation": {}
    },
    {
        "label": "TraversableReader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.resources.simple",
        "description": "pycharm_venv.Lib.importlib.resources.simple",
        "peekOfCode": "class TraversableReader(TraversableResources, SimpleReader):\n    \"\"\"\n    A TraversableResources based on SimpleReader. Resource providers\n    may derive from this class to provide the TraversableResources\n    interface by supplying the SimpleReader interface.\n    \"\"\"\n    def files(self):\n        return ResourceContainer(self)",
        "detail": "pycharm_venv.Lib.importlib.resources.simple",
        "documentation": {}
    },
    {
        "label": "SpecLoaderAdapter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.resources._adapters",
        "description": "pycharm_venv.Lib.importlib.resources._adapters",
        "peekOfCode": "class SpecLoaderAdapter:\n    \"\"\"\n    Adapt a package spec to adapt the underlying loader.\n    \"\"\"\n    def __init__(self, spec, adapter=lambda spec: spec.loader):\n        self.spec = spec\n        self.loader = adapter(spec)\n    def __getattr__(self, name):\n        return getattr(self.spec, name)\nclass TraversableResourcesLoader:",
        "detail": "pycharm_venv.Lib.importlib.resources._adapters",
        "documentation": {}
    },
    {
        "label": "TraversableResourcesLoader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.resources._adapters",
        "description": "pycharm_venv.Lib.importlib.resources._adapters",
        "peekOfCode": "class TraversableResourcesLoader:\n    \"\"\"\n    Adapt a loader to provide TraversableResources.\n    \"\"\"\n    def __init__(self, spec):\n        self.spec = spec\n    def get_resource_reader(self, name):\n        return CompatibilityFiles(self.spec)._native()\ndef _io_wrapper(file, mode='r', *args, **kwargs):\n    if mode == 'r':",
        "detail": "pycharm_venv.Lib.importlib.resources._adapters",
        "documentation": {}
    },
    {
        "label": "CompatibilityFiles",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.resources._adapters",
        "description": "pycharm_venv.Lib.importlib.resources._adapters",
        "peekOfCode": "class CompatibilityFiles:\n    \"\"\"\n    Adapter for an existing or non-existent resource reader\n    to provide a compatibility .files().\n    \"\"\"\n    class SpecPath(abc.Traversable):\n        \"\"\"\n        Path tied to a module spec.\n        Can be read and exposes the resource reader children.\n        \"\"\"",
        "detail": "pycharm_venv.Lib.importlib.resources._adapters",
        "documentation": {}
    },
    {
        "label": "wrap_spec",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.resources._adapters",
        "description": "pycharm_venv.Lib.importlib.resources._adapters",
        "peekOfCode": "def wrap_spec(package):\n    \"\"\"\n    Construct a package spec with traversable compatibility\n    on the spec/loader/reader.\n    \"\"\"\n    return SpecLoaderAdapter(package.__spec__, TraversableResourcesLoader)",
        "detail": "pycharm_venv.Lib.importlib.resources._adapters",
        "documentation": {}
    },
    {
        "label": "package_to_anchor",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.resources._common",
        "description": "pycharm_venv.Lib.importlib.resources._common",
        "peekOfCode": "def package_to_anchor(func):\n    \"\"\"\n    Replace 'package' parameter as 'anchor' and warn about the change.\n    Other errors should fall through.\n    >>> files('a', 'b')\n    Traceback (most recent call last):\n    TypeError: files() takes from 0 to 1 positional arguments but 2 were given\n    Remove this compatibility in Python 3.14.\n    \"\"\"\n    undefined = object()",
        "detail": "pycharm_venv.Lib.importlib.resources._common",
        "documentation": {}
    },
    {
        "label": "files",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.resources._common",
        "description": "pycharm_venv.Lib.importlib.resources._common",
        "peekOfCode": "def files(anchor: Optional[Anchor] = None) -> Traversable:\n    \"\"\"\n    Get a Traversable resource for an anchor.\n    \"\"\"\n    return from_package(resolve(anchor))\ndef get_resource_reader(package: types.ModuleType) -> Optional[ResourceReader]:\n    \"\"\"\n    Return the package's loader if it's a ResourceReader.\n    \"\"\"\n    # We can't use",
        "detail": "pycharm_venv.Lib.importlib.resources._common",
        "documentation": {}
    },
    {
        "label": "get_resource_reader",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.resources._common",
        "description": "pycharm_venv.Lib.importlib.resources._common",
        "peekOfCode": "def get_resource_reader(package: types.ModuleType) -> Optional[ResourceReader]:\n    \"\"\"\n    Return the package's loader if it's a ResourceReader.\n    \"\"\"\n    # We can't use\n    # a issubclass() check here because apparently abc.'s __subclasscheck__()\n    # hook wants to create a weak reference to the object, but\n    # zipimport.zipimporter does not support weak references, resulting in a\n    # TypeError.  That seems terrible.\n    spec = package.__spec__",
        "detail": "pycharm_venv.Lib.importlib.resources._common",
        "documentation": {}
    },
    {
        "label": "resolve",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.resources._common",
        "description": "pycharm_venv.Lib.importlib.resources._common",
        "peekOfCode": "def resolve(cand: Optional[Anchor]) -> types.ModuleType:\n    return cast(types.ModuleType, cand)\n@resolve.register\ndef _(cand: str) -> types.ModuleType:\n    return importlib.import_module(cand)\n@resolve.register\ndef _(cand: None) -> types.ModuleType:\n    return resolve(_infer_caller().f_globals['__name__'])\ndef _infer_caller():\n    \"\"\"",
        "detail": "pycharm_venv.Lib.importlib.resources._common",
        "documentation": {}
    },
    {
        "label": "from_package",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.resources._common",
        "description": "pycharm_venv.Lib.importlib.resources._common",
        "peekOfCode": "def from_package(package: types.ModuleType):\n    \"\"\"\n    Return a Traversable object for the given package.\n    \"\"\"\n    # deferred for performance (python/cpython#109829)\n    from ._adapters import wrap_spec\n    spec = wrap_spec(package)\n    reader = spec.loader.get_resource_reader(spec.name)\n    return reader.files()\n@contextlib.contextmanager",
        "detail": "pycharm_venv.Lib.importlib.resources._common",
        "documentation": {}
    },
    {
        "label": "as_file",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.resources._common",
        "description": "pycharm_venv.Lib.importlib.resources._common",
        "peekOfCode": "def as_file(path):\n    \"\"\"\n    Given a Traversable object, return that object as a\n    path on the local file system in a context manager.\n    \"\"\"\n    return _temp_dir(path) if _is_present_dir(path) else _temp_file(path)\n@as_file.register(pathlib.Path)\n@contextlib.contextmanager\ndef _(path):\n    \"\"\"",
        "detail": "pycharm_venv.Lib.importlib.resources._common",
        "documentation": {}
    },
    {
        "label": "Package",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib.resources._common",
        "description": "pycharm_venv.Lib.importlib.resources._common",
        "peekOfCode": "Package = Union[types.ModuleType, str]\nAnchor = Package\ndef package_to_anchor(func):\n    \"\"\"\n    Replace 'package' parameter as 'anchor' and warn about the change.\n    Other errors should fall through.\n    >>> files('a', 'b')\n    Traceback (most recent call last):\n    TypeError: files() takes from 0 to 1 positional arguments but 2 were given\n    Remove this compatibility in Python 3.14.",
        "detail": "pycharm_venv.Lib.importlib.resources._common",
        "documentation": {}
    },
    {
        "label": "Anchor",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib.resources._common",
        "description": "pycharm_venv.Lib.importlib.resources._common",
        "peekOfCode": "Anchor = Package\ndef package_to_anchor(func):\n    \"\"\"\n    Replace 'package' parameter as 'anchor' and warn about the change.\n    Other errors should fall through.\n    >>> files('a', 'b')\n    Traceback (most recent call last):\n    TypeError: files() takes from 0 to 1 positional arguments but 2 were given\n    Remove this compatibility in Python 3.14.\n    \"\"\"",
        "detail": "pycharm_venv.Lib.importlib.resources._common",
        "documentation": {}
    },
    {
        "label": "open_binary",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.resources._functional",
        "description": "pycharm_venv.Lib.importlib.resources._functional",
        "peekOfCode": "def open_binary(anchor, *path_names):\n    \"\"\"Open for binary reading the *resource* within *package*.\"\"\"\n    return _get_resource(anchor, path_names).open('rb')\ndef open_text(anchor, *path_names, encoding=_MISSING, errors='strict'):\n    \"\"\"Open for text reading the *resource* within *package*.\"\"\"\n    encoding = _get_encoding_arg(path_names, encoding)\n    resource = _get_resource(anchor, path_names)\n    return resource.open('r', encoding=encoding, errors=errors)\ndef read_binary(anchor, *path_names):\n    \"\"\"Read and return contents of *resource* within *package* as bytes.\"\"\"",
        "detail": "pycharm_venv.Lib.importlib.resources._functional",
        "documentation": {}
    },
    {
        "label": "open_text",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.resources._functional",
        "description": "pycharm_venv.Lib.importlib.resources._functional",
        "peekOfCode": "def open_text(anchor, *path_names, encoding=_MISSING, errors='strict'):\n    \"\"\"Open for text reading the *resource* within *package*.\"\"\"\n    encoding = _get_encoding_arg(path_names, encoding)\n    resource = _get_resource(anchor, path_names)\n    return resource.open('r', encoding=encoding, errors=errors)\ndef read_binary(anchor, *path_names):\n    \"\"\"Read and return contents of *resource* within *package* as bytes.\"\"\"\n    return _get_resource(anchor, path_names).read_bytes()\ndef read_text(anchor, *path_names, encoding=_MISSING, errors='strict'):\n    \"\"\"Read and return contents of *resource* within *package* as str.\"\"\"",
        "detail": "pycharm_venv.Lib.importlib.resources._functional",
        "documentation": {}
    },
    {
        "label": "read_binary",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.resources._functional",
        "description": "pycharm_venv.Lib.importlib.resources._functional",
        "peekOfCode": "def read_binary(anchor, *path_names):\n    \"\"\"Read and return contents of *resource* within *package* as bytes.\"\"\"\n    return _get_resource(anchor, path_names).read_bytes()\ndef read_text(anchor, *path_names, encoding=_MISSING, errors='strict'):\n    \"\"\"Read and return contents of *resource* within *package* as str.\"\"\"\n    encoding = _get_encoding_arg(path_names, encoding)\n    resource = _get_resource(anchor, path_names)\n    return resource.read_text(encoding=encoding, errors=errors)\ndef path(anchor, *path_names):\n    \"\"\"Return the path to the *resource* as an actual file system path.\"\"\"",
        "detail": "pycharm_venv.Lib.importlib.resources._functional",
        "documentation": {}
    },
    {
        "label": "read_text",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.resources._functional",
        "description": "pycharm_venv.Lib.importlib.resources._functional",
        "peekOfCode": "def read_text(anchor, *path_names, encoding=_MISSING, errors='strict'):\n    \"\"\"Read and return contents of *resource* within *package* as str.\"\"\"\n    encoding = _get_encoding_arg(path_names, encoding)\n    resource = _get_resource(anchor, path_names)\n    return resource.read_text(encoding=encoding, errors=errors)\ndef path(anchor, *path_names):\n    \"\"\"Return the path to the *resource* as an actual file system path.\"\"\"\n    return as_file(_get_resource(anchor, path_names))\ndef is_resource(anchor, *path_names):\n    \"\"\"Return ``True`` if there is a resource named *name* in the package,",
        "detail": "pycharm_venv.Lib.importlib.resources._functional",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.resources._functional",
        "description": "pycharm_venv.Lib.importlib.resources._functional",
        "peekOfCode": "def path(anchor, *path_names):\n    \"\"\"Return the path to the *resource* as an actual file system path.\"\"\"\n    return as_file(_get_resource(anchor, path_names))\ndef is_resource(anchor, *path_names):\n    \"\"\"Return ``True`` if there is a resource named *name* in the package,\n    Otherwise returns ``False``.\n    \"\"\"\n    return _get_resource(anchor, path_names).is_file()\ndef contents(anchor, *path_names):\n    \"\"\"Return an iterable over the named resources within the package.",
        "detail": "pycharm_venv.Lib.importlib.resources._functional",
        "documentation": {}
    },
    {
        "label": "is_resource",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.resources._functional",
        "description": "pycharm_venv.Lib.importlib.resources._functional",
        "peekOfCode": "def is_resource(anchor, *path_names):\n    \"\"\"Return ``True`` if there is a resource named *name* in the package,\n    Otherwise returns ``False``.\n    \"\"\"\n    return _get_resource(anchor, path_names).is_file()\ndef contents(anchor, *path_names):\n    \"\"\"Return an iterable over the named resources within the package.\n    The iterable returns :class:`str` resources (e.g. files).\n    The iterable does not recurse into subdirectories.\n    \"\"\"",
        "detail": "pycharm_venv.Lib.importlib.resources._functional",
        "documentation": {}
    },
    {
        "label": "contents",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.resources._functional",
        "description": "pycharm_venv.Lib.importlib.resources._functional",
        "peekOfCode": "def contents(anchor, *path_names):\n    \"\"\"Return an iterable over the named resources within the package.\n    The iterable returns :class:`str` resources (e.g. files).\n    The iterable does not recurse into subdirectories.\n    \"\"\"\n    warnings.warn(\n        \"importlib.resources.contents is deprecated. \"\n        \"Use files(anchor).iterdir() instead.\",\n        DeprecationWarning,\n        stacklevel=1,",
        "detail": "pycharm_venv.Lib.importlib.resources._functional",
        "documentation": {}
    },
    {
        "label": "_MISSING",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib.resources._functional",
        "description": "pycharm_venv.Lib.importlib.resources._functional",
        "peekOfCode": "_MISSING = object()\ndef open_binary(anchor, *path_names):\n    \"\"\"Open for binary reading the *resource* within *package*.\"\"\"\n    return _get_resource(anchor, path_names).open('rb')\ndef open_text(anchor, *path_names, encoding=_MISSING, errors='strict'):\n    \"\"\"Open for text reading the *resource* within *package*.\"\"\"\n    encoding = _get_encoding_arg(path_names, encoding)\n    resource = _get_resource(anchor, path_names)\n    return resource.open('r', encoding=encoding, errors=errors)\ndef read_binary(anchor, *path_names):",
        "detail": "pycharm_venv.Lib.importlib.resources._functional",
        "documentation": {}
    },
    {
        "label": "only",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.resources._itertools",
        "description": "pycharm_venv.Lib.importlib.resources._itertools",
        "peekOfCode": "def only(iterable, default=None, too_long=None):\n    \"\"\"If *iterable* has only one item, return it.\n    If it has zero items, return *default*.\n    If it has more than one item, raise the exception given by *too_long*,\n    which is ``ValueError`` by default.\n    >>> only([], default='missing')\n    'missing'\n    >>> only([1])\n    1\n    >>> only([1, 2])  # doctest: +IGNORE_EXCEPTION_DETAIL",
        "detail": "pycharm_venv.Lib.importlib.resources._itertools",
        "documentation": {}
    },
    {
        "label": "MetaPathFinder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.abc",
        "description": "pycharm_venv.Lib.importlib.abc",
        "peekOfCode": "class MetaPathFinder(metaclass=abc.ABCMeta):\n    \"\"\"Abstract base class for import finders on sys.meta_path.\"\"\"\n    # We don't define find_spec() here since that would break\n    # hasattr checks we do to support backward compatibility.\n    def invalidate_caches(self):\n        \"\"\"An optional method for clearing the finder's cache, if any.\n        This method is used by importlib.invalidate_caches().\n        \"\"\"\n_register(MetaPathFinder, machinery.BuiltinImporter, machinery.FrozenImporter,\n          machinery.PathFinder, machinery.WindowsRegistryFinder)",
        "detail": "pycharm_venv.Lib.importlib.abc",
        "documentation": {}
    },
    {
        "label": "PathEntryFinder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.abc",
        "description": "pycharm_venv.Lib.importlib.abc",
        "peekOfCode": "class PathEntryFinder(metaclass=abc.ABCMeta):\n    \"\"\"Abstract base class for path entry finders used by PathFinder.\"\"\"\n    def invalidate_caches(self):\n        \"\"\"An optional method for clearing the finder's cache, if any.\n        This method is used by PathFinder.invalidate_caches().\n        \"\"\"\n_register(PathEntryFinder, machinery.FileFinder)\nclass ResourceLoader(Loader):\n    \"\"\"Abstract base class for loaders which can return data from their\n    back-end storage.",
        "detail": "pycharm_venv.Lib.importlib.abc",
        "documentation": {}
    },
    {
        "label": "ResourceLoader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.abc",
        "description": "pycharm_venv.Lib.importlib.abc",
        "peekOfCode": "class ResourceLoader(Loader):\n    \"\"\"Abstract base class for loaders which can return data from their\n    back-end storage.\n    This ABC represents one of the optional protocols specified by PEP 302.\n    \"\"\"\n    @abc.abstractmethod\n    def get_data(self, path):\n        \"\"\"Abstract method which when implemented should return the bytes for\n        the specified path.  The path must be a str.\"\"\"\n        raise OSError",
        "detail": "pycharm_venv.Lib.importlib.abc",
        "documentation": {}
    },
    {
        "label": "InspectLoader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.abc",
        "description": "pycharm_venv.Lib.importlib.abc",
        "peekOfCode": "class InspectLoader(Loader):\n    \"\"\"Abstract base class for loaders which support inspection about the\n    modules they can load.\n    This ABC represents one of the optional protocols specified by PEP 302.\n    \"\"\"\n    def is_package(self, fullname):\n        \"\"\"Optional method which when implemented should return whether the\n        module is a package.  The fullname is a str.  Returns a bool.\n        Raises ImportError if the module cannot be found.\n        \"\"\"",
        "detail": "pycharm_venv.Lib.importlib.abc",
        "documentation": {}
    },
    {
        "label": "ExecutionLoader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.abc",
        "description": "pycharm_venv.Lib.importlib.abc",
        "peekOfCode": "class ExecutionLoader(InspectLoader):\n    \"\"\"Abstract base class for loaders that wish to support the execution of\n    modules as scripts.\n    This ABC represents one of the optional protocols specified in PEP 302.\n    \"\"\"\n    @abc.abstractmethod\n    def get_filename(self, fullname):\n        \"\"\"Abstract method which should return the value that __file__ is to be\n        set to.\n        Raises ImportError if the module cannot be found.",
        "detail": "pycharm_venv.Lib.importlib.abc",
        "documentation": {}
    },
    {
        "label": "FileLoader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.abc",
        "description": "pycharm_venv.Lib.importlib.abc",
        "peekOfCode": "class FileLoader(_bootstrap_external.FileLoader, ResourceLoader, ExecutionLoader):\n    \"\"\"Abstract base class partially implementing the ResourceLoader and\n    ExecutionLoader ABCs.\"\"\"\n_register(FileLoader, machinery.SourceFileLoader,\n            machinery.SourcelessFileLoader)\nclass SourceLoader(_bootstrap_external.SourceLoader, ResourceLoader, ExecutionLoader):\n    \"\"\"Abstract base class for loading source code (and optionally any\n    corresponding bytecode).\n    To support loading from source code, the abstractmethods inherited from\n    ResourceLoader and ExecutionLoader need to be implemented. To also support",
        "detail": "pycharm_venv.Lib.importlib.abc",
        "documentation": {}
    },
    {
        "label": "SourceLoader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.abc",
        "description": "pycharm_venv.Lib.importlib.abc",
        "peekOfCode": "class SourceLoader(_bootstrap_external.SourceLoader, ResourceLoader, ExecutionLoader):\n    \"\"\"Abstract base class for loading source code (and optionally any\n    corresponding bytecode).\n    To support loading from source code, the abstractmethods inherited from\n    ResourceLoader and ExecutionLoader need to be implemented. To also support\n    loading from bytecode, the optional methods specified directly by this ABC\n    is required.\n    Inherited abstractmethods not implemented in this ABC:\n        * ResourceLoader.get_data\n        * ExecutionLoader.get_filename",
        "detail": "pycharm_venv.Lib.importlib.abc",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib.abc",
        "description": "pycharm_venv.Lib.importlib.abc",
        "peekOfCode": "__all__ = [\n    'Loader', 'MetaPathFinder', 'PathEntryFinder',\n    'ResourceLoader', 'InspectLoader', 'ExecutionLoader',\n    'FileLoader', 'SourceLoader',\n]\ndef __getattr__(name):\n    \"\"\"\n    For backwards compatibility, continue to make names\n    from _resources_abc available through this module. #93963\n    \"\"\"",
        "detail": "pycharm_venv.Lib.importlib.abc",
        "documentation": {}
    },
    {
        "label": "all_suffixes",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.machinery",
        "description": "pycharm_venv.Lib.importlib.machinery",
        "peekOfCode": "def all_suffixes():\n    \"\"\"Returns a list of all recognized module suffixes for this process\"\"\"\n    return SOURCE_SUFFIXES + BYTECODE_SUFFIXES + EXTENSION_SUFFIXES",
        "detail": "pycharm_venv.Lib.importlib.machinery",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib.readers",
        "description": "pycharm_venv.Lib.importlib.readers",
        "peekOfCode": "__all__ = ['FileReader', 'ZipReader', 'MultiplexedPath', 'NamespaceReader']",
        "detail": "pycharm_venv.Lib.importlib.readers",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib.simple",
        "description": "pycharm_venv.Lib.importlib.simple",
        "peekOfCode": "__all__ = [\n    'SimpleReader', 'ResourceHandle', 'ResourceContainer', 'TraversableReader',\n]",
        "detail": "pycharm_venv.Lib.importlib.simple",
        "documentation": {}
    },
    {
        "label": "_incompatible_extension_module_restrictions",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.util",
        "description": "pycharm_venv.Lib.importlib.util",
        "peekOfCode": "class _incompatible_extension_module_restrictions:\n    \"\"\"A context manager that can temporarily skip the compatibility check.\n    NOTE: This function is meant to accommodate an unusual case; one\n    which is likely to eventually go away.  There's is a pretty good\n    chance this is not what you were looking for.\n    WARNING: Using this function to disable the check can lead to\n    unexpected behavior and even crashes.  It should only be used during\n    extension module development.\n    If \"disable_check\" is True then the compatibility check will not\n    happen while the context manager is active.  Otherwise the check",
        "detail": "pycharm_venv.Lib.importlib.util",
        "documentation": {}
    },
    {
        "label": "_LazyModule",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.util",
        "description": "pycharm_venv.Lib.importlib.util",
        "peekOfCode": "class _LazyModule(types.ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute access.\"\"\"\n    def __getattribute__(self, attr):\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        __spec__ = object.__getattribute__(self, '__spec__')\n        loader_state = __spec__.loader_state\n        with loader_state['lock']:\n            # Only the first thread to get the lock should trigger the load\n            # and reset the module's class. The rest can now getattr().\n            if object.__getattribute__(self, '__class__') is _LazyModule:",
        "detail": "pycharm_venv.Lib.importlib.util",
        "documentation": {}
    },
    {
        "label": "LazyLoader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib.util",
        "description": "pycharm_venv.Lib.importlib.util",
        "peekOfCode": "class LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute access.\"\"\"\n    @staticmethod\n    def __check_eager_loader(loader):\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError('loader must define exec_module()')\n    @classmethod\n    def factory(cls, loader):\n        \"\"\"Construct a callable which returns the eager loader made lazy.\"\"\"\n        cls.__check_eager_loader(loader)",
        "detail": "pycharm_venv.Lib.importlib.util",
        "documentation": {}
    },
    {
        "label": "source_hash",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.util",
        "description": "pycharm_venv.Lib.importlib.util",
        "peekOfCode": "def source_hash(source_bytes):\n    \"Return the hash of *source_bytes* as used in hash-based pyc files.\"\n    return _imp.source_hash(_RAW_MAGIC_NUMBER, source_bytes)\ndef resolve_name(name, package):\n    \"\"\"Resolve a relative module name to an absolute one.\"\"\"\n    if not name.startswith('.'):\n        return name\n    elif not package:\n        raise ImportError(f'no package specified for {repr(name)} '\n                          '(required for relative module names)')",
        "detail": "pycharm_venv.Lib.importlib.util",
        "documentation": {}
    },
    {
        "label": "resolve_name",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.util",
        "description": "pycharm_venv.Lib.importlib.util",
        "peekOfCode": "def resolve_name(name, package):\n    \"\"\"Resolve a relative module name to an absolute one.\"\"\"\n    if not name.startswith('.'):\n        return name\n    elif not package:\n        raise ImportError(f'no package specified for {repr(name)} '\n                          '(required for relative module names)')\n    level = 0\n    for character in name:\n        if character != '.':",
        "detail": "pycharm_venv.Lib.importlib.util",
        "documentation": {}
    },
    {
        "label": "find_spec",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib.util",
        "description": "pycharm_venv.Lib.importlib.util",
        "peekOfCode": "def find_spec(name, package=None):\n    \"\"\"Return the spec for the specified module.\n    First, sys.modules is checked to see if the module was already imported. If\n    so, then sys.modules[name].__spec__ is returned. If that happens to be\n    set to None, then ValueError is raised. If the module is not in\n    sys.modules, then sys.meta_path is searched for a suitable spec with the\n    value of 'path' given to the finders. None is returned if no spec could\n    be found.\n    If the name is for submodule (contains a dot), the parent module is\n    automatically imported.",
        "detail": "pycharm_venv.Lib.importlib.util",
        "documentation": {}
    },
    {
        "label": "Loader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._abc",
        "description": "pycharm_venv.Lib.importlib._abc",
        "peekOfCode": "class Loader(metaclass=abc.ABCMeta):\n    \"\"\"Abstract base class for import loaders.\"\"\"\n    def create_module(self, spec):\n        \"\"\"Return a module to initialize and into which to load.\n        This method should raise ImportError if anything prevents it\n        from creating a new module.  It may return None to indicate\n        that the spec should create the new module.\n        \"\"\"\n        # By default, defer to default semantics for the new module.\n        return None",
        "detail": "pycharm_venv.Lib.importlib._abc",
        "documentation": {}
    },
    {
        "label": "_List",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "class _List(list):\n    __slots__ = (\"__weakref__\",)\n# Copied from weakref.py with some simplifications and modifications unique to\n# bootstrapping importlib. Many methods were simply deleting for simplicity, so if they\n# are needed in the future they may work if simply copied back in.\nclass _WeakValueDictionary:\n    def __init__(self):\n        self_weakref = _weakref.ref(self)\n        # Inlined to avoid issues with inheriting from _weakref.ref before _weakref is\n        # set by _setup(). Since there's only one instance of this class, this is",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "_WeakValueDictionary",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "class _WeakValueDictionary:\n    def __init__(self):\n        self_weakref = _weakref.ref(self)\n        # Inlined to avoid issues with inheriting from _weakref.ref before _weakref is\n        # set by _setup(). Since there's only one instance of this class, this is\n        # not expensive.\n        class KeyedRef(_weakref.ref):\n            __slots__ = \"key\",\n            def __new__(type, ob, key):\n                self = super().__new__(type, ob, type.remove)",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "_BlockingOnManager",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "class _BlockingOnManager:\n    \"\"\"A context manager responsible to updating ``_blocking_on``.\"\"\"\n    def __init__(self, thread_id, lock):\n        self.thread_id = thread_id\n        self.lock = lock\n    def __enter__(self):\n        \"\"\"Mark the running thread as waiting for self.lock. via _blocking_on.\"\"\"\n        # Interactions with _blocking_on are *not* protected by the global\n        # import lock here because each thread only touches the state that it\n        # owns (state keyed on its thread id).  The global import lock is",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "_DeadlockError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "class _DeadlockError(RuntimeError):\n    pass\ndef _has_deadlocked(target_id, *, seen_ids, candidate_ids, blocking_on):\n    \"\"\"Check if 'target_id' is holding the same lock as another thread(s).\n    The search within 'blocking_on' starts with the threads listed in\n    'candidate_ids'.  'seen_ids' contains any threads that are considered\n    already traversed in the search.\n    Keyword arguments:\n    target_id     -- The thread id to try to reach.\n    seen_ids      -- A set of threads that have already been visited.",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "_ModuleLock",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "class _ModuleLock:\n    \"\"\"A recursive lock implementation which is able to detect deadlocks\n    (e.g. thread 1 trying to take locks A then B, and thread 2 trying to\n    take locks B then A).\n    \"\"\"\n    def __init__(self, name):\n        # Create an RLock for protecting the import process for the\n        # corresponding module.  Since it is an RLock, a single thread will be\n        # able to take it more than once.  This is necessary to support\n        # re-entrancy in the import system that arises from (at least) signal",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "_DummyModuleLock",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "class _DummyModuleLock:\n    \"\"\"A simple _ModuleLock equivalent for Python builds without\n    multi-threading support.\"\"\"\n    def __init__(self, name):\n        self.name = name\n        self.count = 0\n    def acquire(self):\n        self.count += 1\n        return True\n    def release(self):",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "_ModuleLockManager",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "class _ModuleLockManager:\n    def __init__(self, name):\n        self._name = name\n        self._lock = None\n    def __enter__(self):\n        self._lock = _get_module_lock(self._name)\n        self._lock.acquire()\n    def __exit__(self, *args, **kwargs):\n        self._lock.release()\n# The following two functions are for consumption by Python/import.c.",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "ModuleSpec",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "class ModuleSpec:\n    \"\"\"The specification for a module, used for loading.\n    A module's spec is the source for information about the module.  For\n    data associated with the module, including source, use the spec's\n    loader.\n    `name` is the absolute name of the module.  `loader` is the loader\n    to use when loading the module.  `parent` is the name of the\n    package the module is in.  The parent is derived from the name.\n    `is_package` determines if the module is considered a package or\n    not.  On modules this is reflected by the `__path__` attribute.",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "BuiltinImporter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "class BuiltinImporter:\n    \"\"\"Meta path import for built-in modules.\n    All methods are either class or static methods to avoid the need to\n    instantiate the class.\n    \"\"\"\n    _ORIGIN = \"built-in\"\n    @classmethod\n    def find_spec(cls, fullname, path=None, target=None):\n        if _imp.is_builtin(fullname):\n            return spec_from_loader(fullname, cls, origin=cls._ORIGIN)",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "FrozenImporter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "class FrozenImporter:\n    \"\"\"Meta path import for frozen modules.\n    All methods are either class or static methods to avoid the need to\n    instantiate the class.\n    \"\"\"\n    _ORIGIN = \"frozen\"\n    @classmethod\n    def _fix_up_module(cls, module):\n        spec = module.__spec__\n        state = spec.loader_state",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "_ImportLockContext",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "class _ImportLockContext:\n    \"\"\"Context manager for the import lock.\"\"\"\n    def __enter__(self):\n        \"\"\"Acquire the import lock.\"\"\"\n        _imp.acquire_lock()\n    def __exit__(self, exc_type, exc_value, exc_traceback):\n        \"\"\"Release the import lock regardless of any raised exceptions.\"\"\"\n        _imp.release_lock()\ndef _resolve_name(name, package, level):\n    \"\"\"Resolve a relative module name to an absolute one.\"\"\"",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "spec_from_loader",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "def spec_from_loader(name, loader, *, origin=None, is_package=None):\n    \"\"\"Return a module spec based on various loader methods.\"\"\"\n    if origin is None:\n        origin = getattr(loader, '_ORIGIN', None)\n    if not origin and hasattr(loader, 'get_filename'):\n        if _bootstrap_external is None:\n            raise NotImplementedError\n        spec_from_file_location = _bootstrap_external.spec_from_file_location\n        if is_package is None:\n            return spec_from_file_location(name, loader=loader)",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "module_from_spec",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "def module_from_spec(spec):\n    \"\"\"Create a module based on the provided spec.\"\"\"\n    # Typically loaders will not implement create_module().\n    module = None\n    if hasattr(spec.loader, 'create_module'):\n        # If create_module() returns `None` then it means default\n        # module creation should be used.\n        module = spec.loader.create_module(spec)\n    elif hasattr(spec.loader, 'exec_module'):\n        raise ImportError('loaders that define exec_module() '",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "_thread",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "_thread = None\n_warnings = None\n_weakref = None\n# Import done by _install_external_importers()\n_bootstrap_external = None\ndef _wrap(new, old):\n    \"\"\"Simple substitute for functools.update_wrapper.\"\"\"\n    for replace in ['__module__', '__name__', '__qualname__', '__doc__']:\n        if hasattr(old, replace):\n            setattr(new, replace, getattr(old, replace))",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "_warnings",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "_warnings = None\n_weakref = None\n# Import done by _install_external_importers()\n_bootstrap_external = None\ndef _wrap(new, old):\n    \"\"\"Simple substitute for functools.update_wrapper.\"\"\"\n    for replace in ['__module__', '__name__', '__qualname__', '__doc__']:\n        if hasattr(old, replace):\n            setattr(new, replace, getattr(old, replace))\n    new.__dict__.update(old.__dict__)",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "_weakref",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "_weakref = None\n# Import done by _install_external_importers()\n_bootstrap_external = None\ndef _wrap(new, old):\n    \"\"\"Simple substitute for functools.update_wrapper.\"\"\"\n    for replace in ['__module__', '__name__', '__qualname__', '__doc__']:\n        if hasattr(old, replace):\n            setattr(new, replace, getattr(old, replace))\n    new.__dict__.update(old.__dict__)\ndef _new_module(name):",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "_bootstrap_external",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "_bootstrap_external = None\ndef _wrap(new, old):\n    \"\"\"Simple substitute for functools.update_wrapper.\"\"\"\n    for replace in ['__module__', '__name__', '__qualname__', '__doc__']:\n        if hasattr(old, replace):\n            setattr(new, replace, getattr(old, replace))\n    new.__dict__.update(old.__dict__)\ndef _new_module(name):\n    return type(sys)(name)\n# Module-level locking ########################################################",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "_module_locks",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "_module_locks = {}\n# A dict mapping thread IDs to weakref'ed lists of _ModuleLock instances.\n# This maps a thread to the module locks it is blocking on acquiring.  The\n# values are lists because a single thread could perform a re-entrant import\n# and be \"in the process\" of blocking on locks for more than one module.  A\n# thread can be \"in the process\" because a thread cannot actually block on\n# acquiring more than one lock but it can have set up bookkeeping that reflects\n# that it intends to block on acquiring more than one lock.\n#\n# The dictionary uses a WeakValueDictionary to avoid keeping unnecessary",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "_blocking_on",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "_blocking_on = None\nclass _BlockingOnManager:\n    \"\"\"A context manager responsible to updating ``_blocking_on``.\"\"\"\n    def __init__(self, thread_id, lock):\n        self.thread_id = thread_id\n        self.lock = lock\n    def __enter__(self):\n        \"\"\"Mark the running thread as waiting for self.lock. via _blocking_on.\"\"\"\n        # Interactions with _blocking_on are *not* protected by the global\n        # import lock here because each thread only touches the state that it",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "_ERR_MSG_PREFIX",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "_ERR_MSG_PREFIX = 'No module named '\n_ERR_MSG = _ERR_MSG_PREFIX + '{!r}'\ndef _find_and_load_unlocked(name, import_):\n    path = None\n    parent = name.rpartition('.')[0]\n    parent_spec = None\n    if parent:\n        if parent not in sys.modules:\n            _call_with_frames_removed(import_, parent)\n        # Crazy side-effects!",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "_ERR_MSG",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "_ERR_MSG = _ERR_MSG_PREFIX + '{!r}'\ndef _find_and_load_unlocked(name, import_):\n    path = None\n    parent = name.rpartition('.')[0]\n    parent_spec = None\n    if parent:\n        if parent not in sys.modules:\n            _call_with_frames_removed(import_, parent)\n        # Crazy side-effects!\n        if name in sys.modules:",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "_NEEDS_LOADING",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap",
        "description": "pycharm_venv.Lib.importlib._bootstrap",
        "peekOfCode": "_NEEDS_LOADING = object()\ndef _find_and_load(name, import_):\n    \"\"\"Find and load the module.\"\"\"\n    # Optimization: we avoid unneeded module locking if the module\n    # already exists in sys.modules and is fully initialized.\n    module = sys.modules.get(name, _NEEDS_LOADING)\n    if (module is _NEEDS_LOADING or\n        getattr(getattr(module, \"__spec__\", None), \"_initializing\", False)):\n        with _ModuleLockManager(name):\n            module = sys.modules.get(name, _NEEDS_LOADING)",
        "detail": "pycharm_venv.Lib.importlib._bootstrap",
        "documentation": {}
    },
    {
        "label": "WindowsRegistryFinder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "class WindowsRegistryFinder:\n    \"\"\"Meta path finder for modules declared in the Windows registry.\"\"\"\n    REGISTRY_KEY = (\n        'Software\\\\Python\\\\PythonCore\\\\{sys_version}'\n        '\\\\Modules\\\\{fullname}')\n    REGISTRY_KEY_DEBUG = (\n        'Software\\\\Python\\\\PythonCore\\\\{sys_version}'\n        '\\\\Modules\\\\{fullname}\\\\Debug')\n    DEBUG_BUILD = (_MS_WINDOWS and '_d.pyd' in EXTENSION_SUFFIXES)\n    @staticmethod",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "_LoaderBasics",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "class _LoaderBasics:\n    \"\"\"Base class of common code needed by both SourceLoader and\n    SourcelessFileLoader.\"\"\"\n    def is_package(self, fullname):\n        \"\"\"Concrete implementation of InspectLoader.is_package by checking if\n        the path returned by get_filename has a filename of '__init__.py'.\"\"\"\n        filename = _path_split(self.get_filename(fullname))[1]\n        filename_base = filename.rsplit('.', 1)[0]\n        tail_name = fullname.rpartition('.')[2]\n        return filename_base == '__init__' and tail_name != '__init__'",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "SourceLoader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "class SourceLoader(_LoaderBasics):\n    def path_mtime(self, path):\n        \"\"\"Optional method that returns the modification time (an int) for the\n        specified path (a str).\n        Raises OSError when the path cannot be handled.\n        \"\"\"\n        raise OSError\n    def path_stats(self, path):\n        \"\"\"Optional method returning a metadata dict for the specified\n        path (a str).",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "FileLoader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "class FileLoader:\n    \"\"\"Base file loader class which implements the loader protocol methods that\n    require file system usage.\"\"\"\n    def __init__(self, fullname, path):\n        \"\"\"Cache the module name and the path to the file found by the\n        finder.\"\"\"\n        self.name = fullname\n        self.path = path\n    def __eq__(self, other):\n        return (self.__class__ == other.__class__ and",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "SourceFileLoader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "class SourceFileLoader(FileLoader, SourceLoader):\n    \"\"\"Concrete implementation of SourceLoader using the file system.\"\"\"\n    def path_stats(self, path):\n        \"\"\"Return the metadata for the path.\"\"\"\n        st = _path_stat(path)\n        return {'mtime': st.st_mtime, 'size': st.st_size}\n    def _cache_bytecode(self, source_path, bytecode_path, data):\n        # Adapt between the two APIs\n        mode = _calc_mode(source_path)\n        return self.set_data(bytecode_path, data, _mode=mode)",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "SourcelessFileLoader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "class SourcelessFileLoader(FileLoader, _LoaderBasics):\n    \"\"\"Loader which handles sourceless file imports.\"\"\"\n    def get_code(self, fullname):\n        path = self.get_filename(fullname)\n        data = self.get_data(path)\n        # Call _classify_pyc to do basic validation of the pyc but ignore the\n        # result. There's no source to check against.\n        exc_details = {\n            'name': fullname,\n            'path': path,",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "ExtensionFileLoader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "class ExtensionFileLoader(FileLoader, _LoaderBasics):\n    \"\"\"Loader for extension modules.\n    The constructor is designed to work with FileFinder.\n    \"\"\"\n    def __init__(self, name, path):\n        self.name = name\n        self.path = path\n    def __eq__(self, other):\n        return (self.__class__ == other.__class__ and\n                self.__dict__ == other.__dict__)",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "_NamespacePath",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "class _NamespacePath:\n    \"\"\"Represents a namespace package's path.  It uses the module name\n    to find its parent module, and from there it looks up the parent's\n    __path__.  When this changes, the module's own path is recomputed,\n    using path_finder.  For top-level modules, the parent module's path\n    is sys.path.\"\"\"\n    # When invalidate_caches() is called, this epoch is incremented\n    # https://bugs.python.org/issue45703\n    _epoch = 0\n    def __init__(self, name, path, path_finder):",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "NamespaceLoader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "class NamespaceLoader:\n    def __init__(self, name, path, path_finder):\n        self._path = _NamespacePath(name, path, path_finder)\n    def is_package(self, fullname):\n        return True\n    def get_source(self, fullname):\n        return ''\n    def get_code(self, fullname):\n        return compile('', '<string>', 'exec', dont_inherit=True)\n    def create_module(self, spec):",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "PathFinder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "class PathFinder:\n    \"\"\"Meta path finder for sys.path and package __path__ attributes.\"\"\"\n    @staticmethod\n    def invalidate_caches():\n        \"\"\"Call the invalidate_caches() method on all path entry finders\n        stored in sys.path_importer_cache (where implemented).\"\"\"\n        for name, finder in list(sys.path_importer_cache.items()):\n            # Drop entry if finder name is a relative path. The current\n            # working directory may have changed.\n            if finder is None or not _path_isabs(name):",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "FileFinder",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "class FileFinder:\n    \"\"\"File-based finder.\n    Interactions with the file system are cached for performance, being\n    refreshed when the directory the finder is handling has been modified.\n    \"\"\"\n    def __init__(self, path, *loader_details):\n        \"\"\"Initialize with the path to search on and a variable number of\n        2-tuples containing the loader and the file suffixes the loader\n        recognizes.\"\"\"\n        loaders = []",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "AppleFrameworkLoader",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "class AppleFrameworkLoader(ExtensionFileLoader):\n    \"\"\"A loader for modules that have been packaged as frameworks for\n    compatibility with Apple's iOS App Store policies.\n    \"\"\"\n    def create_module(self, spec):\n        # If the ModuleSpec has been created by the FileFinder, it will have\n        # been created with an origin pointing to the .fwork file. We need to\n        # redirect this to the location in the Frameworks folder, using the\n        # content of the .fwork file.\n        if spec.origin.endswith(\".fwork\"):",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "cache_from_source",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "def cache_from_source(path, debug_override=None, *, optimization=None):\n    \"\"\"Given the path to a .py file, return the path to its .pyc file.\n    The .py file does not need to exist; this simply returns the path to the\n    .pyc file calculated as if the .py file were imported.\n    The 'optimization' parameter controls the presumed optimization level of\n    the bytecode file. If 'optimization' is not None, the string representation\n    of the argument is taken and verified to be alphanumeric (else ValueError\n    is raised).\n    The debug_override parameter is deprecated. If debug_override is not None,\n    a True value is the same as setting 'optimization' to the empty string",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "source_from_cache",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "def source_from_cache(path):\n    \"\"\"Given the path to a .pyc. file, return the path to its .py file.\n    The .pyc file does not need to exist; this simply returns the path to\n    the .py file calculated to correspond to the .pyc file.  If path does\n    not conform to PEP 3147/488 format, ValueError will be raised. If\n    sys.implementation.cache_tag is None then NotImplementedError is raised.\n    \"\"\"\n    if sys.implementation.cache_tag is None:\n        raise NotImplementedError('sys.implementation.cache_tag is None')\n    path = _os.fspath(path)",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "decode_source",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "def decode_source(source_bytes):\n    \"\"\"Decode bytes representing source code and return the string.\n    Universal newline support is used in the decoding.\n    \"\"\"\n    import tokenize  # To avoid bootstrap issues.\n    source_bytes_readline = _io.BytesIO(source_bytes).readline\n    encoding = tokenize.detect_encoding(source_bytes_readline)\n    newline_decoder = _io.IncrementalNewlineDecoder(None, True)\n    return newline_decoder.decode(source_bytes.decode(encoding[0]))\n# Module specifications #######################################################",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "spec_from_file_location",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "def spec_from_file_location(name, location=None, *, loader=None,\n                            submodule_search_locations=_POPULATE):\n    \"\"\"Return a module spec based on a file location.\n    To indicate that the module is a package, set\n    submodule_search_locations to a list of directory paths.  An\n    empty list is sufficient, though its not otherwise useful to the\n    import system.\n    The loader must take a spec as its only __init__() arg.\n    \"\"\"\n    if location is None:",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "_bootstrap",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "_bootstrap = None\n# Import builtin modules\nimport _imp\nimport _io\nimport sys\nimport _warnings\nimport marshal\n_MS_WINDOWS = (sys.platform == 'win32')\nif _MS_WINDOWS:\n    import nt as _os",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "_MS_WINDOWS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "_MS_WINDOWS = (sys.platform == 'win32')\nif _MS_WINDOWS:\n    import nt as _os\n    import winreg\nelse:\n    import posix as _os\nif _MS_WINDOWS:\n    path_separators = ['\\\\', '/']\nelse:\n    path_separators = ['/']",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "path_sep",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "path_sep = path_separators[0]\npath_sep_tuple = tuple(path_separators)\npath_separators = ''.join(path_separators)\n_pathseps_with_colon = {f':{s}' for s in path_separators}\n# Bootstrap-related code ######################################################\n_CASE_INSENSITIVE_PLATFORMS_STR_KEY = 'win',\n_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY = 'cygwin', 'darwin', 'ios', 'tvos', 'watchos'\n_CASE_INSENSITIVE_PLATFORMS =  (_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY\n                                + _CASE_INSENSITIVE_PLATFORMS_STR_KEY)\ndef _make_relax_case():",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "path_sep_tuple",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "path_sep_tuple = tuple(path_separators)\npath_separators = ''.join(path_separators)\n_pathseps_with_colon = {f':{s}' for s in path_separators}\n# Bootstrap-related code ######################################################\n_CASE_INSENSITIVE_PLATFORMS_STR_KEY = 'win',\n_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY = 'cygwin', 'darwin', 'ios', 'tvos', 'watchos'\n_CASE_INSENSITIVE_PLATFORMS =  (_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY\n                                + _CASE_INSENSITIVE_PLATFORMS_STR_KEY)\ndef _make_relax_case():\n    if sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS):",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "path_separators",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "path_separators = ''.join(path_separators)\n_pathseps_with_colon = {f':{s}' for s in path_separators}\n# Bootstrap-related code ######################################################\n_CASE_INSENSITIVE_PLATFORMS_STR_KEY = 'win',\n_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY = 'cygwin', 'darwin', 'ios', 'tvos', 'watchos'\n_CASE_INSENSITIVE_PLATFORMS =  (_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY\n                                + _CASE_INSENSITIVE_PLATFORMS_STR_KEY)\ndef _make_relax_case():\n    if sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS):\n        if sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS_STR_KEY):",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "_pathseps_with_colon",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "_pathseps_with_colon = {f':{s}' for s in path_separators}\n# Bootstrap-related code ######################################################\n_CASE_INSENSITIVE_PLATFORMS_STR_KEY = 'win',\n_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY = 'cygwin', 'darwin', 'ios', 'tvos', 'watchos'\n_CASE_INSENSITIVE_PLATFORMS =  (_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY\n                                + _CASE_INSENSITIVE_PLATFORMS_STR_KEY)\ndef _make_relax_case():\n    if sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS):\n        if sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS_STR_KEY):\n            key = 'PYTHONCASEOK'",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "_CASE_INSENSITIVE_PLATFORMS_STR_KEY",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "_CASE_INSENSITIVE_PLATFORMS_STR_KEY = 'win',\n_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY = 'cygwin', 'darwin', 'ios', 'tvos', 'watchos'\n_CASE_INSENSITIVE_PLATFORMS =  (_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY\n                                + _CASE_INSENSITIVE_PLATFORMS_STR_KEY)\ndef _make_relax_case():\n    if sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS):\n        if sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS_STR_KEY):\n            key = 'PYTHONCASEOK'\n        else:\n            key = b'PYTHONCASEOK'",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY = 'cygwin', 'darwin', 'ios', 'tvos', 'watchos'\n_CASE_INSENSITIVE_PLATFORMS =  (_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY\n                                + _CASE_INSENSITIVE_PLATFORMS_STR_KEY)\ndef _make_relax_case():\n    if sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS):\n        if sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS_STR_KEY):\n            key = 'PYTHONCASEOK'\n        else:\n            key = b'PYTHONCASEOK'\n        def _relax_case():",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "_CASE_INSENSITIVE_PLATFORMS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "_CASE_INSENSITIVE_PLATFORMS =  (_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY\n                                + _CASE_INSENSITIVE_PLATFORMS_STR_KEY)\ndef _make_relax_case():\n    if sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS):\n        if sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS_STR_KEY):\n            key = 'PYTHONCASEOK'\n        else:\n            key = b'PYTHONCASEOK'\n        def _relax_case():\n            \"\"\"True if filenames must be checked case-insensitively and ignore environment flags are not set.\"\"\"",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "_relax_case",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "_relax_case = _make_relax_case()\ndef _pack_uint32(x):\n    \"\"\"Convert a 32-bit integer to little-endian.\"\"\"\n    return (int(x) & 0xFFFFFFFF).to_bytes(4, 'little')\ndef _unpack_uint64(data):\n    \"\"\"Convert 8 bytes in little-endian to an integer.\"\"\"\n    assert len(data) == 8\n    return int.from_bytes(data, 'little')\ndef _unpack_uint32(data):\n    \"\"\"Convert 4 bytes in little-endian to an integer.\"\"\"",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "_code_type",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "_code_type = type(_write_atomic.__code__)\n# Finder/loader utility code ###############################################\n# Magic word to reject .pyc files generated by other Python versions.\n# It should change for each incompatible change to the bytecode.\n#\n# The value of CR and LF is incorporated so if you ever read or write\n# a .pyc file in text mode the magic number will be wrong; also, the\n# Apple MPW compiler swaps their values, botching string constants.\n#\n# There were a variety of old schemes for setting the magic number.",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "MAGIC_NUMBER",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "MAGIC_NUMBER = (3571).to_bytes(2, 'little') + b'\\r\\n'\n_RAW_MAGIC_NUMBER = int.from_bytes(MAGIC_NUMBER, 'little')  # For import.c\n_PYCACHE = '__pycache__'\n_OPT = 'opt-'\nSOURCE_SUFFIXES = ['.py']\nif _MS_WINDOWS:\n    SOURCE_SUFFIXES.append('.pyw')\nEXTENSION_SUFFIXES = _imp.extension_suffixes()\nBYTECODE_SUFFIXES = ['.pyc']\n# Deprecated.",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "_RAW_MAGIC_NUMBER",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "_RAW_MAGIC_NUMBER = int.from_bytes(MAGIC_NUMBER, 'little')  # For import.c\n_PYCACHE = '__pycache__'\n_OPT = 'opt-'\nSOURCE_SUFFIXES = ['.py']\nif _MS_WINDOWS:\n    SOURCE_SUFFIXES.append('.pyw')\nEXTENSION_SUFFIXES = _imp.extension_suffixes()\nBYTECODE_SUFFIXES = ['.pyc']\n# Deprecated.\nDEBUG_BYTECODE_SUFFIXES = OPTIMIZED_BYTECODE_SUFFIXES = BYTECODE_SUFFIXES",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "_PYCACHE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "_PYCACHE = '__pycache__'\n_OPT = 'opt-'\nSOURCE_SUFFIXES = ['.py']\nif _MS_WINDOWS:\n    SOURCE_SUFFIXES.append('.pyw')\nEXTENSION_SUFFIXES = _imp.extension_suffixes()\nBYTECODE_SUFFIXES = ['.pyc']\n# Deprecated.\nDEBUG_BYTECODE_SUFFIXES = OPTIMIZED_BYTECODE_SUFFIXES = BYTECODE_SUFFIXES\ndef cache_from_source(path, debug_override=None, *, optimization=None):",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "_OPT",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "_OPT = 'opt-'\nSOURCE_SUFFIXES = ['.py']\nif _MS_WINDOWS:\n    SOURCE_SUFFIXES.append('.pyw')\nEXTENSION_SUFFIXES = _imp.extension_suffixes()\nBYTECODE_SUFFIXES = ['.pyc']\n# Deprecated.\nDEBUG_BYTECODE_SUFFIXES = OPTIMIZED_BYTECODE_SUFFIXES = BYTECODE_SUFFIXES\ndef cache_from_source(path, debug_override=None, *, optimization=None):\n    \"\"\"Given the path to a .py file, return the path to its .pyc file.",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "SOURCE_SUFFIXES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "SOURCE_SUFFIXES = ['.py']\nif _MS_WINDOWS:\n    SOURCE_SUFFIXES.append('.pyw')\nEXTENSION_SUFFIXES = _imp.extension_suffixes()\nBYTECODE_SUFFIXES = ['.pyc']\n# Deprecated.\nDEBUG_BYTECODE_SUFFIXES = OPTIMIZED_BYTECODE_SUFFIXES = BYTECODE_SUFFIXES\ndef cache_from_source(path, debug_override=None, *, optimization=None):\n    \"\"\"Given the path to a .py file, return the path to its .pyc file.\n    The .py file does not need to exist; this simply returns the path to the",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "EXTENSION_SUFFIXES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "EXTENSION_SUFFIXES = _imp.extension_suffixes()\nBYTECODE_SUFFIXES = ['.pyc']\n# Deprecated.\nDEBUG_BYTECODE_SUFFIXES = OPTIMIZED_BYTECODE_SUFFIXES = BYTECODE_SUFFIXES\ndef cache_from_source(path, debug_override=None, *, optimization=None):\n    \"\"\"Given the path to a .py file, return the path to its .pyc file.\n    The .py file does not need to exist; this simply returns the path to the\n    .pyc file calculated as if the .py file were imported.\n    The 'optimization' parameter controls the presumed optimization level of\n    the bytecode file. If 'optimization' is not None, the string representation",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "BYTECODE_SUFFIXES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "BYTECODE_SUFFIXES = ['.pyc']\n# Deprecated.\nDEBUG_BYTECODE_SUFFIXES = OPTIMIZED_BYTECODE_SUFFIXES = BYTECODE_SUFFIXES\ndef cache_from_source(path, debug_override=None, *, optimization=None):\n    \"\"\"Given the path to a .py file, return the path to its .pyc file.\n    The .py file does not need to exist; this simply returns the path to the\n    .pyc file calculated as if the .py file were imported.\n    The 'optimization' parameter controls the presumed optimization level of\n    the bytecode file. If 'optimization' is not None, the string representation\n    of the argument is taken and verified to be alphanumeric (else ValueError",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "DEBUG_BYTECODE_SUFFIXES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "DEBUG_BYTECODE_SUFFIXES = OPTIMIZED_BYTECODE_SUFFIXES = BYTECODE_SUFFIXES\ndef cache_from_source(path, debug_override=None, *, optimization=None):\n    \"\"\"Given the path to a .py file, return the path to its .pyc file.\n    The .py file does not need to exist; this simply returns the path to the\n    .pyc file calculated as if the .py file were imported.\n    The 'optimization' parameter controls the presumed optimization level of\n    the bytecode file. If 'optimization' is not None, the string representation\n    of the argument is taken and verified to be alphanumeric (else ValueError\n    is raised).\n    The debug_override parameter is deprecated. If debug_override is not None,",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "_POPULATE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "_POPULATE = object()\ndef spec_from_file_location(name, location=None, *, loader=None,\n                            submodule_search_locations=_POPULATE):\n    \"\"\"Return a module spec based on a file location.\n    To indicate that the module is a package, set\n    submodule_search_locations to a list of directory paths.  An\n    empty list is sufficient, though its not otherwise useful to the\n    import system.\n    The loader must take a spec as its only __init__() arg.\n    \"\"\"",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "_NamespaceLoader",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.importlib._bootstrap_external",
        "description": "pycharm_venv.Lib.importlib._bootstrap_external",
        "peekOfCode": "_NamespaceLoader = NamespaceLoader\n# Finders #####################################################################\nclass PathFinder:\n    \"\"\"Meta path finder for sys.path and package __path__ attributes.\"\"\"\n    @staticmethod\n    def invalidate_caches():\n        \"\"\"Call the invalidate_caches() method on all path entry finders\n        stored in sys.path_importer_cache (where implemented).\"\"\"\n        for name, finder in list(sys.path_importer_cache.items()):\n            # Drop entry if finder name is a relative path. The current",
        "detail": "pycharm_venv.Lib.importlib._bootstrap_external",
        "documentation": {}
    },
    {
        "label": "_EXTRA_CASES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._casefix",
        "description": "pycharm_venv.Lib.re._casefix",
        "peekOfCode": "_EXTRA_CASES = {\n    # LATIN SMALL LETTER I: LATIN SMALL LETTER DOTLESS I\n    0x0069: (0x0131,), # 'i': ''\n    # LATIN SMALL LETTER S: LATIN SMALL LETTER LONG S\n    0x0073: (0x017f,), # 's': ''\n    # MICRO SIGN: GREEK SMALL LETTER MU\n    0x00b5: (0x03bc,), # '': ''\n    # LATIN SMALL LETTER DOTLESS I: LATIN SMALL LETTER I\n    0x0131: (0x0069,), # '': 'i'\n    # LATIN SMALL LETTER LONG S: LATIN SMALL LETTER S",
        "detail": "pycharm_venv.Lib.re._casefix",
        "documentation": {}
    },
    {
        "label": "isstring",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.re._compiler",
        "description": "pycharm_venv.Lib.re._compiler",
        "peekOfCode": "def isstring(obj):\n    return isinstance(obj, (str, bytes))\ndef _code(p, flags):\n    flags = p.state.flags | flags\n    code = []\n    # compile info block\n    _compile_info(code, p, flags)\n    # compile the pattern\n    _compile(code, p.data, flags)\n    code.append(SUCCESS)",
        "detail": "pycharm_venv.Lib.re._compiler",
        "documentation": {}
    },
    {
        "label": "dis",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.re._compiler",
        "description": "pycharm_venv.Lib.re._compiler",
        "peekOfCode": "def dis(code):\n    import sys\n    labels = set()\n    level = 0\n    offset_width = len(str(len(code) - 1))\n    def dis_(start, end):\n        def print_(*args, to=None):\n            if to is not None:\n                labels.add(to)\n                args += ('(to %d)' % (to,),)",
        "detail": "pycharm_venv.Lib.re._compiler",
        "documentation": {}
    },
    {
        "label": "compile",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.re._compiler",
        "description": "pycharm_venv.Lib.re._compiler",
        "peekOfCode": "def compile(p, flags=0):\n    # internal: convert pattern list to internal format\n    if isstring(p):\n        pattern = p\n        p = _parser.parse(p, flags)\n    else:\n        pattern = None\n    code = _code(p, flags)\n    if flags & SRE_FLAG_DEBUG:\n        print()",
        "detail": "pycharm_venv.Lib.re._compiler",
        "documentation": {}
    },
    {
        "label": "_LITERAL_CODES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._compiler",
        "description": "pycharm_venv.Lib.re._compiler",
        "peekOfCode": "_LITERAL_CODES = {LITERAL, NOT_LITERAL}\n_SUCCESS_CODES = {SUCCESS, FAILURE}\n_ASSERT_CODES = {ASSERT, ASSERT_NOT}\n_UNIT_CODES = _LITERAL_CODES | {ANY, IN}\n_REPEATING_CODES = {\n    MIN_REPEAT: (REPEAT, MIN_UNTIL, MIN_REPEAT_ONE),\n    MAX_REPEAT: (REPEAT, MAX_UNTIL, REPEAT_ONE),\n    POSSESSIVE_REPEAT: (POSSESSIVE_REPEAT, SUCCESS, POSSESSIVE_REPEAT_ONE),\n}\ndef _combine_flags(flags, add_flags, del_flags,",
        "detail": "pycharm_venv.Lib.re._compiler",
        "documentation": {}
    },
    {
        "label": "_SUCCESS_CODES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._compiler",
        "description": "pycharm_venv.Lib.re._compiler",
        "peekOfCode": "_SUCCESS_CODES = {SUCCESS, FAILURE}\n_ASSERT_CODES = {ASSERT, ASSERT_NOT}\n_UNIT_CODES = _LITERAL_CODES | {ANY, IN}\n_REPEATING_CODES = {\n    MIN_REPEAT: (REPEAT, MIN_UNTIL, MIN_REPEAT_ONE),\n    MAX_REPEAT: (REPEAT, MAX_UNTIL, REPEAT_ONE),\n    POSSESSIVE_REPEAT: (POSSESSIVE_REPEAT, SUCCESS, POSSESSIVE_REPEAT_ONE),\n}\ndef _combine_flags(flags, add_flags, del_flags,\n                   TYPE_FLAGS=_parser.TYPE_FLAGS):",
        "detail": "pycharm_venv.Lib.re._compiler",
        "documentation": {}
    },
    {
        "label": "_ASSERT_CODES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._compiler",
        "description": "pycharm_venv.Lib.re._compiler",
        "peekOfCode": "_ASSERT_CODES = {ASSERT, ASSERT_NOT}\n_UNIT_CODES = _LITERAL_CODES | {ANY, IN}\n_REPEATING_CODES = {\n    MIN_REPEAT: (REPEAT, MIN_UNTIL, MIN_REPEAT_ONE),\n    MAX_REPEAT: (REPEAT, MAX_UNTIL, REPEAT_ONE),\n    POSSESSIVE_REPEAT: (POSSESSIVE_REPEAT, SUCCESS, POSSESSIVE_REPEAT_ONE),\n}\ndef _combine_flags(flags, add_flags, del_flags,\n                   TYPE_FLAGS=_parser.TYPE_FLAGS):\n    if add_flags & TYPE_FLAGS:",
        "detail": "pycharm_venv.Lib.re._compiler",
        "documentation": {}
    },
    {
        "label": "_UNIT_CODES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._compiler",
        "description": "pycharm_venv.Lib.re._compiler",
        "peekOfCode": "_UNIT_CODES = _LITERAL_CODES | {ANY, IN}\n_REPEATING_CODES = {\n    MIN_REPEAT: (REPEAT, MIN_UNTIL, MIN_REPEAT_ONE),\n    MAX_REPEAT: (REPEAT, MAX_UNTIL, REPEAT_ONE),\n    POSSESSIVE_REPEAT: (POSSESSIVE_REPEAT, SUCCESS, POSSESSIVE_REPEAT_ONE),\n}\ndef _combine_flags(flags, add_flags, del_flags,\n                   TYPE_FLAGS=_parser.TYPE_FLAGS):\n    if add_flags & TYPE_FLAGS:\n        flags &= ~TYPE_FLAGS",
        "detail": "pycharm_venv.Lib.re._compiler",
        "documentation": {}
    },
    {
        "label": "_REPEATING_CODES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._compiler",
        "description": "pycharm_venv.Lib.re._compiler",
        "peekOfCode": "_REPEATING_CODES = {\n    MIN_REPEAT: (REPEAT, MIN_UNTIL, MIN_REPEAT_ONE),\n    MAX_REPEAT: (REPEAT, MAX_UNTIL, REPEAT_ONE),\n    POSSESSIVE_REPEAT: (POSSESSIVE_REPEAT, SUCCESS, POSSESSIVE_REPEAT_ONE),\n}\ndef _combine_flags(flags, add_flags, del_flags,\n                   TYPE_FLAGS=_parser.TYPE_FLAGS):\n    if add_flags & TYPE_FLAGS:\n        flags &= ~TYPE_FLAGS\n    return (flags | add_flags) & ~del_flags",
        "detail": "pycharm_venv.Lib.re._compiler",
        "documentation": {}
    },
    {
        "label": "_CODEBITS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._compiler",
        "description": "pycharm_venv.Lib.re._compiler",
        "peekOfCode": "_CODEBITS = _sre.CODESIZE * 8\nMAXCODE = (1 << _CODEBITS) - 1\n_BITS_TRANS = b'0' + b'1' * 255\ndef _mk_bitmap(bits, _CODEBITS=_CODEBITS, _int=int):\n    s = bits.translate(_BITS_TRANS)[::-1]\n    return [_int(s[i - _CODEBITS: i], 2)\n            for i in range(len(s), 0, -_CODEBITS)]\ndef _bytes_to_codes(b):\n    # Convert block indices to word array\n    a = memoryview(b).cast('I')",
        "detail": "pycharm_venv.Lib.re._compiler",
        "documentation": {}
    },
    {
        "label": "MAXCODE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._compiler",
        "description": "pycharm_venv.Lib.re._compiler",
        "peekOfCode": "MAXCODE = (1 << _CODEBITS) - 1\n_BITS_TRANS = b'0' + b'1' * 255\ndef _mk_bitmap(bits, _CODEBITS=_CODEBITS, _int=int):\n    s = bits.translate(_BITS_TRANS)[::-1]\n    return [_int(s[i - _CODEBITS: i], 2)\n            for i in range(len(s), 0, -_CODEBITS)]\ndef _bytes_to_codes(b):\n    # Convert block indices to word array\n    a = memoryview(b).cast('I')\n    assert a.itemsize == _sre.CODESIZE",
        "detail": "pycharm_venv.Lib.re._compiler",
        "documentation": {}
    },
    {
        "label": "_BITS_TRANS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._compiler",
        "description": "pycharm_venv.Lib.re._compiler",
        "peekOfCode": "_BITS_TRANS = b'0' + b'1' * 255\ndef _mk_bitmap(bits, _CODEBITS=_CODEBITS, _int=int):\n    s = bits.translate(_BITS_TRANS)[::-1]\n    return [_int(s[i - _CODEBITS: i], 2)\n            for i in range(len(s), 0, -_CODEBITS)]\ndef _bytes_to_codes(b):\n    # Convert block indices to word array\n    a = memoryview(b).cast('I')\n    assert a.itemsize == _sre.CODESIZE\n    assert len(a) * a.itemsize == len(b)",
        "detail": "pycharm_venv.Lib.re._compiler",
        "documentation": {}
    },
    {
        "label": "PatternError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "class PatternError(Exception):\n    \"\"\"Exception raised for invalid regular expressions.\n    Attributes:\n        msg: The unformatted error message\n        pattern: The regular expression pattern\n        pos: The index in the pattern where compilation failed (may be None)\n        lineno: The line corresponding to pos (may be None)\n        colno: The column corresponding to pos (may be None)\n    \"\"\"\n    __module__ = 're'",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "_NamedIntConstant",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "class _NamedIntConstant(int):\n    def __new__(cls, value, name):\n        self = super(_NamedIntConstant, cls).__new__(cls, value)\n        self.name = name\n        return self\n    def __repr__(self):\n        return self.name\n    __reduce__ = None\nMAXREPEAT = _NamedIntConstant(MAXREPEAT, 'MAXREPEAT')\ndef _makecodes(*names):",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "MAGIC",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "MAGIC = 20230612\nfrom _sre import MAXREPEAT, MAXGROUPS\n# SRE standard exception (access as sre.error)\n# should this really be here?\nclass PatternError(Exception):\n    \"\"\"Exception raised for invalid regular expressions.\n    Attributes:\n        msg: The unformatted error message\n        pattern: The regular expression pattern\n        pos: The index in the pattern where compilation failed (may be None)",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "error",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "error = PatternError\nclass _NamedIntConstant(int):\n    def __new__(cls, value, name):\n        self = super(_NamedIntConstant, cls).__new__(cls, value)\n        self.name = name\n        return self\n    def __repr__(self):\n        return self.name\n    __reduce__ = None\nMAXREPEAT = _NamedIntConstant(MAXREPEAT, 'MAXREPEAT')",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "MAXREPEAT",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "MAXREPEAT = _NamedIntConstant(MAXREPEAT, 'MAXREPEAT')\ndef _makecodes(*names):\n    items = [_NamedIntConstant(i, name) for i, name in enumerate(names)]\n    globals().update({item.name: item for item in items})\n    return items\n# operators\nOPCODES = _makecodes(\n    # failure=0 success=1 (just because it looks better that way :-)\n    'FAILURE', 'SUCCESS',\n    'ANY', 'ANY_ALL',",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "OPCODES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "OPCODES = _makecodes(\n    # failure=0 success=1 (just because it looks better that way :-)\n    'FAILURE', 'SUCCESS',\n    'ANY', 'ANY_ALL',\n    'ASSERT', 'ASSERT_NOT',\n    'AT',\n    'BRANCH',\n    'CATEGORY',\n    'CHARSET', 'BIGCHARSET',\n    'GROUPREF', 'GROUPREF_EXISTS',",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "ATCODES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "ATCODES = _makecodes(\n    'AT_BEGINNING', 'AT_BEGINNING_LINE', 'AT_BEGINNING_STRING',\n    'AT_BOUNDARY', 'AT_NON_BOUNDARY',\n    'AT_END', 'AT_END_LINE', 'AT_END_STRING',\n    'AT_LOC_BOUNDARY', 'AT_LOC_NON_BOUNDARY',\n    'AT_UNI_BOUNDARY', 'AT_UNI_NON_BOUNDARY',\n)\n# categories\nCHCODES = _makecodes(\n    'CATEGORY_DIGIT', 'CATEGORY_NOT_DIGIT',",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "CHCODES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "CHCODES = _makecodes(\n    'CATEGORY_DIGIT', 'CATEGORY_NOT_DIGIT',\n    'CATEGORY_SPACE', 'CATEGORY_NOT_SPACE',\n    'CATEGORY_WORD', 'CATEGORY_NOT_WORD',\n    'CATEGORY_LINEBREAK', 'CATEGORY_NOT_LINEBREAK',\n    'CATEGORY_LOC_WORD', 'CATEGORY_LOC_NOT_WORD',\n    'CATEGORY_UNI_DIGIT', 'CATEGORY_UNI_NOT_DIGIT',\n    'CATEGORY_UNI_SPACE', 'CATEGORY_UNI_NOT_SPACE',\n    'CATEGORY_UNI_WORD', 'CATEGORY_UNI_NOT_WORD',\n    'CATEGORY_UNI_LINEBREAK', 'CATEGORY_UNI_NOT_LINEBREAK',",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "OP_IGNORE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "OP_IGNORE = {\n    LITERAL: LITERAL_IGNORE,\n    NOT_LITERAL: NOT_LITERAL_IGNORE,\n}\nOP_LOCALE_IGNORE = {\n    LITERAL: LITERAL_LOC_IGNORE,\n    NOT_LITERAL: NOT_LITERAL_LOC_IGNORE,\n}\nOP_UNICODE_IGNORE = {\n    LITERAL: LITERAL_UNI_IGNORE,",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "OP_LOCALE_IGNORE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "OP_LOCALE_IGNORE = {\n    LITERAL: LITERAL_LOC_IGNORE,\n    NOT_LITERAL: NOT_LITERAL_LOC_IGNORE,\n}\nOP_UNICODE_IGNORE = {\n    LITERAL: LITERAL_UNI_IGNORE,\n    NOT_LITERAL: NOT_LITERAL_UNI_IGNORE,\n}\nAT_MULTILINE = {\n    AT_BEGINNING: AT_BEGINNING_LINE,",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "OP_UNICODE_IGNORE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "OP_UNICODE_IGNORE = {\n    LITERAL: LITERAL_UNI_IGNORE,\n    NOT_LITERAL: NOT_LITERAL_UNI_IGNORE,\n}\nAT_MULTILINE = {\n    AT_BEGINNING: AT_BEGINNING_LINE,\n    AT_END: AT_END_LINE\n}\nAT_LOCALE = {\n    AT_BOUNDARY: AT_LOC_BOUNDARY,",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "AT_MULTILINE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "AT_MULTILINE = {\n    AT_BEGINNING: AT_BEGINNING_LINE,\n    AT_END: AT_END_LINE\n}\nAT_LOCALE = {\n    AT_BOUNDARY: AT_LOC_BOUNDARY,\n    AT_NON_BOUNDARY: AT_LOC_NON_BOUNDARY\n}\nAT_UNICODE = {\n    AT_BOUNDARY: AT_UNI_BOUNDARY,",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "AT_LOCALE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "AT_LOCALE = {\n    AT_BOUNDARY: AT_LOC_BOUNDARY,\n    AT_NON_BOUNDARY: AT_LOC_NON_BOUNDARY\n}\nAT_UNICODE = {\n    AT_BOUNDARY: AT_UNI_BOUNDARY,\n    AT_NON_BOUNDARY: AT_UNI_NON_BOUNDARY\n}\nCH_LOCALE = {\n    CATEGORY_DIGIT: CATEGORY_DIGIT,",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "AT_UNICODE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "AT_UNICODE = {\n    AT_BOUNDARY: AT_UNI_BOUNDARY,\n    AT_NON_BOUNDARY: AT_UNI_NON_BOUNDARY\n}\nCH_LOCALE = {\n    CATEGORY_DIGIT: CATEGORY_DIGIT,\n    CATEGORY_NOT_DIGIT: CATEGORY_NOT_DIGIT,\n    CATEGORY_SPACE: CATEGORY_SPACE,\n    CATEGORY_NOT_SPACE: CATEGORY_NOT_SPACE,\n    CATEGORY_WORD: CATEGORY_LOC_WORD,",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "CH_LOCALE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "CH_LOCALE = {\n    CATEGORY_DIGIT: CATEGORY_DIGIT,\n    CATEGORY_NOT_DIGIT: CATEGORY_NOT_DIGIT,\n    CATEGORY_SPACE: CATEGORY_SPACE,\n    CATEGORY_NOT_SPACE: CATEGORY_NOT_SPACE,\n    CATEGORY_WORD: CATEGORY_LOC_WORD,\n    CATEGORY_NOT_WORD: CATEGORY_LOC_NOT_WORD,\n    CATEGORY_LINEBREAK: CATEGORY_LINEBREAK,\n    CATEGORY_NOT_LINEBREAK: CATEGORY_NOT_LINEBREAK\n}",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "CH_UNICODE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "CH_UNICODE = {\n    CATEGORY_DIGIT: CATEGORY_UNI_DIGIT,\n    CATEGORY_NOT_DIGIT: CATEGORY_UNI_NOT_DIGIT,\n    CATEGORY_SPACE: CATEGORY_UNI_SPACE,\n    CATEGORY_NOT_SPACE: CATEGORY_UNI_NOT_SPACE,\n    CATEGORY_WORD: CATEGORY_UNI_WORD,\n    CATEGORY_NOT_WORD: CATEGORY_UNI_NOT_WORD,\n    CATEGORY_LINEBREAK: CATEGORY_UNI_LINEBREAK,\n    CATEGORY_NOT_LINEBREAK: CATEGORY_UNI_NOT_LINEBREAK\n}",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "SRE_FLAG_IGNORECASE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "SRE_FLAG_IGNORECASE = 2 # case insensitive\nSRE_FLAG_LOCALE = 4 # honour system locale\nSRE_FLAG_MULTILINE = 8 # treat target as multiline string\nSRE_FLAG_DOTALL = 16 # treat target as a single string\nSRE_FLAG_UNICODE = 32 # use unicode \"locale\"\nSRE_FLAG_VERBOSE = 64 # ignore whitespace and comments\nSRE_FLAG_DEBUG = 128 # debugging\nSRE_FLAG_ASCII = 256 # use ascii \"locale\"\n# flags for INFO primitive\nSRE_INFO_PREFIX = 1 # has prefix",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "SRE_FLAG_LOCALE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "SRE_FLAG_LOCALE = 4 # honour system locale\nSRE_FLAG_MULTILINE = 8 # treat target as multiline string\nSRE_FLAG_DOTALL = 16 # treat target as a single string\nSRE_FLAG_UNICODE = 32 # use unicode \"locale\"\nSRE_FLAG_VERBOSE = 64 # ignore whitespace and comments\nSRE_FLAG_DEBUG = 128 # debugging\nSRE_FLAG_ASCII = 256 # use ascii \"locale\"\n# flags for INFO primitive\nSRE_INFO_PREFIX = 1 # has prefix\nSRE_INFO_LITERAL = 2 # entire pattern is literal (given by prefix)",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "SRE_FLAG_MULTILINE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "SRE_FLAG_MULTILINE = 8 # treat target as multiline string\nSRE_FLAG_DOTALL = 16 # treat target as a single string\nSRE_FLAG_UNICODE = 32 # use unicode \"locale\"\nSRE_FLAG_VERBOSE = 64 # ignore whitespace and comments\nSRE_FLAG_DEBUG = 128 # debugging\nSRE_FLAG_ASCII = 256 # use ascii \"locale\"\n# flags for INFO primitive\nSRE_INFO_PREFIX = 1 # has prefix\nSRE_INFO_LITERAL = 2 # entire pattern is literal (given by prefix)\nSRE_INFO_CHARSET = 4 # pattern starts with character from given set",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "SRE_FLAG_DOTALL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "SRE_FLAG_DOTALL = 16 # treat target as a single string\nSRE_FLAG_UNICODE = 32 # use unicode \"locale\"\nSRE_FLAG_VERBOSE = 64 # ignore whitespace and comments\nSRE_FLAG_DEBUG = 128 # debugging\nSRE_FLAG_ASCII = 256 # use ascii \"locale\"\n# flags for INFO primitive\nSRE_INFO_PREFIX = 1 # has prefix\nSRE_INFO_LITERAL = 2 # entire pattern is literal (given by prefix)\nSRE_INFO_CHARSET = 4 # pattern starts with character from given set",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "SRE_FLAG_UNICODE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "SRE_FLAG_UNICODE = 32 # use unicode \"locale\"\nSRE_FLAG_VERBOSE = 64 # ignore whitespace and comments\nSRE_FLAG_DEBUG = 128 # debugging\nSRE_FLAG_ASCII = 256 # use ascii \"locale\"\n# flags for INFO primitive\nSRE_INFO_PREFIX = 1 # has prefix\nSRE_INFO_LITERAL = 2 # entire pattern is literal (given by prefix)\nSRE_INFO_CHARSET = 4 # pattern starts with character from given set",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "SRE_FLAG_VERBOSE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "SRE_FLAG_VERBOSE = 64 # ignore whitespace and comments\nSRE_FLAG_DEBUG = 128 # debugging\nSRE_FLAG_ASCII = 256 # use ascii \"locale\"\n# flags for INFO primitive\nSRE_INFO_PREFIX = 1 # has prefix\nSRE_INFO_LITERAL = 2 # entire pattern is literal (given by prefix)\nSRE_INFO_CHARSET = 4 # pattern starts with character from given set",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "SRE_FLAG_DEBUG",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "SRE_FLAG_DEBUG = 128 # debugging\nSRE_FLAG_ASCII = 256 # use ascii \"locale\"\n# flags for INFO primitive\nSRE_INFO_PREFIX = 1 # has prefix\nSRE_INFO_LITERAL = 2 # entire pattern is literal (given by prefix)\nSRE_INFO_CHARSET = 4 # pattern starts with character from given set",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "SRE_FLAG_ASCII",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "SRE_FLAG_ASCII = 256 # use ascii \"locale\"\n# flags for INFO primitive\nSRE_INFO_PREFIX = 1 # has prefix\nSRE_INFO_LITERAL = 2 # entire pattern is literal (given by prefix)\nSRE_INFO_CHARSET = 4 # pattern starts with character from given set",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "SRE_INFO_PREFIX",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "SRE_INFO_PREFIX = 1 # has prefix\nSRE_INFO_LITERAL = 2 # entire pattern is literal (given by prefix)\nSRE_INFO_CHARSET = 4 # pattern starts with character from given set",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "SRE_INFO_LITERAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "SRE_INFO_LITERAL = 2 # entire pattern is literal (given by prefix)\nSRE_INFO_CHARSET = 4 # pattern starts with character from given set",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "SRE_INFO_CHARSET",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._constants",
        "description": "pycharm_venv.Lib.re._constants",
        "peekOfCode": "SRE_INFO_CHARSET = 4 # pattern starts with character from given set",
        "detail": "pycharm_venv.Lib.re._constants",
        "documentation": {}
    },
    {
        "label": "State",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "class State:\n    # keeps track of state for parsing\n    def __init__(self):\n        self.flags = 0\n        self.groupdict = {}\n        self.groupwidths = [None]  # group 0\n        self.lookbehindgroups = None\n        self.grouprefpos = {}\n    @property\n    def groups(self):",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "SubPattern",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "class SubPattern:\n    # a subpattern, in intermediate form\n    def __init__(self, state, data=None):\n        self.state = state\n        if data is None:\n            data = []\n        self.data = data\n        self.width = None\n    def dump(self, level=0):\n        seqtypes = (tuple, list)",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "Tokenizer",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "class Tokenizer:\n    def __init__(self, string):\n        self.istext = isinstance(string, str)\n        self.string = string\n        if not self.istext:\n            string = str(string, 'latin1')\n        self.decoded_string = string\n        self.index = 0\n        self.next = None\n        self.__next()",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "fix_flags",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "def fix_flags(src, flags):\n    # Check and fix flags according to the type of pattern (str or bytes)\n    if isinstance(src, str):\n        if flags & SRE_FLAG_LOCALE:\n            raise ValueError(\"cannot use LOCALE flag with a str pattern\")\n        if not flags & SRE_FLAG_ASCII:\n            flags |= SRE_FLAG_UNICODE\n        elif flags & SRE_FLAG_UNICODE:\n            raise ValueError(\"ASCII and UNICODE flags are incompatible\")\n    else:",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "def parse(str, flags=0, state=None):\n    # parse 're' pattern into list of (opcode, argument) tuples\n    source = Tokenizer(str)\n    if state is None:\n        state = State()\n    state.flags = flags\n    state.str = str\n    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)\n    p.state.flags = fix_flags(str, p.state.flags)\n    if source.next is not None:",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "parse_template",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "def parse_template(source, pattern):\n    # parse 're' replacement string into list of literals and\n    # group references\n    s = Tokenizer(source)\n    sget = s.get\n    result = []\n    literal = []\n    lappend = literal.append\n    def addliteral():\n        if s.istext:",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "SPECIAL_CHARS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "SPECIAL_CHARS = \".\\\\[{()*+?^$|\"\nREPEAT_CHARS = \"*+?{\"\nDIGITS = frozenset(\"0123456789\")\nOCTDIGITS = frozenset(\"01234567\")\nHEXDIGITS = frozenset(\"0123456789abcdefABCDEF\")\nASCIILETTERS = frozenset(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\nWHITESPACE = frozenset(\" \\t\\n\\r\\v\\f\")\n_REPEATCODES = frozenset({MIN_REPEAT, MAX_REPEAT, POSSESSIVE_REPEAT})\n_UNITCODES = frozenset({ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY})\nESCAPES = {",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "REPEAT_CHARS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "REPEAT_CHARS = \"*+?{\"\nDIGITS = frozenset(\"0123456789\")\nOCTDIGITS = frozenset(\"01234567\")\nHEXDIGITS = frozenset(\"0123456789abcdefABCDEF\")\nASCIILETTERS = frozenset(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\nWHITESPACE = frozenset(\" \\t\\n\\r\\v\\f\")\n_REPEATCODES = frozenset({MIN_REPEAT, MAX_REPEAT, POSSESSIVE_REPEAT})\n_UNITCODES = frozenset({ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY})\nESCAPES = {\n    r\"\\a\": (LITERAL, ord(\"\\a\")),",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "DIGITS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "DIGITS = frozenset(\"0123456789\")\nOCTDIGITS = frozenset(\"01234567\")\nHEXDIGITS = frozenset(\"0123456789abcdefABCDEF\")\nASCIILETTERS = frozenset(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\nWHITESPACE = frozenset(\" \\t\\n\\r\\v\\f\")\n_REPEATCODES = frozenset({MIN_REPEAT, MAX_REPEAT, POSSESSIVE_REPEAT})\n_UNITCODES = frozenset({ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY})\nESCAPES = {\n    r\"\\a\": (LITERAL, ord(\"\\a\")),\n    r\"\\b\": (LITERAL, ord(\"\\b\")),",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "OCTDIGITS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "OCTDIGITS = frozenset(\"01234567\")\nHEXDIGITS = frozenset(\"0123456789abcdefABCDEF\")\nASCIILETTERS = frozenset(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\nWHITESPACE = frozenset(\" \\t\\n\\r\\v\\f\")\n_REPEATCODES = frozenset({MIN_REPEAT, MAX_REPEAT, POSSESSIVE_REPEAT})\n_UNITCODES = frozenset({ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY})\nESCAPES = {\n    r\"\\a\": (LITERAL, ord(\"\\a\")),\n    r\"\\b\": (LITERAL, ord(\"\\b\")),\n    r\"\\f\": (LITERAL, ord(\"\\f\")),",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "HEXDIGITS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "HEXDIGITS = frozenset(\"0123456789abcdefABCDEF\")\nASCIILETTERS = frozenset(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\nWHITESPACE = frozenset(\" \\t\\n\\r\\v\\f\")\n_REPEATCODES = frozenset({MIN_REPEAT, MAX_REPEAT, POSSESSIVE_REPEAT})\n_UNITCODES = frozenset({ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY})\nESCAPES = {\n    r\"\\a\": (LITERAL, ord(\"\\a\")),\n    r\"\\b\": (LITERAL, ord(\"\\b\")),\n    r\"\\f\": (LITERAL, ord(\"\\f\")),\n    r\"\\n\": (LITERAL, ord(\"\\n\")),",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "ASCIILETTERS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "ASCIILETTERS = frozenset(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\nWHITESPACE = frozenset(\" \\t\\n\\r\\v\\f\")\n_REPEATCODES = frozenset({MIN_REPEAT, MAX_REPEAT, POSSESSIVE_REPEAT})\n_UNITCODES = frozenset({ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY})\nESCAPES = {\n    r\"\\a\": (LITERAL, ord(\"\\a\")),\n    r\"\\b\": (LITERAL, ord(\"\\b\")),\n    r\"\\f\": (LITERAL, ord(\"\\f\")),\n    r\"\\n\": (LITERAL, ord(\"\\n\")),\n    r\"\\r\": (LITERAL, ord(\"\\r\")),",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "WHITESPACE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "WHITESPACE = frozenset(\" \\t\\n\\r\\v\\f\")\n_REPEATCODES = frozenset({MIN_REPEAT, MAX_REPEAT, POSSESSIVE_REPEAT})\n_UNITCODES = frozenset({ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY})\nESCAPES = {\n    r\"\\a\": (LITERAL, ord(\"\\a\")),\n    r\"\\b\": (LITERAL, ord(\"\\b\")),\n    r\"\\f\": (LITERAL, ord(\"\\f\")),\n    r\"\\n\": (LITERAL, ord(\"\\n\")),\n    r\"\\r\": (LITERAL, ord(\"\\r\")),\n    r\"\\t\": (LITERAL, ord(\"\\t\")),",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "_REPEATCODES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "_REPEATCODES = frozenset({MIN_REPEAT, MAX_REPEAT, POSSESSIVE_REPEAT})\n_UNITCODES = frozenset({ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY})\nESCAPES = {\n    r\"\\a\": (LITERAL, ord(\"\\a\")),\n    r\"\\b\": (LITERAL, ord(\"\\b\")),\n    r\"\\f\": (LITERAL, ord(\"\\f\")),\n    r\"\\n\": (LITERAL, ord(\"\\n\")),\n    r\"\\r\": (LITERAL, ord(\"\\r\")),\n    r\"\\t\": (LITERAL, ord(\"\\t\")),\n    r\"\\v\": (LITERAL, ord(\"\\v\")),",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "_UNITCODES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "_UNITCODES = frozenset({ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY})\nESCAPES = {\n    r\"\\a\": (LITERAL, ord(\"\\a\")),\n    r\"\\b\": (LITERAL, ord(\"\\b\")),\n    r\"\\f\": (LITERAL, ord(\"\\f\")),\n    r\"\\n\": (LITERAL, ord(\"\\n\")),\n    r\"\\r\": (LITERAL, ord(\"\\r\")),\n    r\"\\t\": (LITERAL, ord(\"\\t\")),\n    r\"\\v\": (LITERAL, ord(\"\\v\")),\n    r\"\\\\\": (LITERAL, ord(\"\\\\\"))",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "ESCAPES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "ESCAPES = {\n    r\"\\a\": (LITERAL, ord(\"\\a\")),\n    r\"\\b\": (LITERAL, ord(\"\\b\")),\n    r\"\\f\": (LITERAL, ord(\"\\f\")),\n    r\"\\n\": (LITERAL, ord(\"\\n\")),\n    r\"\\r\": (LITERAL, ord(\"\\r\")),\n    r\"\\t\": (LITERAL, ord(\"\\t\")),\n    r\"\\v\": (LITERAL, ord(\"\\v\")),\n    r\"\\\\\": (LITERAL, ord(\"\\\\\"))\n}",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "CATEGORIES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "CATEGORIES = {\n    r\"\\A\": (AT, AT_BEGINNING_STRING), # start of string\n    r\"\\b\": (AT, AT_BOUNDARY),\n    r\"\\B\": (AT, AT_NON_BOUNDARY),\n    r\"\\d\": (IN, [(CATEGORY, CATEGORY_DIGIT)]),\n    r\"\\D\": (IN, [(CATEGORY, CATEGORY_NOT_DIGIT)]),\n    r\"\\s\": (IN, [(CATEGORY, CATEGORY_SPACE)]),\n    r\"\\S\": (IN, [(CATEGORY, CATEGORY_NOT_SPACE)]),\n    r\"\\w\": (IN, [(CATEGORY, CATEGORY_WORD)]),\n    r\"\\W\": (IN, [(CATEGORY, CATEGORY_NOT_WORD)]),",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "FLAGS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "FLAGS = {\n    # standard flags\n    \"i\": SRE_FLAG_IGNORECASE,\n    \"L\": SRE_FLAG_LOCALE,\n    \"m\": SRE_FLAG_MULTILINE,\n    \"s\": SRE_FLAG_DOTALL,\n    \"x\": SRE_FLAG_VERBOSE,\n    # extensions\n    \"a\": SRE_FLAG_ASCII,\n    \"u\": SRE_FLAG_UNICODE,",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "TYPE_FLAGS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "TYPE_FLAGS = SRE_FLAG_ASCII | SRE_FLAG_LOCALE | SRE_FLAG_UNICODE\nGLOBAL_FLAGS = SRE_FLAG_DEBUG\n# Maximal value returned by SubPattern.getwidth().\n# Must be larger than MAXREPEAT, MAXCODE and sys.maxsize.\nMAXWIDTH = 1 << 64\nclass State:\n    # keeps track of state for parsing\n    def __init__(self):\n        self.flags = 0\n        self.groupdict = {}",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "GLOBAL_FLAGS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "GLOBAL_FLAGS = SRE_FLAG_DEBUG\n# Maximal value returned by SubPattern.getwidth().\n# Must be larger than MAXREPEAT, MAXCODE and sys.maxsize.\nMAXWIDTH = 1 << 64\nclass State:\n    # keeps track of state for parsing\n    def __init__(self):\n        self.flags = 0\n        self.groupdict = {}\n        self.groupwidths = [None]  # group 0",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "MAXWIDTH",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.re._parser",
        "description": "pycharm_venv.Lib.re._parser",
        "peekOfCode": "MAXWIDTH = 1 << 64\nclass State:\n    # keeps track of state for parsing\n    def __init__(self):\n        self.flags = 0\n        self.groupdict = {}\n        self.groupwidths = [None]  # group 0\n        self.lookbehindgroups = None\n        self.grouprefpos = {}\n    @property",
        "detail": "pycharm_venv.Lib.re._parser",
        "documentation": {}
    },
    {
        "label": "b64encode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def b64encode(s, altchars=None):\n    \"\"\"Encode the bytes-like object s using Base64 and return a bytes object.\n    Optional altchars should be a byte string of length 2 which specifies an\n    alternative alphabet for the '+' and '/' characters.  This allows an\n    application to e.g. generate url or filesystem safe Base64 strings.\n    \"\"\"\n    encoded = binascii.b2a_base64(s, newline=False)\n    if altchars is not None:\n        assert len(altchars) == 2, repr(altchars)\n        return encoded.translate(bytes.maketrans(b'+/', altchars))",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b64decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def b64decode(s, altchars=None, validate=False):\n    \"\"\"Decode the Base64 encoded bytes-like object or ASCII string s.\n    Optional altchars must be a bytes-like object or ASCII string of length 2\n    which specifies the alternative alphabet used instead of the '+' and '/'\n    characters.\n    The result is returned as a bytes object.  A binascii.Error is raised if\n    s is incorrectly padded.\n    If validate is False (the default), characters that are neither in the\n    normal base-64 alphabet nor the alternative alphabet are discarded prior\n    to the padding check.  If validate is True, these non-alphabet characters",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "standard_b64encode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def standard_b64encode(s):\n    \"\"\"Encode bytes-like object s using the standard Base64 alphabet.\n    The result is returned as a bytes object.\n    \"\"\"\n    return b64encode(s)\ndef standard_b64decode(s):\n    \"\"\"Decode bytes encoded with the standard Base64 alphabet.\n    Argument s is a bytes-like object or ASCII string to decode.  The result\n    is returned as a bytes object.  A binascii.Error is raised if the input\n    is incorrectly padded.  Characters that are not in the standard alphabet",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "standard_b64decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def standard_b64decode(s):\n    \"\"\"Decode bytes encoded with the standard Base64 alphabet.\n    Argument s is a bytes-like object or ASCII string to decode.  The result\n    is returned as a bytes object.  A binascii.Error is raised if the input\n    is incorrectly padded.  Characters that are not in the standard alphabet\n    are discarded prior to the padding check.\n    \"\"\"\n    return b64decode(s)\n_urlsafe_encode_translation = bytes.maketrans(b'+/', b'-_')\n_urlsafe_decode_translation = bytes.maketrans(b'-_', b'+/')",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "urlsafe_b64encode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def urlsafe_b64encode(s):\n    \"\"\"Encode bytes using the URL- and filesystem-safe Base64 alphabet.\n    Argument s is a bytes-like object to encode.  The result is returned as a\n    bytes object.  The alphabet uses '-' instead of '+' and '_' instead of\n    '/'.\n    \"\"\"\n    return b64encode(s).translate(_urlsafe_encode_translation)\ndef urlsafe_b64decode(s):\n    \"\"\"Decode bytes using the URL- and filesystem-safe Base64 alphabet.\n    Argument s is a bytes-like object or ASCII string to decode.  The result",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "urlsafe_b64decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def urlsafe_b64decode(s):\n    \"\"\"Decode bytes using the URL- and filesystem-safe Base64 alphabet.\n    Argument s is a bytes-like object or ASCII string to decode.  The result\n    is returned as a bytes object.  A binascii.Error is raised if the input\n    is incorrectly padded.  Characters that are not in the URL-safe base-64\n    alphabet, and are not a plus '+' or slash '/', are discarded prior to the\n    padding check.\n    The alphabet uses '-' instead of '+' and '_' instead of '/'.\n    \"\"\"\n    s = _bytes_from_decode_data(s)",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b32encode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def b32encode(s):\n    return _b32encode(_b32alphabet, s)\nb32encode.__doc__ = _B32_ENCODE_DOCSTRING.format(encoding='base32')\ndef b32decode(s, casefold=False, map01=None):\n    return _b32decode(_b32alphabet, s, casefold, map01)\nb32decode.__doc__ = _B32_DECODE_DOCSTRING.format(encoding='base32',\n                                        extra_args=_B32_DECODE_MAP01_DOCSTRING)\ndef b32hexencode(s):\n    return _b32encode(_b32hexalphabet, s)\nb32hexencode.__doc__ = _B32_ENCODE_DOCSTRING.format(encoding='base32hex')",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b32decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def b32decode(s, casefold=False, map01=None):\n    return _b32decode(_b32alphabet, s, casefold, map01)\nb32decode.__doc__ = _B32_DECODE_DOCSTRING.format(encoding='base32',\n                                        extra_args=_B32_DECODE_MAP01_DOCSTRING)\ndef b32hexencode(s):\n    return _b32encode(_b32hexalphabet, s)\nb32hexencode.__doc__ = _B32_ENCODE_DOCSTRING.format(encoding='base32hex')\ndef b32hexdecode(s, casefold=False):\n    # base32hex does not have the 01 mapping\n    return _b32decode(_b32hexalphabet, s, casefold)",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b32hexencode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def b32hexencode(s):\n    return _b32encode(_b32hexalphabet, s)\nb32hexencode.__doc__ = _B32_ENCODE_DOCSTRING.format(encoding='base32hex')\ndef b32hexdecode(s, casefold=False):\n    # base32hex does not have the 01 mapping\n    return _b32decode(_b32hexalphabet, s, casefold)\nb32hexdecode.__doc__ = _B32_DECODE_DOCSTRING.format(encoding='base32hex',\n                                                    extra_args='')\n# RFC 3548, Base 16 Alphabet specifies uppercase, but hexlify() returns\n# lowercase.  The RFC also recommends against accepting input case",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b32hexdecode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def b32hexdecode(s, casefold=False):\n    # base32hex does not have the 01 mapping\n    return _b32decode(_b32hexalphabet, s, casefold)\nb32hexdecode.__doc__ = _B32_DECODE_DOCSTRING.format(encoding='base32hex',\n                                                    extra_args='')\n# RFC 3548, Base 16 Alphabet specifies uppercase, but hexlify() returns\n# lowercase.  The RFC also recommends against accepting input case\n# insensitively.\ndef b16encode(s):\n    \"\"\"Encode the bytes-like object s using Base16 and return a bytes object.",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b16encode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def b16encode(s):\n    \"\"\"Encode the bytes-like object s using Base16 and return a bytes object.\n    \"\"\"\n    return binascii.hexlify(s).upper()\ndef b16decode(s, casefold=False):\n    \"\"\"Decode the Base16 encoded bytes-like object or ASCII string s.\n    Optional casefold is a flag specifying whether a lowercase alphabet is\n    acceptable as input.  For security purposes, the default is False.\n    The result is returned as a bytes object.  A binascii.Error is raised if\n    s is incorrectly padded or if there are non-alphabet characters present",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b16decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def b16decode(s, casefold=False):\n    \"\"\"Decode the Base16 encoded bytes-like object or ASCII string s.\n    Optional casefold is a flag specifying whether a lowercase alphabet is\n    acceptable as input.  For security purposes, the default is False.\n    The result is returned as a bytes object.  A binascii.Error is raised if\n    s is incorrectly padded or if there are non-alphabet characters present\n    in the input.\n    \"\"\"\n    s = _bytes_from_decode_data(s)\n    if casefold:",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "a85encode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def a85encode(b, *, foldspaces=False, wrapcol=0, pad=False, adobe=False):\n    \"\"\"Encode bytes-like object b using Ascii85 and return a bytes object.\n    foldspaces is an optional flag that uses the special short sequence 'y'\n    instead of 4 consecutive spaces (ASCII 0x20) as supported by 'btoa'. This\n    feature is not supported by the \"standard\" Adobe encoding.\n    wrapcol controls whether the output should have newline (b'\\\\n') characters\n    added to it. If this is non-zero, each output line will be at most this\n    many characters long, excluding the trailing newline.\n    pad controls whether the input is padded to a multiple of 4 before\n    encoding. Note that the btoa implementation always pads.",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "a85decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def a85decode(b, *, foldspaces=False, adobe=False, ignorechars=b' \\t\\n\\r\\v'):\n    \"\"\"Decode the Ascii85 encoded bytes-like object or ASCII string b.\n    foldspaces is a flag that specifies whether the 'y' short sequence should be\n    accepted as shorthand for 4 consecutive spaces (ASCII 0x20). This feature is\n    not supported by the \"standard\" Adobe encoding.\n    adobe controls whether the input sequence is in Adobe Ascii85 format (i.e.\n    is framed with <~ and ~>).\n    ignorechars should be a byte string containing characters to ignore from the\n    input. This should only contain whitespace characters, and by default\n    contains all whitespace characters in ASCII.",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b85encode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def b85encode(b, pad=False):\n    \"\"\"Encode bytes-like object b in base85 format and return a bytes object.\n    If pad is true, the input is padded with b'\\\\0' so its length is a multiple of\n    4 bytes before encoding.\n    \"\"\"\n    global _b85chars, _b85chars2\n    # Delay the initialization of tables to not waste memory\n    # if the function is never called\n    if _b85chars2 is None:\n        _b85chars = [bytes((i,)) for i in _b85alphabet]",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b85decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def b85decode(b):\n    \"\"\"Decode the base85-encoded bytes-like object or ASCII string b\n    The result is returned as a bytes object.\n    \"\"\"\n    global _b85dec\n    # Delay the initialization of tables to not waste memory\n    # if the function is never called\n    if _b85dec is None:\n        _b85dec = [None] * 256\n        for i, c in enumerate(_b85alphabet):",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "z85encode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def z85encode(s):\n    \"\"\"Encode bytes-like object b in z85 format and return a bytes object.\"\"\"\n    return b85encode(s).translate(_z85_encode_translation)\ndef z85decode(s):\n    \"\"\"Decode the z85-encoded bytes-like object or ASCII string b\n    The result is returned as a bytes object.\n    \"\"\"\n    s = _bytes_from_decode_data(s)\n    s = s.translate(_z85_decode_translation)\n    try:",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "z85decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def z85decode(s):\n    \"\"\"Decode the z85-encoded bytes-like object or ASCII string b\n    The result is returned as a bytes object.\n    \"\"\"\n    s = _bytes_from_decode_data(s)\n    s = s.translate(_z85_decode_translation)\n    try:\n        return b85decode(s)\n    except ValueError as e:\n        raise ValueError(e.args[0].replace('base85', 'z85')) from None",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "encode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def encode(input, output):\n    \"\"\"Encode a file; input and output are binary files.\"\"\"\n    while s := input.read(MAXBINSIZE):\n        while len(s) < MAXBINSIZE and (ns := input.read(MAXBINSIZE-len(s))):\n            s += ns\n        line = binascii.b2a_base64(s)\n        output.write(line)\ndef decode(input, output):\n    \"\"\"Decode a file; input and output are binary files.\"\"\"\n    while line := input.readline():",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "decode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def decode(input, output):\n    \"\"\"Decode a file; input and output are binary files.\"\"\"\n    while line := input.readline():\n        s = binascii.a2b_base64(line)\n        output.write(s)\ndef _input_type_check(s):\n    try:\n        m = memoryview(s)\n    except TypeError as err:\n        msg = \"expected bytes-like object, not %s\" % s.__class__.__name__",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "encodebytes",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def encodebytes(s):\n    \"\"\"Encode a bytestring into a bytes object containing multiple lines\n    of base-64 data.\"\"\"\n    _input_type_check(s)\n    pieces = []\n    for i in range(0, len(s), MAXBINSIZE):\n        chunk = s[i : i + MAXBINSIZE]\n        pieces.append(binascii.b2a_base64(chunk))\n    return b\"\".join(pieces)\ndef decodebytes(s):",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "decodebytes",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def decodebytes(s):\n    \"\"\"Decode a bytestring of base-64 data into a bytes object.\"\"\"\n    _input_type_check(s)\n    return binascii.a2b_base64(s)\n# Usable as a script...\ndef main():\n    \"\"\"Small main program\"\"\"\n    import sys, getopt\n    usage = f\"\"\"usage: {sys.argv[0]} [-h|-d|-e|-u] [file|-]\n        -h: print this help message and exit",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "def main():\n    \"\"\"Small main program\"\"\"\n    import sys, getopt\n    usage = f\"\"\"usage: {sys.argv[0]} [-h|-d|-e|-u] [file|-]\n        -h: print this help message and exit\n        -d, -u: decode\n        -e: encode (default)\"\"\"\n    try:\n        opts, args = getopt.getopt(sys.argv[1:], 'hdeu')\n    except getopt.error as msg:",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "__all__ = [\n    # Legacy interface exports traditional RFC 2045 Base64 encodings\n    'encode', 'decode', 'encodebytes', 'decodebytes',\n    # Generalized interface for other encodings\n    'b64encode', 'b64decode', 'b32encode', 'b32decode',\n    'b32hexencode', 'b32hexdecode', 'b16encode', 'b16decode',\n    # Base85 and Ascii85 encodings\n    'b85encode', 'b85decode', 'a85encode', 'a85decode', 'z85encode', 'z85decode',\n    # Standard Base64 encoding\n    'standard_b64encode', 'standard_b64decode',",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "bytes_types",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "bytes_types = (bytes, bytearray)  # Types acceptable as binary data\ndef _bytes_from_decode_data(s):\n    if isinstance(s, str):\n        try:\n            return s.encode('ascii')\n        except UnicodeEncodeError:\n            raise ValueError('string argument should contain only ASCII characters')\n    if isinstance(s, bytes_types):\n        return s\n    try:",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_urlsafe_encode_translation",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_urlsafe_encode_translation = bytes.maketrans(b'+/', b'-_')\n_urlsafe_decode_translation = bytes.maketrans(b'-_', b'+/')\ndef urlsafe_b64encode(s):\n    \"\"\"Encode bytes using the URL- and filesystem-safe Base64 alphabet.\n    Argument s is a bytes-like object to encode.  The result is returned as a\n    bytes object.  The alphabet uses '-' instead of '+' and '_' instead of\n    '/'.\n    \"\"\"\n    return b64encode(s).translate(_urlsafe_encode_translation)\ndef urlsafe_b64decode(s):",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_urlsafe_decode_translation",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_urlsafe_decode_translation = bytes.maketrans(b'-_', b'+/')\ndef urlsafe_b64encode(s):\n    \"\"\"Encode bytes using the URL- and filesystem-safe Base64 alphabet.\n    Argument s is a bytes-like object to encode.  The result is returned as a\n    bytes object.  The alphabet uses '-' instead of '+' and '_' instead of\n    '/'.\n    \"\"\"\n    return b64encode(s).translate(_urlsafe_encode_translation)\ndef urlsafe_b64decode(s):\n    \"\"\"Decode bytes using the URL- and filesystem-safe Base64 alphabet.",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_B32_ENCODE_DOCSTRING",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_B32_ENCODE_DOCSTRING = '''\nEncode the bytes-like objects using {encoding} and return a bytes object.\n'''\n_B32_DECODE_DOCSTRING = '''\nDecode the {encoding} encoded bytes-like object or ASCII string s.\nOptional casefold is a flag specifying whether a lowercase alphabet is\nacceptable as input.  For security purposes, the default is False.\n{extra_args}\nThe result is returned as a bytes object.  A binascii.Error is raised if\nthe input is incorrectly padded or if there are non-alphabet",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_B32_DECODE_DOCSTRING",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_B32_DECODE_DOCSTRING = '''\nDecode the {encoding} encoded bytes-like object or ASCII string s.\nOptional casefold is a flag specifying whether a lowercase alphabet is\nacceptable as input.  For security purposes, the default is False.\n{extra_args}\nThe result is returned as a bytes object.  A binascii.Error is raised if\nthe input is incorrectly padded or if there are non-alphabet\ncharacters present in the input.\n'''\n_B32_DECODE_MAP01_DOCSTRING = '''",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_B32_DECODE_MAP01_DOCSTRING",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_B32_DECODE_MAP01_DOCSTRING = '''\nRFC 3548 allows for optional mapping of the digit 0 (zero) to the\nletter O (oh), and for optional mapping of the digit 1 (one) to\neither the letter I (eye) or letter L (el).  The optional argument\nmap01 when not None, specifies which letter the digit 1 should be\nmapped to (when map01 is not None, the digit 0 is always mapped to\nthe letter O).  For security purposes the default is None, so that\n0 and 1 are not allowed in the input.\n'''\n_b32alphabet = b'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_b32alphabet",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_b32alphabet = b'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'\n_b32hexalphabet = b'0123456789ABCDEFGHIJKLMNOPQRSTUV'\n_b32tab2 = {}\n_b32rev = {}\ndef _b32encode(alphabet, s):\n    # Delay the initialization of the table to not waste memory\n    # if the function is never called\n    if alphabet not in _b32tab2:\n        b32tab = [bytes((i,)) for i in alphabet]\n        _b32tab2[alphabet] = [a + b for a in b32tab for b in b32tab]",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_b32hexalphabet",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_b32hexalphabet = b'0123456789ABCDEFGHIJKLMNOPQRSTUV'\n_b32tab2 = {}\n_b32rev = {}\ndef _b32encode(alphabet, s):\n    # Delay the initialization of the table to not waste memory\n    # if the function is never called\n    if alphabet not in _b32tab2:\n        b32tab = [bytes((i,)) for i in alphabet]\n        _b32tab2[alphabet] = [a + b for a in b32tab for b in b32tab]\n        b32tab = None",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_b32tab2",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_b32tab2 = {}\n_b32rev = {}\ndef _b32encode(alphabet, s):\n    # Delay the initialization of the table to not waste memory\n    # if the function is never called\n    if alphabet not in _b32tab2:\n        b32tab = [bytes((i,)) for i in alphabet]\n        _b32tab2[alphabet] = [a + b for a in b32tab for b in b32tab]\n        b32tab = None\n    if not isinstance(s, bytes_types):",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_b32rev",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_b32rev = {}\ndef _b32encode(alphabet, s):\n    # Delay the initialization of the table to not waste memory\n    # if the function is never called\n    if alphabet not in _b32tab2:\n        b32tab = [bytes((i,)) for i in alphabet]\n        _b32tab2[alphabet] = [a + b for a in b32tab for b in b32tab]\n        b32tab = None\n    if not isinstance(s, bytes_types):\n        s = memoryview(s).tobytes()",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b32encode.__doc__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "b32encode.__doc__ = _B32_ENCODE_DOCSTRING.format(encoding='base32')\ndef b32decode(s, casefold=False, map01=None):\n    return _b32decode(_b32alphabet, s, casefold, map01)\nb32decode.__doc__ = _B32_DECODE_DOCSTRING.format(encoding='base32',\n                                        extra_args=_B32_DECODE_MAP01_DOCSTRING)\ndef b32hexencode(s):\n    return _b32encode(_b32hexalphabet, s)\nb32hexencode.__doc__ = _B32_ENCODE_DOCSTRING.format(encoding='base32hex')\ndef b32hexdecode(s, casefold=False):\n    # base32hex does not have the 01 mapping",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b32decode.__doc__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "b32decode.__doc__ = _B32_DECODE_DOCSTRING.format(encoding='base32',\n                                        extra_args=_B32_DECODE_MAP01_DOCSTRING)\ndef b32hexencode(s):\n    return _b32encode(_b32hexalphabet, s)\nb32hexencode.__doc__ = _B32_ENCODE_DOCSTRING.format(encoding='base32hex')\ndef b32hexdecode(s, casefold=False):\n    # base32hex does not have the 01 mapping\n    return _b32decode(_b32hexalphabet, s, casefold)\nb32hexdecode.__doc__ = _B32_DECODE_DOCSTRING.format(encoding='base32hex',\n                                                    extra_args='')",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b32hexencode.__doc__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "b32hexencode.__doc__ = _B32_ENCODE_DOCSTRING.format(encoding='base32hex')\ndef b32hexdecode(s, casefold=False):\n    # base32hex does not have the 01 mapping\n    return _b32decode(_b32hexalphabet, s, casefold)\nb32hexdecode.__doc__ = _B32_DECODE_DOCSTRING.format(encoding='base32hex',\n                                                    extra_args='')\n# RFC 3548, Base 16 Alphabet specifies uppercase, but hexlify() returns\n# lowercase.  The RFC also recommends against accepting input case\n# insensitively.\ndef b16encode(s):",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "b32hexdecode.__doc__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "b32hexdecode.__doc__ = _B32_DECODE_DOCSTRING.format(encoding='base32hex',\n                                                    extra_args='')\n# RFC 3548, Base 16 Alphabet specifies uppercase, but hexlify() returns\n# lowercase.  The RFC also recommends against accepting input case\n# insensitively.\ndef b16encode(s):\n    \"\"\"Encode the bytes-like object s using Base16 and return a bytes object.\n    \"\"\"\n    return binascii.hexlify(s).upper()\ndef b16decode(s, casefold=False):",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_a85chars",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_a85chars = None\n_a85chars2 = None\n_A85START = b\"<~\"\n_A85END = b\"~>\"\ndef _85encode(b, chars, chars2, pad=False, foldnuls=False, foldspaces=False):\n    # Helper function for a85encode and b85encode\n    if not isinstance(b, bytes_types):\n        b = memoryview(b).tobytes()\n    padding = (-len(b)) % 4\n    if padding:",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_a85chars2",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_a85chars2 = None\n_A85START = b\"<~\"\n_A85END = b\"~>\"\ndef _85encode(b, chars, chars2, pad=False, foldnuls=False, foldspaces=False):\n    # Helper function for a85encode and b85encode\n    if not isinstance(b, bytes_types):\n        b = memoryview(b).tobytes()\n    padding = (-len(b)) % 4\n    if padding:\n        b = b + b'\\0' * padding",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_A85START",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_A85START = b\"<~\"\n_A85END = b\"~>\"\ndef _85encode(b, chars, chars2, pad=False, foldnuls=False, foldspaces=False):\n    # Helper function for a85encode and b85encode\n    if not isinstance(b, bytes_types):\n        b = memoryview(b).tobytes()\n    padding = (-len(b)) % 4\n    if padding:\n        b = b + b'\\0' * padding\n    words = struct.Struct('!%dI' % (len(b) // 4)).unpack(b)",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_A85END",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_A85END = b\"~>\"\ndef _85encode(b, chars, chars2, pad=False, foldnuls=False, foldspaces=False):\n    # Helper function for a85encode and b85encode\n    if not isinstance(b, bytes_types):\n        b = memoryview(b).tobytes()\n    padding = (-len(b)) % 4\n    if padding:\n        b = b + b'\\0' * padding\n    words = struct.Struct('!%dI' % (len(b) // 4)).unpack(b)\n    chunks = [b'z' if foldnuls and not word else",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_b85alphabet",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_b85alphabet = (b\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                b\"abcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~\")\n_b85chars = None\n_b85chars2 = None\n_b85dec = None\ndef b85encode(b, pad=False):\n    \"\"\"Encode bytes-like object b in base85 format and return a bytes object.\n    If pad is true, the input is padded with b'\\\\0' so its length is a multiple of\n    4 bytes before encoding.\n    \"\"\"",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_b85chars",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_b85chars = None\n_b85chars2 = None\n_b85dec = None\ndef b85encode(b, pad=False):\n    \"\"\"Encode bytes-like object b in base85 format and return a bytes object.\n    If pad is true, the input is padded with b'\\\\0' so its length is a multiple of\n    4 bytes before encoding.\n    \"\"\"\n    global _b85chars, _b85chars2\n    # Delay the initialization of tables to not waste memory",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_b85chars2",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_b85chars2 = None\n_b85dec = None\ndef b85encode(b, pad=False):\n    \"\"\"Encode bytes-like object b in base85 format and return a bytes object.\n    If pad is true, the input is padded with b'\\\\0' so its length is a multiple of\n    4 bytes before encoding.\n    \"\"\"\n    global _b85chars, _b85chars2\n    # Delay the initialization of tables to not waste memory\n    # if the function is never called",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_b85dec",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_b85dec = None\ndef b85encode(b, pad=False):\n    \"\"\"Encode bytes-like object b in base85 format and return a bytes object.\n    If pad is true, the input is padded with b'\\\\0' so its length is a multiple of\n    4 bytes before encoding.\n    \"\"\"\n    global _b85chars, _b85chars2\n    # Delay the initialization of tables to not waste memory\n    # if the function is never called\n    if _b85chars2 is None:",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_z85alphabet",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_z85alphabet = (b'0123456789abcdefghijklmnopqrstuvwxyz'\n                b'ABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#')\n# Translating b85 valid but z85 invalid chars to b'\\x00' is required\n# to prevent them from being decoded as b85 valid chars.\n_z85_b85_decode_diff = b';_`|~'\n_z85_decode_translation = bytes.maketrans(\n    _z85alphabet + _z85_b85_decode_diff,\n    _b85alphabet + b'\\x00' * len(_z85_b85_decode_diff)\n)\n_z85_encode_translation = bytes.maketrans(_b85alphabet, _z85alphabet)",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_z85_b85_decode_diff",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_z85_b85_decode_diff = b';_`|~'\n_z85_decode_translation = bytes.maketrans(\n    _z85alphabet + _z85_b85_decode_diff,\n    _b85alphabet + b'\\x00' * len(_z85_b85_decode_diff)\n)\n_z85_encode_translation = bytes.maketrans(_b85alphabet, _z85alphabet)\ndef z85encode(s):\n    \"\"\"Encode bytes-like object b in z85 format and return a bytes object.\"\"\"\n    return b85encode(s).translate(_z85_encode_translation)\ndef z85decode(s):",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_z85_decode_translation",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_z85_decode_translation = bytes.maketrans(\n    _z85alphabet + _z85_b85_decode_diff,\n    _b85alphabet + b'\\x00' * len(_z85_b85_decode_diff)\n)\n_z85_encode_translation = bytes.maketrans(_b85alphabet, _z85alphabet)\ndef z85encode(s):\n    \"\"\"Encode bytes-like object b in z85 format and return a bytes object.\"\"\"\n    return b85encode(s).translate(_z85_encode_translation)\ndef z85decode(s):\n    \"\"\"Decode the z85-encoded bytes-like object or ASCII string b",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "_z85_encode_translation",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "_z85_encode_translation = bytes.maketrans(_b85alphabet, _z85alphabet)\ndef z85encode(s):\n    \"\"\"Encode bytes-like object b in z85 format and return a bytes object.\"\"\"\n    return b85encode(s).translate(_z85_encode_translation)\ndef z85decode(s):\n    \"\"\"Decode the z85-encoded bytes-like object or ASCII string b\n    The result is returned as a bytes object.\n    \"\"\"\n    s = _bytes_from_decode_data(s)\n    s = s.translate(_z85_decode_translation)",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "MAXLINESIZE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "MAXLINESIZE = 76 # Excluding the CRLF\nMAXBINSIZE = (MAXLINESIZE//4)*3\ndef encode(input, output):\n    \"\"\"Encode a file; input and output are binary files.\"\"\"\n    while s := input.read(MAXBINSIZE):\n        while len(s) < MAXBINSIZE and (ns := input.read(MAXBINSIZE-len(s))):\n            s += ns\n        line = binascii.b2a_base64(s)\n        output.write(line)\ndef decode(input, output):",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "MAXBINSIZE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.base64",
        "description": "pycharm_venv.Lib.base64",
        "peekOfCode": "MAXBINSIZE = (MAXLINESIZE//4)*3\ndef encode(input, output):\n    \"\"\"Encode a file; input and output are binary files.\"\"\"\n    while s := input.read(MAXBINSIZE):\n        while len(s) < MAXBINSIZE and (ns := input.read(MAXBINSIZE-len(s))):\n            s += ns\n        line = binascii.b2a_base64(s)\n        output.write(line)\ndef decode(input, output):\n    \"\"\"Decode a file; input and output are binary files.\"\"\"",
        "detail": "pycharm_venv.Lib.base64",
        "documentation": {}
    },
    {
        "label": "insort_right",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.bisect",
        "description": "pycharm_venv.Lib.bisect",
        "peekOfCode": "def insort_right(a, x, lo=0, hi=None, *, key=None):\n    \"\"\"Insert item x in list a, and keep it sorted assuming a is sorted.\n    If x is already in a, insert it to the right of the rightmost x.\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    A custom key function can be supplied to customize the sort order.\n    \"\"\"\n    if key is None:\n        lo = bisect_right(a, x, lo, hi)\n    else:",
        "detail": "pycharm_venv.Lib.bisect",
        "documentation": {}
    },
    {
        "label": "bisect_right",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.bisect",
        "description": "pycharm_venv.Lib.bisect",
        "peekOfCode": "def bisect_right(a, x, lo=0, hi=None, *, key=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n    The return value i is such that all e in a[:i] have e <= x, and all e in\n    a[i:] have e > x.  So if x already appears in the list, a.insert(i, x) will\n    insert just after the rightmost x already there.\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    A custom key function can be supplied to customize the sort order.\n    \"\"\"\n    if lo < 0:",
        "detail": "pycharm_venv.Lib.bisect",
        "documentation": {}
    },
    {
        "label": "insort_left",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.bisect",
        "description": "pycharm_venv.Lib.bisect",
        "peekOfCode": "def insort_left(a, x, lo=0, hi=None, *, key=None):\n    \"\"\"Insert item x in list a, and keep it sorted assuming a is sorted.\n    If x is already in a, insert it to the left of the leftmost x.\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    A custom key function can be supplied to customize the sort order.\n    \"\"\"\n    if key is None:\n        lo = bisect_left(a, x, lo, hi)\n    else:",
        "detail": "pycharm_venv.Lib.bisect",
        "documentation": {}
    },
    {
        "label": "bisect_left",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.bisect",
        "description": "pycharm_venv.Lib.bisect",
        "peekOfCode": "def bisect_left(a, x, lo=0, hi=None, *, key=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n    The return value i is such that all e in a[:i] have e < x, and all e in\n    a[i:] have e >= x.  So if x already appears in the list, a.insert(i, x) will\n    insert just before the leftmost x already there.\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    A custom key function can be supplied to customize the sort order.\n    \"\"\"\n    if lo < 0:",
        "detail": "pycharm_venv.Lib.bisect",
        "documentation": {}
    },
    {
        "label": "bisect",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.bisect",
        "description": "pycharm_venv.Lib.bisect",
        "peekOfCode": "bisect = bisect_right\ninsort = insort_right",
        "detail": "pycharm_venv.Lib.bisect",
        "documentation": {}
    },
    {
        "label": "insort",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.bisect",
        "description": "pycharm_venv.Lib.bisect",
        "peekOfCode": "insort = insort_right",
        "detail": "pycharm_venv.Lib.bisect",
        "documentation": {}
    },
    {
        "label": "instances)",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "class instances).\n- A shallow copy constructs a new compound object and then (to the\n  extent possible) inserts *the same objects* into it that the\n  original contains.\n- A deep copy constructs a new compound object and then, recursively,\n  inserts *copies* into it of the objects found in the original.\nTwo problems often exist with deep copy operations that don't exist\nwith shallow copy operations:\n a) recursive objects (compound objects that, directly or indirectly,\n    contain a reference to themselves) may cause a recursive loop",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "Error",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "class Error(Exception):\n    pass\nerror = Error   # backward compatibility\n__all__ = [\"Error\", \"copy\", \"deepcopy\", \"replace\"]\ndef copy(x):\n    \"\"\"Shallow copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    cls = type(x)\n    copier = _copy_dispatch.get(cls)",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "def copy(x):\n    \"\"\"Shallow copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    cls = type(x)\n    copier = _copy_dispatch.get(cls)\n    if copier:\n        return copier(x)\n    if issubclass(cls, type):\n        # treat it as a regular class:",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "def deepcopy(x, memo=None, _nil=[]):\n    \"\"\"Deep copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    d = id(x)\n    if memo is None:\n        memo = {}\n    else:\n        y = memo.get(d, _nil)\n        if y is not _nil:",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "replace",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "def replace(obj, /, **changes):\n    \"\"\"Return a new object replacing specified fields with new values.\n    This is especially useful for immutable objects, like named tuples or\n    frozen dataclasses.\n    \"\"\"\n    cls = obj.__class__\n    func = getattr(cls, '__replace__', None)\n    if func is None:\n        raise TypeError(f\"replace() does not support {cls.__name__} objects\")\n    return func(obj, **changes)",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "error",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "error = Error   # backward compatibility\n__all__ = [\"Error\", \"copy\", \"deepcopy\", \"replace\"]\ndef copy(x):\n    \"\"\"Shallow copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    cls = type(x)\n    copier = _copy_dispatch.get(cls)\n    if copier:\n        return copier(x)",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "__all__ = [\"Error\", \"copy\", \"deepcopy\", \"replace\"]\ndef copy(x):\n    \"\"\"Shallow copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    cls = type(x)\n    copier = _copy_dispatch.get(cls)\n    if copier:\n        return copier(x)\n    if issubclass(cls, type):",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "_copy_dispatch",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "_copy_dispatch = d = {}\ndef _copy_immutable(x):\n    return x\nfor t in (types.NoneType, int, float, bool, complex, str, tuple,\n          bytes, frozenset, type, range, slice, property,\n          types.BuiltinFunctionType, types.EllipsisType,\n          types.NotImplementedType, types.FunctionType, types.CodeType,\n          weakref.ref):\n    d[t] = _copy_immutable\nd[list] = list.copy",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[list]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[list] = list.copy\nd[dict] = dict.copy\nd[set] = set.copy\nd[bytearray] = bytearray.copy\ndel d, t\ndef deepcopy(x, memo=None, _nil=[]):\n    \"\"\"Deep copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    d = id(x)",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[dict]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[dict] = dict.copy\nd[set] = set.copy\nd[bytearray] = bytearray.copy\ndel d, t\ndef deepcopy(x, memo=None, _nil=[]):\n    \"\"\"Deep copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    d = id(x)\n    if memo is None:",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[set]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[set] = set.copy\nd[bytearray] = bytearray.copy\ndel d, t\ndef deepcopy(x, memo=None, _nil=[]):\n    \"\"\"Deep copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    d = id(x)\n    if memo is None:\n        memo = {}",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[bytearray]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[bytearray] = bytearray.copy\ndel d, t\ndef deepcopy(x, memo=None, _nil=[]):\n    \"\"\"Deep copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    d = id(x)\n    if memo is None:\n        memo = {}\n    else:",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "_deepcopy_dispatch",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "_deepcopy_dispatch = d = {}\ndef _deepcopy_atomic(x, memo):\n    return x\nd[types.NoneType] = _deepcopy_atomic\nd[types.EllipsisType] = _deepcopy_atomic\nd[types.NotImplementedType] = _deepcopy_atomic\nd[int] = _deepcopy_atomic\nd[float] = _deepcopy_atomic\nd[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[types.NoneType]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[types.NoneType] = _deepcopy_atomic\nd[types.EllipsisType] = _deepcopy_atomic\nd[types.NotImplementedType] = _deepcopy_atomic\nd[int] = _deepcopy_atomic\nd[float] = _deepcopy_atomic\nd[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic\nd[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\nd[types.CodeType] = _deepcopy_atomic",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[types.EllipsisType]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[types.EllipsisType] = _deepcopy_atomic\nd[types.NotImplementedType] = _deepcopy_atomic\nd[int] = _deepcopy_atomic\nd[float] = _deepcopy_atomic\nd[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic\nd[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\nd[types.CodeType] = _deepcopy_atomic\nd[type] = _deepcopy_atomic",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[types.NotImplementedType]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[types.NotImplementedType] = _deepcopy_atomic\nd[int] = _deepcopy_atomic\nd[float] = _deepcopy_atomic\nd[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic\nd[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\nd[types.CodeType] = _deepcopy_atomic\nd[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[int]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[int] = _deepcopy_atomic\nd[float] = _deepcopy_atomic\nd[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic\nd[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\nd[types.CodeType] = _deepcopy_atomic\nd[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[float]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[float] = _deepcopy_atomic\nd[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic\nd[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\nd[types.CodeType] = _deepcopy_atomic\nd[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[bool]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic\nd[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\nd[types.CodeType] = _deepcopy_atomic\nd[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[complex]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[complex] = _deepcopy_atomic\nd[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\nd[types.CodeType] = _deepcopy_atomic\nd[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic\nd[property] = _deepcopy_atomic",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[bytes]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\nd[types.CodeType] = _deepcopy_atomic\nd[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic\nd[property] = _deepcopy_atomic\ndef _deepcopy_list(x, memo, deepcopy=deepcopy):",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[str]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[str] = _deepcopy_atomic\nd[types.CodeType] = _deepcopy_atomic\nd[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic\nd[property] = _deepcopy_atomic\ndef _deepcopy_list(x, memo, deepcopy=deepcopy):\n    y = []",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[types.CodeType]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[types.CodeType] = _deepcopy_atomic\nd[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic\nd[property] = _deepcopy_atomic\ndef _deepcopy_list(x, memo, deepcopy=deepcopy):\n    y = []\n    memo[id(x)] = y",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[type]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic\nd[property] = _deepcopy_atomic\ndef _deepcopy_list(x, memo, deepcopy=deepcopy):\n    y = []\n    memo[id(x)] = y\n    append = y.append",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[range]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic\nd[property] = _deepcopy_atomic\ndef _deepcopy_list(x, memo, deepcopy=deepcopy):\n    y = []\n    memo[id(x)] = y\n    append = y.append\n    for a in x:",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[types.BuiltinFunctionType]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic\nd[property] = _deepcopy_atomic\ndef _deepcopy_list(x, memo, deepcopy=deepcopy):\n    y = []\n    memo[id(x)] = y\n    append = y.append\n    for a in x:\n        append(deepcopy(a, memo))",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[types.FunctionType]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic\nd[property] = _deepcopy_atomic\ndef _deepcopy_list(x, memo, deepcopy=deepcopy):\n    y = []\n    memo[id(x)] = y\n    append = y.append\n    for a in x:\n        append(deepcopy(a, memo))\n    return y",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[weakref.ref]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[weakref.ref] = _deepcopy_atomic\nd[property] = _deepcopy_atomic\ndef _deepcopy_list(x, memo, deepcopy=deepcopy):\n    y = []\n    memo[id(x)] = y\n    append = y.append\n    for a in x:\n        append(deepcopy(a, memo))\n    return y\nd[list] = _deepcopy_list",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[property]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[property] = _deepcopy_atomic\ndef _deepcopy_list(x, memo, deepcopy=deepcopy):\n    y = []\n    memo[id(x)] = y\n    append = y.append\n    for a in x:\n        append(deepcopy(a, memo))\n    return y\nd[list] = _deepcopy_list\ndef _deepcopy_tuple(x, memo, deepcopy=deepcopy):",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[list]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[list] = _deepcopy_list\ndef _deepcopy_tuple(x, memo, deepcopy=deepcopy):\n    y = [deepcopy(a, memo) for a in x]\n    # We're not going to put the tuple in the memo, but it's still important we\n    # check for it, in case the tuple contains recursive mutable structures.\n    try:\n        return memo[id(x)]\n    except KeyError:\n        pass\n    for k, j in zip(x, y):",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[tuple]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[tuple] = _deepcopy_tuple\ndef _deepcopy_dict(x, memo, deepcopy=deepcopy):\n    y = {}\n    memo[id(x)] = y\n    for key, value in x.items():\n        y[deepcopy(key, memo)] = deepcopy(value, memo)\n    return y\nd[dict] = _deepcopy_dict\ndef _deepcopy_method(x, memo): # Copy instance methods\n    return type(x)(x.__func__, deepcopy(x.__self__, memo))",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[dict]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[dict] = _deepcopy_dict\ndef _deepcopy_method(x, memo): # Copy instance methods\n    return type(x)(x.__func__, deepcopy(x.__self__, memo))\nd[types.MethodType] = _deepcopy_method\ndel d\ndef _keep_alive(x, memo):\n    \"\"\"Keeps a reference to the object x in the memo.\n    Because we remember objects by their id, we have\n    to assure that possibly temporary objects are kept\n    alive by referencing them.",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "d[types.MethodType]",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copy",
        "description": "pycharm_venv.Lib.copy",
        "peekOfCode": "d[types.MethodType] = _deepcopy_method\ndel d\ndef _keep_alive(x, memo):\n    \"\"\"Keeps a reference to the object x in the memo.\n    Because we remember objects by their id, we have\n    to assure that possibly temporary objects are kept\n    alive by referencing them.\n    We store a reference at the id of the memo, which should\n    normally not be used unless someone tries to deepcopy\n    the memo itself...",
        "detail": "pycharm_venv.Lib.copy",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.copyreg",
        "description": "pycharm_venv.Lib.copyreg",
        "peekOfCode": "def pickle(ob_type, pickle_function, constructor_ob=None):\n    if not callable(pickle_function):\n        raise TypeError(\"reduction functions must be callable\")\n    dispatch_table[ob_type] = pickle_function\n    # The constructor_ob function is a vestige of safe for unpickling.\n    # There is no reason for the caller to pass it anymore.\n    if constructor_ob is not None:\n        constructor(constructor_ob)\ndef constructor(object):\n    if not callable(object):",
        "detail": "pycharm_venv.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "constructor",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.copyreg",
        "description": "pycharm_venv.Lib.copyreg",
        "peekOfCode": "def constructor(object):\n    if not callable(object):\n        raise TypeError(\"constructors must be callable\")\n# Example: provide pickling support for complex numbers.\ndef pickle_complex(c):\n    return complex, (c.real, c.imag)\npickle(complex, pickle_complex, complex)\ndef pickle_union(obj):\n    import functools, operator\n    return functools.reduce, (operator.or_, obj.__args__)",
        "detail": "pycharm_venv.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "pickle_complex",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.copyreg",
        "description": "pycharm_venv.Lib.copyreg",
        "peekOfCode": "def pickle_complex(c):\n    return complex, (c.real, c.imag)\npickle(complex, pickle_complex, complex)\ndef pickle_union(obj):\n    import functools, operator\n    return functools.reduce, (operator.or_, obj.__args__)\npickle(type(int | str), pickle_union)\n# Support for pickling new-style objects\ndef _reconstructor(cls, base, state):\n    if base is object:",
        "detail": "pycharm_venv.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "pickle_union",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.copyreg",
        "description": "pycharm_venv.Lib.copyreg",
        "peekOfCode": "def pickle_union(obj):\n    import functools, operator\n    return functools.reduce, (operator.or_, obj.__args__)\npickle(type(int | str), pickle_union)\n# Support for pickling new-style objects\ndef _reconstructor(cls, base, state):\n    if base is object:\n        obj = object.__new__(cls)\n    else:\n        obj = base.__new__(cls, state)",
        "detail": "pycharm_venv.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "add_extension",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.copyreg",
        "description": "pycharm_venv.Lib.copyreg",
        "peekOfCode": "def add_extension(module, name, code):\n    \"\"\"Register an extension code.\"\"\"\n    code = int(code)\n    if not 1 <= code <= 0x7fffffff:\n        raise ValueError(\"code out of range\")\n    key = (module, name)\n    if (_extension_registry.get(key) == code and\n        _inverted_registry.get(code) == key):\n        return # Redundant registrations are benign\n    if key in _extension_registry:",
        "detail": "pycharm_venv.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "remove_extension",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.copyreg",
        "description": "pycharm_venv.Lib.copyreg",
        "peekOfCode": "def remove_extension(module, name, code):\n    \"\"\"Unregister an extension code.  For testing only.\"\"\"\n    key = (module, name)\n    if (_extension_registry.get(key) != code or\n        _inverted_registry.get(code) != key):\n        raise ValueError(\"key %s is not registered with code %s\" %\n                         (key, code))\n    del _extension_registry[key]\n    del _inverted_registry[code]\n    if code in _extension_cache:",
        "detail": "pycharm_venv.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "clear_extension_cache",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.copyreg",
        "description": "pycharm_venv.Lib.copyreg",
        "peekOfCode": "def clear_extension_cache():\n    _extension_cache.clear()\n# Standard extension code assignments\n# Reserved ranges\n# First  Last Count  Purpose\n#     1   127   127  Reserved for Python standard library\n#   128   191    64  Reserved for Zope\n#   192   239    48  Reserved for 3rd parties\n#   240   255    16  Reserved for private use (will never be assigned)\n#   256   Inf   Inf  Reserved for future assignment",
        "detail": "pycharm_venv.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copyreg",
        "description": "pycharm_venv.Lib.copyreg",
        "peekOfCode": "__all__ = [\"pickle\", \"constructor\",\n           \"add_extension\", \"remove_extension\", \"clear_extension_cache\"]\ndispatch_table = {}\ndef pickle(ob_type, pickle_function, constructor_ob=None):\n    if not callable(pickle_function):\n        raise TypeError(\"reduction functions must be callable\")\n    dispatch_table[ob_type] = pickle_function\n    # The constructor_ob function is a vestige of safe for unpickling.\n    # There is no reason for the caller to pass it anymore.\n    if constructor_ob is not None:",
        "detail": "pycharm_venv.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "dispatch_table",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copyreg",
        "description": "pycharm_venv.Lib.copyreg",
        "peekOfCode": "dispatch_table = {}\ndef pickle(ob_type, pickle_function, constructor_ob=None):\n    if not callable(pickle_function):\n        raise TypeError(\"reduction functions must be callable\")\n    dispatch_table[ob_type] = pickle_function\n    # The constructor_ob function is a vestige of safe for unpickling.\n    # There is no reason for the caller to pass it anymore.\n    if constructor_ob is not None:\n        constructor(constructor_ob)\ndef constructor(object):",
        "detail": "pycharm_venv.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "_HEAPTYPE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copyreg",
        "description": "pycharm_venv.Lib.copyreg",
        "peekOfCode": "_HEAPTYPE = 1<<9\n_new_type = type(int.__new__)\n# Python code for object.__reduce_ex__ for protocols 0 and 1\ndef _reduce_ex(self, proto):\n    assert proto < 2\n    cls = self.__class__\n    for base in cls.__mro__:\n        if hasattr(base, '__flags__') and not base.__flags__ & _HEAPTYPE:\n            break\n        new = base.__new__",
        "detail": "pycharm_venv.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "_new_type",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copyreg",
        "description": "pycharm_venv.Lib.copyreg",
        "peekOfCode": "_new_type = type(int.__new__)\n# Python code for object.__reduce_ex__ for protocols 0 and 1\ndef _reduce_ex(self, proto):\n    assert proto < 2\n    cls = self.__class__\n    for base in cls.__mro__:\n        if hasattr(base, '__flags__') and not base.__flags__ & _HEAPTYPE:\n            break\n        new = base.__new__\n        if isinstance(new, _new_type) and new.__self__ is base:",
        "detail": "pycharm_venv.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "_extension_registry",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copyreg",
        "description": "pycharm_venv.Lib.copyreg",
        "peekOfCode": "_extension_registry = {}                # key -> code\n_inverted_registry = {}                 # code -> key\n_extension_cache = {}                   # code -> object\n# Don't ever rebind those names:  pickling grabs a reference to them when\n# it's initialized, and won't see a rebinding.\ndef add_extension(module, name, code):\n    \"\"\"Register an extension code.\"\"\"\n    code = int(code)\n    if not 1 <= code <= 0x7fffffff:\n        raise ValueError(\"code out of range\")",
        "detail": "pycharm_venv.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "_inverted_registry",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copyreg",
        "description": "pycharm_venv.Lib.copyreg",
        "peekOfCode": "_inverted_registry = {}                 # code -> key\n_extension_cache = {}                   # code -> object\n# Don't ever rebind those names:  pickling grabs a reference to them when\n# it's initialized, and won't see a rebinding.\ndef add_extension(module, name, code):\n    \"\"\"Register an extension code.\"\"\"\n    code = int(code)\n    if not 1 <= code <= 0x7fffffff:\n        raise ValueError(\"code out of range\")\n    key = (module, name)",
        "detail": "pycharm_venv.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "_extension_cache",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.copyreg",
        "description": "pycharm_venv.Lib.copyreg",
        "peekOfCode": "_extension_cache = {}                   # code -> object\n# Don't ever rebind those names:  pickling grabs a reference to them when\n# it's initialized, and won't see a rebinding.\ndef add_extension(module, name, code):\n    \"\"\"Register an extension code.\"\"\"\n    code = int(code)\n    if not 1 <= code <= 0x7fffffff:\n        raise ValueError(\"code out of range\")\n    key = (module, name)\n    if (_extension_registry.get(key) == code and",
        "detail": "pycharm_venv.Lib.copyreg",
        "documentation": {}
    },
    {
        "label": "nonmember",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "class nonmember(object):\n    \"\"\"\n    Protects item from becoming an Enum member during class creation.\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\nclass member(object):\n    \"\"\"\n    Forces item to become an Enum member during class creation.\n    \"\"\"",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "member",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "class member(object):\n    \"\"\"\n    Forces item to become an Enum member during class creation.\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\ndef _is_descriptor(obj):\n    \"\"\"\n    Returns True if obj is a descriptor, False otherwise.\n    \"\"\"",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "_not_given",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "class _not_given:\n    def __repr__(self):\n        return('<not given>')\n_not_given = _not_given()\nclass _auto_null:\n    def __repr__(self):\n        return '_auto_null'\n_auto_null = _auto_null()\nclass auto:\n    \"\"\"",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "_auto_null",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "class _auto_null:\n    def __repr__(self):\n        return '_auto_null'\n_auto_null = _auto_null()\nclass auto:\n    \"\"\"\n    Instances are replaced with an appropriate value in Enum class suites.\n    \"\"\"\n    def __init__(self, value=_auto_null):\n        self.value = value",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "class auto:\n    \"\"\"\n    Instances are replaced with an appropriate value in Enum class suites.\n    \"\"\"\n    def __init__(self, value=_auto_null):\n        self.value = value\n    def __repr__(self):\n        return \"auto(%r)\" % self.value\nclass property(DynamicClassAttribute):\n    \"\"\"",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "property",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "class property(DynamicClassAttribute):\n    \"\"\"\n    This is a descriptor, used to define attributes that act differently\n    when accessed through an enum member and through an enum class.\n    Instance access is the same as property(), but access to an attribute\n    through the enum class will instead look in the class' _member_map_ for\n    a corresponding enum member.\n    \"\"\"\n    member = None\n    _attr_type = None",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "_proto_member",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "class _proto_member:\n    \"\"\"\n    intermediate step for enum members between class execution and final creation\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\n    def __set_name__(self, enum_class, member_name):\n        \"\"\"\n        convert each quasi-member into an instance of the new enum class\n        \"\"\"",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "EnumDict",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "class EnumDict(dict):\n    \"\"\"\n    Track enum member order and ensure member names are not reused.\n    EnumType will use the names found in self._member_names as the\n    enumeration member names.\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._member_names = {} # use a dict -- faster look-up than a list, and keeps insertion order since 3.7\n        self._last_values = []",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "EnumType",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "class EnumType(type):\n    \"\"\"\n    Metaclass for Enum\n    \"\"\"\n    @classmethod\n    def __prepare__(metacls, cls, bases, **kwds):\n        # check that previous enum members do not exist\n        metacls._check_for_existing_members_(cls, bases)\n        # create the namespace dict\n        enum_dict = EnumDict()",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "class Enum(metaclass=EnumType):\n    \"\"\"\n    Create a collection of name/value pairs.\n    Example enumeration:\n    >>> class Color(Enum):\n    ...     RED = 1\n    ...     BLUE = 2\n    ...     GREEN = 3\n    Access them by:\n    - attribute access:",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "ReprEnum",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "class ReprEnum(Enum):\n    \"\"\"\n    Only changes the repr(), leaving str() and format() to the mixed-in type.\n    \"\"\"\nclass IntEnum(int, ReprEnum):\n    \"\"\"\n    Enum where members are also (and must be) ints\n    \"\"\"\nclass StrEnum(str, ReprEnum):\n    \"\"\"",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "class IntEnum(int, ReprEnum):\n    \"\"\"\n    Enum where members are also (and must be) ints\n    \"\"\"\nclass StrEnum(str, ReprEnum):\n    \"\"\"\n    Enum where members are also (and must be) strings\n    \"\"\"\n    def __new__(cls, *values):\n        \"values must already be of type `str`\"",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "StrEnum",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "class StrEnum(str, ReprEnum):\n    \"\"\"\n    Enum where members are also (and must be) strings\n    \"\"\"\n    def __new__(cls, *values):\n        \"values must already be of type `str`\"\n        if len(values) > 3:\n            raise TypeError('too many arguments for str(): %r' % (values, ))\n        if len(values) == 1:\n            # it must be a string",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "FlagBoundary",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "class FlagBoundary(StrEnum):\n    \"\"\"\n    control how out of range values are handled\n    \"strict\" -> error is raised             [default for Flag]\n    \"conform\" -> extra bits are discarded\n    \"eject\" -> lose flag status\n    \"keep\" -> keep flag status and all bits [default for IntFlag]\n    \"\"\"\n    STRICT = auto()\n    CONFORM = auto()",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "Flag",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "class Flag(Enum, boundary=STRICT):\n    \"\"\"\n    Support for flags\n    \"\"\"\n    _numeric_repr_ = repr\n    @staticmethod\n    def _generate_next_value_(name, start, count, last_values):\n        \"\"\"\n        Generate the next value when not given.\n        name: the name of the member",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "IntFlag",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "class IntFlag(int, ReprEnum, Flag, boundary=KEEP):\n    \"\"\"\n    Support for integer-based Flags\n    \"\"\"\ndef _high_bit(value):\n    \"\"\"\n    returns index of highest bit, or -1 if value is zero or negative\n    \"\"\"\n    return value.bit_length() - 1\ndef unique(enumeration):",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "EnumCheck",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "class EnumCheck:\n    \"\"\"\n    various conditions to check an enumeration for\n    \"\"\"\n    CONTINUOUS = \"no skipped integer values\"\n    NAMED_FLAGS = \"multi-flag aliases may not contain unnamed flags\"\n    UNIQUE = \"one name per value\"\nCONTINUOUS, NAMED_FLAGS, UNIQUE = EnumCheck\nclass verify:\n    \"\"\"",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "verify",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "class verify:\n    \"\"\"\n    Check an enumeration for various constraints. (see EnumCheck)\n    \"\"\"\n    def __init__(self, *checks):\n        self.checks = checks\n    def __call__(self, enumeration):\n        checks = self.checks\n        cls_name = enumeration.__name__\n        if Flag is not None and issubclass(enumeration, Flag):",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "show_flag_values",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "def show_flag_values(value):\n    return list(_iter_bits_lsb(value))\ndef bin(num, max_bits=None):\n    \"\"\"\n    Like built-in bin(), except negative values are represented in\n    twos-compliment, and the leading bit always indicates sign\n    (0=positive, 1=negative).\n    >>> bin(10)\n    '0b0 1010'\n    >>> bin(~10)   # ~10 is -11",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "bin",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "def bin(num, max_bits=None):\n    \"\"\"\n    Like built-in bin(), except negative values are represented in\n    twos-compliment, and the leading bit always indicates sign\n    (0=positive, 1=negative).\n    >>> bin(10)\n    '0b0 1010'\n    >>> bin(~10)   # ~10 is -11\n    '0b1 0101'\n    \"\"\"",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "pickle_by_global_name",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "def pickle_by_global_name(self, proto):\n    # should not be used with Flag-type enums\n    return self.name\n_reduce_ex_by_global_name = pickle_by_global_name\ndef pickle_by_enum_name(self, proto):\n    # should not be used with Flag-type enums\n    return getattr, (self.__class__, self._name_)\nclass FlagBoundary(StrEnum):\n    \"\"\"\n    control how out of range values are handled",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "pickle_by_enum_name",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "def pickle_by_enum_name(self, proto):\n    # should not be used with Flag-type enums\n    return getattr, (self.__class__, self._name_)\nclass FlagBoundary(StrEnum):\n    \"\"\"\n    control how out of range values are handled\n    \"strict\" -> error is raised             [default for Flag]\n    \"conform\" -> extra bits are discarded\n    \"eject\" -> lose flag status\n    \"keep\" -> keep flag status and all bits [default for IntFlag]",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "unique",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "def unique(enumeration):\n    \"\"\"\n    Class decorator for enumerations ensuring unique member values.\n    \"\"\"\n    duplicates = []\n    for name, member in enumeration.__members__.items():\n        if name != member.name:\n            duplicates.append((name, member.name))\n    if duplicates:\n        alias_details = ', '.join(",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "global_enum_repr",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "def global_enum_repr(self):\n    \"\"\"\n    use module.enum_name instead of class.enum_name\n    the module is the last module in case of a multi-module name\n    \"\"\"\n    module = self.__class__.__module__.split('.')[-1]\n    return '%s.%s' % (module, self._name_)\ndef global_flag_repr(self):\n    \"\"\"\n    use module.flag_name instead of class.flag_name",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "global_flag_repr",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "def global_flag_repr(self):\n    \"\"\"\n    use module.flag_name instead of class.flag_name\n    the module is the last module in case of a multi-module name\n    \"\"\"\n    module = self.__class__.__module__.split('.')[-1]\n    cls_name = self.__class__.__name__\n    if self._name_ is None:\n        return \"%s.%s(%r)\" % (module, cls_name, self._value_)\n    if _is_single_bit(self._value_):",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "global_str",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "def global_str(self):\n    \"\"\"\n    use enum_name instead of class.enum_name\n    \"\"\"\n    if self._name_ is None:\n        cls_name = self.__class__.__name__\n        return \"%s(%r)\" % (cls_name, self._value_)\n    else:\n        return self._name_\ndef global_enum(cls, update_str=False):",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "global_enum",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "def global_enum(cls, update_str=False):\n    \"\"\"\n    decorator that makes the repr() of an enum member reference its module\n    instead of its class; also exports all members to the enum's module's\n    global namespace\n    \"\"\"\n    if issubclass(cls, Flag):\n        cls.__repr__ = global_flag_repr\n    else:\n        cls.__repr__ = global_enum_repr",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "__all__ = [\n        'EnumType', 'EnumMeta', 'EnumDict',\n        'Enum', 'IntEnum', 'StrEnum', 'Flag', 'IntFlag', 'ReprEnum',\n        'auto', 'unique', 'property', 'verify', 'member', 'nonmember',\n        'FlagBoundary', 'STRICT', 'CONFORM', 'EJECT', 'KEEP',\n        'global_flag_repr', 'global_enum_repr', 'global_str', 'global_enum',\n        'EnumCheck', 'CONTINUOUS', 'NAMED_FLAGS', 'UNIQUE',\n        'pickle_by_global_name', 'pickle_by_enum_name',\n        ]\n# Dummy value for Enum and Flag as there are explicit checks for them",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "Enum = Flag = EJECT = _stdlib_enums = ReprEnum = None\nclass nonmember(object):\n    \"\"\"\n    Protects item from becoming an Enum member during class creation.\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\nclass member(object):\n    \"\"\"\n    Forces item to become an Enum member during class creation.",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "_not_given",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "_not_given = _not_given()\nclass _auto_null:\n    def __repr__(self):\n        return '_auto_null'\n_auto_null = _auto_null()\nclass auto:\n    \"\"\"\n    Instances are replaced with an appropriate value in Enum class suites.\n    \"\"\"\n    def __init__(self, value=_auto_null):",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "_auto_null",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "_auto_null = _auto_null()\nclass auto:\n    \"\"\"\n    Instances are replaced with an appropriate value in Enum class suites.\n    \"\"\"\n    def __init__(self, value=_auto_null):\n        self.value = value\n    def __repr__(self):\n        return \"auto(%r)\" % self.value\nclass property(DynamicClassAttribute):",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "_EnumDict",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "_EnumDict = EnumDict        # keep private name for backwards compatibility\nclass EnumType(type):\n    \"\"\"\n    Metaclass for Enum\n    \"\"\"\n    @classmethod\n    def __prepare__(metacls, cls, bases, **kwds):\n        # check that previous enum members do not exist\n        metacls._check_for_existing_members_(cls, bases)\n        # create the namespace dict",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "EnumMeta",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "EnumMeta = EnumType         # keep EnumMeta name for backwards compatibility\nclass Enum(metaclass=EnumType):\n    \"\"\"\n    Create a collection of name/value pairs.\n    Example enumeration:\n    >>> class Color(Enum):\n    ...     RED = 1\n    ...     BLUE = 2\n    ...     GREEN = 3\n    Access them by:",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "_reduce_ex_by_global_name",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "_reduce_ex_by_global_name = pickle_by_global_name\ndef pickle_by_enum_name(self, proto):\n    # should not be used with Flag-type enums\n    return getattr, (self.__class__, self._name_)\nclass FlagBoundary(StrEnum):\n    \"\"\"\n    control how out of range values are handled\n    \"strict\" -> error is raised             [default for Flag]\n    \"conform\" -> extra bits are discarded\n    \"eject\" -> lose flag status",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "_stdlib_enums",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.enum",
        "description": "pycharm_venv.Lib.enum",
        "peekOfCode": "_stdlib_enums = IntEnum, StrEnum, IntFlag",
        "detail": "pycharm_venv.Lib.enum",
        "documentation": {}
    },
    {
        "label": "fnmatch",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.fnmatch",
        "description": "pycharm_venv.Lib.fnmatch",
        "peekOfCode": "def fnmatch(name, pat):\n    \"\"\"Test whether FILENAME matches PATTERN.\n    Patterns are Unix shell style:\n    *       matches everything\n    ?       matches any single character\n    [seq]   matches any character in seq\n    [!seq]  matches any char not in seq\n    An initial period in FILENAME is not special.\n    Both FILENAME and PATTERN are first case-normalized\n    if the operating system requires it.",
        "detail": "pycharm_venv.Lib.fnmatch",
        "documentation": {}
    },
    {
        "label": "filter",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.fnmatch",
        "description": "pycharm_venv.Lib.fnmatch",
        "peekOfCode": "def filter(names, pat):\n    \"\"\"Construct a list from those elements of the iterable NAMES that match PAT.\"\"\"\n    result = []\n    pat = os.path.normcase(pat)\n    match = _compile_pattern(pat)\n    if os.path is posixpath:\n        # normcase on posix is NOP. Optimize it away from the loop.\n        for name in names:\n            if match(name):\n                result.append(name)",
        "detail": "pycharm_venv.Lib.fnmatch",
        "documentation": {}
    },
    {
        "label": "fnmatchcase",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.fnmatch",
        "description": "pycharm_venv.Lib.fnmatch",
        "peekOfCode": "def fnmatchcase(name, pat):\n    \"\"\"Test whether FILENAME matches PATTERN, including case.\n    This is a version of fnmatch() which doesn't case-normalize\n    its arguments.\n    \"\"\"\n    match = _compile_pattern(pat)\n    return match(name) is not None\ndef translate(pat):\n    \"\"\"Translate a shell PATTERN to a regular expression.\n    There is no way to quote meta-characters.",
        "detail": "pycharm_venv.Lib.fnmatch",
        "documentation": {}
    },
    {
        "label": "translate",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.fnmatch",
        "description": "pycharm_venv.Lib.fnmatch",
        "peekOfCode": "def translate(pat):\n    \"\"\"Translate a shell PATTERN to a regular expression.\n    There is no way to quote meta-characters.\n    \"\"\"\n    STAR = object()\n    parts = _translate(pat, STAR, '.')\n    return _join_translated_parts(parts, STAR)\ndef _translate(pat, STAR, QUESTION_MARK):\n    res = []\n    add = res.append",
        "detail": "pycharm_venv.Lib.fnmatch",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.fnmatch",
        "description": "pycharm_venv.Lib.fnmatch",
        "peekOfCode": "__all__ = [\"filter\", \"fnmatch\", \"fnmatchcase\", \"translate\"]\ndef fnmatch(name, pat):\n    \"\"\"Test whether FILENAME matches PATTERN.\n    Patterns are Unix shell style:\n    *       matches everything\n    ?       matches any single character\n    [seq]   matches any character in seq\n    [!seq]  matches any char not in seq\n    An initial period in FILENAME is not special.\n    Both FILENAME and PATTERN are first case-normalized",
        "detail": "pycharm_venv.Lib.fnmatch",
        "documentation": {}
    },
    {
        "label": "partial",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "class partial:\n    \"\"\"New function with partial application of the given arguments\n    and keywords.\n    \"\"\"\n    __slots__ = \"func\", \"args\", \"keywords\", \"__dict__\", \"__weakref__\"\n    def __new__(cls, func, /, *args, **keywords):\n        if not callable(func):\n            raise TypeError(\"the first argument must be callable\")\n        if isinstance(func, partial):\n            args = func.args + args",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "partialmethod",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "class partialmethod(object):\n    \"\"\"Method descriptor with partial application of the given arguments\n    and keywords.\n    Supports wrapping existing descriptors and handles non-descriptor\n    callables as instance methods.\n    \"\"\"\n    def __init__(self, func, /, *args, **keywords):\n        if not callable(func) and not hasattr(func, \"__get__\"):\n            raise TypeError(\"{!r} is not callable or a descriptor\"\n                                 .format(func))",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "_HashedSeq",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "class _HashedSeq(list):\n    \"\"\" This class guarantees that hash() will be called no more than once\n        per element.  This is important because the lru_cache() will hash\n        the key multiple times on a cache miss.\n    \"\"\"\n    __slots__ = 'hashvalue'\n    def __init__(self, tup, hash=hash):\n        self[:] = tup\n        self.hashvalue = hash(tup)\n    def __hash__(self):",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "singledispatchmethod",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "class singledispatchmethod:\n    \"\"\"Single-dispatch generic method descriptor.\n    Supports wrapping existing descriptors and handles non-descriptor\n    callables as instance methods.\n    \"\"\"\n    def __init__(self, func):\n        if not callable(func) and not hasattr(func, \"__get__\"):\n            raise TypeError(f\"{func!r} is not callable or a descriptor\")\n        self.dispatcher = singledispatch(func)\n        self.func = func",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "cached_property",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "class cached_property:\n    def __init__(self, func):\n        self.func = func\n        self.attrname = None\n        self.__doc__ = func.__doc__\n        self.__module__ = func.__module__\n    def __set_name__(self, owner, name):\n        if self.attrname is None:\n            self.attrname = name\n        elif name != self.attrname:",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "update_wrapper",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "def update_wrapper(wrapper,\n                   wrapped,\n                   assigned = WRAPPER_ASSIGNMENTS,\n                   updated = WRAPPER_UPDATES):\n    \"\"\"Update a wrapper function to look like the wrapped function\n       wrapper is the function to be updated\n       wrapped is the original function\n       assigned is a tuple naming the attributes assigned directly\n       from the wrapped function to the wrapper function (defaults to\n       functools.WRAPPER_ASSIGNMENTS)",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "def wraps(wrapped,\n          assigned = WRAPPER_ASSIGNMENTS,\n          updated = WRAPPER_UPDATES):\n    \"\"\"Decorator factory to apply update_wrapper() to a wrapper function\n       Returns a decorator that invokes update_wrapper() with the decorated\n       function as the wrapper argument and the arguments to wraps() as the\n       remaining arguments. Default arguments are as for update_wrapper().\n       This is a convenience function to simplify applying partial() to\n       update_wrapper().\n    \"\"\"",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "total_ordering",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "def total_ordering(cls):\n    \"\"\"Class decorator that fills in missing ordering methods\"\"\"\n    # Find user-defined comparisons (not those inherited from object).\n    roots = {op for op in _convert if getattr(cls, op, None) is not getattr(object, op, None)}\n    if not roots:\n        raise ValueError('must define at least one ordering operation: < > <= >=')\n    root = max(roots)       # prefer __lt__ to __le__ to __gt__ to __ge__\n    for opname, opfunc in _convert[root]:\n        if opname not in roots:\n            opfunc.__name__ = opname",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "cmp_to_key",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "def cmp_to_key(mycmp):\n    \"\"\"Convert a cmp= function into a key= function\"\"\"\n    class K(object):\n        __slots__ = ['obj']\n        def __init__(self, obj):\n            self.obj = obj\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) < 0\n        def __gt__(self, other):\n            return mycmp(self.obj, other.obj) > 0",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "def reduce(function, sequence, initial=_initial_missing):\n    \"\"\"\n    reduce(function, iterable[, initial], /) -> value\n    Apply a function of two arguments cumulatively to the items of a sequence\n    or iterable, from left to right, so as to reduce the iterable to a single\n    value.  For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\n    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\n    of the iterable in the calculation, and serves as a default when the\n    iterable is empty.\n    \"\"\"",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "def lru_cache(maxsize=128, typed=False):\n    \"\"\"Least-recently-used cache decorator.\n    If *maxsize* is set to None, the LRU features are disabled and the cache\n    can grow without bound.\n    If *typed* is True, arguments of different types will be cached separately.\n    For example, f(decimal.Decimal(\"3.0\")) and f(3.0) will be treated as\n    distinct calls with distinct results. Some types such as str and int may\n    be cached separately even when typed is false.\n    Arguments to the cached function must be hashable.\n    View the cache statistics named tuple (hits, misses, maxsize, currsize)",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "cache",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "def cache(user_function, /):\n    'Simple lightweight unbounded cache.  Sometimes called \"memoize\".'\n    return lru_cache(maxsize=None)(user_function)\n################################################################################\n### singledispatch() - single-dispatch generic function decorator\n################################################################################\ndef _c3_merge(sequences):\n    \"\"\"Merges MROs in *sequences* to a single MRO using the C3 algorithm.\n    Adapted from https://docs.python.org/3/howto/mro.html.\n    \"\"\"",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "singledispatch",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "def singledispatch(func):\n    \"\"\"Single-dispatch generic function decorator.\n    Transforms a function into a generic function, which can have different\n    behaviours depending upon the type of its first argument. The decorated\n    function acts as the default implementation, and additional\n    implementations can be registered using the register() attribute of the\n    generic function.\n    \"\"\"\n    # There are many programs that use functools without singledispatch, so we\n    # trade-off making singledispatch marginally slower for the benefit of",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "__all__ = ['update_wrapper', 'wraps', 'WRAPPER_ASSIGNMENTS', 'WRAPPER_UPDATES',\n           'total_ordering', 'cache', 'cmp_to_key', 'lru_cache', 'reduce',\n           'partial', 'partialmethod', 'singledispatch', 'singledispatchmethod',\n           'cached_property']\nfrom abc import get_cache_token\nfrom collections import namedtuple\n# import types, weakref  # Deferred to single_dispatch()\nfrom reprlib import recursive_repr\nfrom _thread import RLock\n# Avoid importing types, so we can speedup import time",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "GenericAlias",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "GenericAlias = type(list[int])\n################################################################################\n### update_wrapper() and wraps() decorator\n################################################################################\n# update_wrapper() and wraps() are tools to help write\n# wrapper functions that can handle naive introspection\nWRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__qualname__', '__doc__',\n                       '__annotations__', '__type_params__')\nWRAPPER_UPDATES = ('__dict__',)\ndef update_wrapper(wrapper,",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "WRAPPER_ASSIGNMENTS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "WRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__qualname__', '__doc__',\n                       '__annotations__', '__type_params__')\nWRAPPER_UPDATES = ('__dict__',)\ndef update_wrapper(wrapper,\n                   wrapped,\n                   assigned = WRAPPER_ASSIGNMENTS,\n                   updated = WRAPPER_UPDATES):\n    \"\"\"Update a wrapper function to look like the wrapped function\n       wrapper is the function to be updated\n       wrapped is the original function",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "WRAPPER_UPDATES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "WRAPPER_UPDATES = ('__dict__',)\ndef update_wrapper(wrapper,\n                   wrapped,\n                   assigned = WRAPPER_ASSIGNMENTS,\n                   updated = WRAPPER_UPDATES):\n    \"\"\"Update a wrapper function to look like the wrapped function\n       wrapper is the function to be updated\n       wrapped is the original function\n       assigned is a tuple naming the attributes assigned directly\n       from the wrapped function to the wrapper function (defaults to",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "_convert",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "_convert = {\n    '__lt__': [('__gt__', _gt_from_lt),\n               ('__le__', _le_from_lt),\n               ('__ge__', _ge_from_lt)],\n    '__le__': [('__ge__', _ge_from_le),\n               ('__lt__', _lt_from_le),\n               ('__gt__', _gt_from_le)],\n    '__gt__': [('__lt__', _lt_from_gt),\n               ('__ge__', _ge_from_gt),\n               ('__le__', _le_from_gt)],",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "_initial_missing",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "_initial_missing = object()\ndef reduce(function, sequence, initial=_initial_missing):\n    \"\"\"\n    reduce(function, iterable[, initial], /) -> value\n    Apply a function of two arguments cumulatively to the items of a sequence\n    or iterable, from left to right, so as to reduce the iterable to a single\n    value.  For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\n    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\n    of the iterable in the calculation, and serves as a default when the\n    iterable is empty.",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "_CacheInfo",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "_CacheInfo = namedtuple(\"CacheInfo\", [\"hits\", \"misses\", \"maxsize\", \"currsize\"])\nclass _HashedSeq(list):\n    \"\"\" This class guarantees that hash() will be called no more than once\n        per element.  This is important because the lru_cache() will hash\n        the key multiple times on a cache miss.\n    \"\"\"\n    __slots__ = 'hashvalue'\n    def __init__(self, tup, hash=hash):\n        self[:] = tup\n        self.hashvalue = hash(tup)",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "_NOT_FOUND",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.functools",
        "description": "pycharm_venv.Lib.functools",
        "peekOfCode": "_NOT_FOUND = object()\nclass cached_property:\n    def __init__(self, func):\n        self.func = func\n        self.attrname = None\n        self.__doc__ = func.__doc__\n        self.__module__ = func.__module__\n    def __set_name__(self, owner, name):\n        if self.attrname is None:\n            self.attrname = name",
        "detail": "pycharm_venv.Lib.functools",
        "documentation": {}
    },
    {
        "label": "file_digest",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.hashlib",
        "description": "pycharm_venv.Lib.hashlib",
        "peekOfCode": "def file_digest(fileobj, digest, /, *, _bufsize=2**18):\n    \"\"\"Hash the contents of a file-like object. Returns a digest object.\n    *fileobj* must be a file-like object opened for reading in binary mode.\n    It accepts file objects from open(), io.BytesIO(), and SocketIO objects.\n    The function may bypass Python's I/O and use the file descriptor *fileno*\n    directly.\n    *digest* must either be a hash algorithm name as a *str*, a hash\n    constructor, or a callable that returns a hash object.\n    \"\"\"\n    # On Linux we could use AF_ALG sockets and sendfile() to archive zero-copy",
        "detail": "pycharm_venv.Lib.hashlib",
        "documentation": {}
    },
    {
        "label": "__doc__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.hashlib",
        "description": "pycharm_venv.Lib.hashlib",
        "peekOfCode": "__doc__ = \"\"\"hashlib module - A common interface to many hash functions.\nnew(name, data=b'', **kwargs) - returns a new hash object implementing the\n                                given hash function; initializing the hash\n                                using the given binary data.\nNamed constructor functions are also available, these are faster\nthan using new(name):\nmd5(), sha1(), sha224(), sha256(), sha384(), sha512(), blake2b(), blake2s(),\nsha3_224, sha3_256, sha3_384, sha3_512, shake_128, and shake_256.\nMore algorithms may be available on your platform but the above are guaranteed\nto exist.  See the algorithms_guaranteed and algorithms_available attributes",
        "detail": "pycharm_venv.Lib.hashlib",
        "documentation": {}
    },
    {
        "label": "__always_supported",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.hashlib",
        "description": "pycharm_venv.Lib.hashlib",
        "peekOfCode": "__always_supported = ('md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',\n                      'blake2b', 'blake2s',\n                      'sha3_224', 'sha3_256', 'sha3_384', 'sha3_512',\n                      'shake_128', 'shake_256')\nalgorithms_guaranteed = set(__always_supported)\nalgorithms_available = set(__always_supported)\n__all__ = __always_supported + ('new', 'algorithms_guaranteed',\n                                'algorithms_available', 'file_digest')\n__builtin_constructor_cache = {}\n# Prefer our blake2 implementation",
        "detail": "pycharm_venv.Lib.hashlib",
        "documentation": {}
    },
    {
        "label": "algorithms_guaranteed",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.hashlib",
        "description": "pycharm_venv.Lib.hashlib",
        "peekOfCode": "algorithms_guaranteed = set(__always_supported)\nalgorithms_available = set(__always_supported)\n__all__ = __always_supported + ('new', 'algorithms_guaranteed',\n                                'algorithms_available', 'file_digest')\n__builtin_constructor_cache = {}\n# Prefer our blake2 implementation\n# OpenSSL 1.1.0 comes with a limited implementation of blake2b/s. The OpenSSL\n# implementations neither support keyed blake2 (blake2 MAC) nor advanced\n# features like salt, personalization, or tree hashing. OpenSSL hash-only\n# variants are available as 'blake2b512' and 'blake2s256', though.",
        "detail": "pycharm_venv.Lib.hashlib",
        "documentation": {}
    },
    {
        "label": "algorithms_available",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.hashlib",
        "description": "pycharm_venv.Lib.hashlib",
        "peekOfCode": "algorithms_available = set(__always_supported)\n__all__ = __always_supported + ('new', 'algorithms_guaranteed',\n                                'algorithms_available', 'file_digest')\n__builtin_constructor_cache = {}\n# Prefer our blake2 implementation\n# OpenSSL 1.1.0 comes with a limited implementation of blake2b/s. The OpenSSL\n# implementations neither support keyed blake2 (blake2 MAC) nor advanced\n# features like salt, personalization, or tree hashing. OpenSSL hash-only\n# variants are available as 'blake2b512' and 'blake2s256', though.\n__block_openssl_constructor = {",
        "detail": "pycharm_venv.Lib.hashlib",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.hashlib",
        "description": "pycharm_venv.Lib.hashlib",
        "peekOfCode": "__all__ = __always_supported + ('new', 'algorithms_guaranteed',\n                                'algorithms_available', 'file_digest')\n__builtin_constructor_cache = {}\n# Prefer our blake2 implementation\n# OpenSSL 1.1.0 comes with a limited implementation of blake2b/s. The OpenSSL\n# implementations neither support keyed blake2 (blake2 MAC) nor advanced\n# features like salt, personalization, or tree hashing. OpenSSL hash-only\n# variants are available as 'blake2b512' and 'blake2s256', though.\n__block_openssl_constructor = {\n    'blake2b', 'blake2s',",
        "detail": "pycharm_venv.Lib.hashlib",
        "documentation": {}
    },
    {
        "label": "__builtin_constructor_cache",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.hashlib",
        "description": "pycharm_venv.Lib.hashlib",
        "peekOfCode": "__builtin_constructor_cache = {}\n# Prefer our blake2 implementation\n# OpenSSL 1.1.0 comes with a limited implementation of blake2b/s. The OpenSSL\n# implementations neither support keyed blake2 (blake2 MAC) nor advanced\n# features like salt, personalization, or tree hashing. OpenSSL hash-only\n# variants are available as 'blake2b512' and 'blake2s256', though.\n__block_openssl_constructor = {\n    'blake2b', 'blake2s',\n}\ndef __get_builtin_constructor(name):",
        "detail": "pycharm_venv.Lib.hashlib",
        "documentation": {}
    },
    {
        "label": "__block_openssl_constructor",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.hashlib",
        "description": "pycharm_venv.Lib.hashlib",
        "peekOfCode": "__block_openssl_constructor = {\n    'blake2b', 'blake2s',\n}\ndef __get_builtin_constructor(name):\n    cache = __builtin_constructor_cache\n    constructor = cache.get(name)\n    if constructor is not None:\n        return constructor\n    try:\n        if name in {'SHA1', 'sha1'}:",
        "detail": "pycharm_venv.Lib.hashlib",
        "documentation": {}
    },
    {
        "label": "heappush",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.heapq",
        "description": "pycharm_venv.Lib.heapq",
        "peekOfCode": "def heappush(heap, item):\n    \"\"\"Push item onto heap, maintaining the heap invariant.\"\"\"\n    heap.append(item)\n    _siftdown(heap, 0, len(heap)-1)\ndef heappop(heap):\n    \"\"\"Pop the smallest item off the heap, maintaining the heap invariant.\"\"\"\n    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty\n    if heap:\n        returnitem = heap[0]\n        heap[0] = lastelt",
        "detail": "pycharm_venv.Lib.heapq",
        "documentation": {}
    },
    {
        "label": "heappop",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.heapq",
        "description": "pycharm_venv.Lib.heapq",
        "peekOfCode": "def heappop(heap):\n    \"\"\"Pop the smallest item off the heap, maintaining the heap invariant.\"\"\"\n    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty\n    if heap:\n        returnitem = heap[0]\n        heap[0] = lastelt\n        _siftup(heap, 0)\n        return returnitem\n    return lastelt\ndef heapreplace(heap, item):",
        "detail": "pycharm_venv.Lib.heapq",
        "documentation": {}
    },
    {
        "label": "heapreplace",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.heapq",
        "description": "pycharm_venv.Lib.heapq",
        "peekOfCode": "def heapreplace(heap, item):\n    \"\"\"Pop and return the current smallest value, and add the new item.\n    This is more efficient than heappop() followed by heappush(), and can be\n    more appropriate when using a fixed-size heap.  Note that the value\n    returned may be larger than item!  That constrains reasonable uses of\n    this routine unless written as part of a conditional replacement:\n        if item > heap[0]:\n            item = heapreplace(heap, item)\n    \"\"\"\n    returnitem = heap[0]    # raises appropriate IndexError if heap is empty",
        "detail": "pycharm_venv.Lib.heapq",
        "documentation": {}
    },
    {
        "label": "heappushpop",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.heapq",
        "description": "pycharm_venv.Lib.heapq",
        "peekOfCode": "def heappushpop(heap, item):\n    \"\"\"Fast version of a heappush followed by a heappop.\"\"\"\n    if heap and heap[0] < item:\n        item, heap[0] = heap[0], item\n        _siftup(heap, 0)\n    return item\ndef heapify(x):\n    \"\"\"Transform list into a heap, in-place, in O(len(x)) time.\"\"\"\n    n = len(x)\n    # Transform bottom-up.  The largest index there's any point to looking at",
        "detail": "pycharm_venv.Lib.heapq",
        "documentation": {}
    },
    {
        "label": "heapify",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.heapq",
        "description": "pycharm_venv.Lib.heapq",
        "peekOfCode": "def heapify(x):\n    \"\"\"Transform list into a heap, in-place, in O(len(x)) time.\"\"\"\n    n = len(x)\n    # Transform bottom-up.  The largest index there's any point to looking at\n    # is the largest with a child index in-range, so must have 2*i + 1 < n,\n    # or i < (n-1)/2.  If n is even = 2*j, this is (2*j-1)/2 = j-1/2 so\n    # j-1 is the largest, which is n//2 - 1.  If n is odd = 2*j+1, this is\n    # (2*j+1-1)/2 = j so j-1 is the largest, and that's again n//2-1.\n    for i in reversed(range(n//2)):\n        _siftup(x, i)",
        "detail": "pycharm_venv.Lib.heapq",
        "documentation": {}
    },
    {
        "label": "merge",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.heapq",
        "description": "pycharm_venv.Lib.heapq",
        "peekOfCode": "def merge(*iterables, key=None, reverse=False):\n    '''Merge multiple sorted inputs into a single sorted output.\n    Similar to sorted(itertools.chain(*iterables)) but returns a generator,\n    does not pull the data into memory all at once, and assumes that each of\n    the input streams is already sorted (smallest to largest).\n    >>> list(merge([1,3,5,7], [0,2,4,8], [5,10,15,20], [], [25]))\n    [0, 1, 2, 3, 4, 5, 5, 7, 8, 10, 15, 20, 25]\n    If *key* is not None, applies a key function to each element to determine\n    its sort order.\n    >>> list(merge(['dog', 'horse'], ['cat', 'fish', 'kangaroo'], key=len))",
        "detail": "pycharm_venv.Lib.heapq",
        "documentation": {}
    },
    {
        "label": "nsmallest",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.heapq",
        "description": "pycharm_venv.Lib.heapq",
        "peekOfCode": "def nsmallest(n, iterable, key=None):\n    \"\"\"Find the n smallest elements in a dataset.\n    Equivalent to:  sorted(iterable, key=key)[:n]\n    \"\"\"\n    # Short-cut for n==1 is to use min()\n    if n == 1:\n        it = iter(iterable)\n        sentinel = object()\n        result = min(it, default=sentinel, key=key)\n        return [] if result is sentinel else [result]",
        "detail": "pycharm_venv.Lib.heapq",
        "documentation": {}
    },
    {
        "label": "nlargest",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.heapq",
        "description": "pycharm_venv.Lib.heapq",
        "peekOfCode": "def nlargest(n, iterable, key=None):\n    \"\"\"Find the n largest elements in a dataset.\n    Equivalent to:  sorted(iterable, key=key, reverse=True)[:n]\n    \"\"\"\n    # Short-cut for n==1 is to use max()\n    if n == 1:\n        it = iter(iterable)\n        sentinel = object()\n        result = max(it, default=sentinel, key=key)\n        return [] if result is sentinel else [result]",
        "detail": "pycharm_venv.Lib.heapq",
        "documentation": {}
    },
    {
        "label": "heap",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.heapq",
        "description": "pycharm_venv.Lib.heapq",
        "peekOfCode": "heap = []            # creates an empty heap\nheappush(heap, item) # pushes a new item on the heap\nitem = heappop(heap) # pops the smallest item from the heap\nitem = heap[0]       # smallest item on the heap without popping it\nheapify(x)           # transforms list into a heap, in-place, in linear time\nitem = heappushpop(heap, item) # pushes a new item and then returns\n                               # the smallest item; the heap size is unchanged\nitem = heapreplace(heap, item) # pops and returns smallest item, and adds\n                               # new item; the heap size is unchanged\nOur API differs from textbook heap algorithms as follows:",
        "detail": "pycharm_venv.Lib.heapq",
        "documentation": {}
    },
    {
        "label": "item",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.heapq",
        "description": "pycharm_venv.Lib.heapq",
        "peekOfCode": "item = heappop(heap) # pops the smallest item from the heap\nitem = heap[0]       # smallest item on the heap without popping it\nheapify(x)           # transforms list into a heap, in-place, in linear time\nitem = heappushpop(heap, item) # pushes a new item and then returns\n                               # the smallest item; the heap size is unchanged\nitem = heapreplace(heap, item) # pops and returns smallest item, and adds\n                               # new item; the heap size is unchanged\nOur API differs from textbook heap algorithms as follows:\n- We use 0-based indexing.  This makes the relationship between the\n  index for a node and the indexes for its children slightly less",
        "detail": "pycharm_venv.Lib.heapq",
        "documentation": {}
    },
    {
        "label": "item",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.heapq",
        "description": "pycharm_venv.Lib.heapq",
        "peekOfCode": "item = heap[0]       # smallest item on the heap without popping it\nheapify(x)           # transforms list into a heap, in-place, in linear time\nitem = heappushpop(heap, item) # pushes a new item and then returns\n                               # the smallest item; the heap size is unchanged\nitem = heapreplace(heap, item) # pops and returns smallest item, and adds\n                               # new item; the heap size is unchanged\nOur API differs from textbook heap algorithms as follows:\n- We use 0-based indexing.  This makes the relationship between the\n  index for a node and the indexes for its children slightly less\n  obvious, but is more suitable since Python uses 0-based indexing.",
        "detail": "pycharm_venv.Lib.heapq",
        "documentation": {}
    },
    {
        "label": "item",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.heapq",
        "description": "pycharm_venv.Lib.heapq",
        "peekOfCode": "item = heappushpop(heap, item) # pushes a new item and then returns\n                               # the smallest item; the heap size is unchanged\nitem = heapreplace(heap, item) # pops and returns smallest item, and adds\n                               # new item; the heap size is unchanged\nOur API differs from textbook heap algorithms as follows:\n- We use 0-based indexing.  This makes the relationship between the\n  index for a node and the indexes for its children slightly less\n  obvious, but is more suitable since Python uses 0-based indexing.\n- Our heappop() method returns the smallest item, not the largest.\nThese two make it possible to view the heap as a regular Python list",
        "detail": "pycharm_venv.Lib.heapq",
        "documentation": {}
    },
    {
        "label": "item",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.heapq",
        "description": "pycharm_venv.Lib.heapq",
        "peekOfCode": "item = heapreplace(heap, item) # pops and returns smallest item, and adds\n                               # new item; the heap size is unchanged\nOur API differs from textbook heap algorithms as follows:\n- We use 0-based indexing.  This makes the relationship between the\n  index for a node and the indexes for its children slightly less\n  obvious, but is more suitable since Python uses 0-based indexing.\n- Our heappop() method returns the smallest item, not the largest.\nThese two make it possible to view the heap as a regular Python list\nwithout surprises: heap[0] is the smallest item, and heap.sort()\nmaintains the heap invariant!",
        "detail": "pycharm_venv.Lib.heapq",
        "documentation": {}
    },
    {
        "label": "__about__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.heapq",
        "description": "pycharm_venv.Lib.heapq",
        "peekOfCode": "__about__ = \"\"\"Heap queues\n[explanation by Franois Pinard]\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\nThe strange invariant above is meant to be an efficient memory\nrepresentation for a tournament.  The numbers below are `k', not a[k]:\n                                   0\n                  1                                 2",
        "detail": "pycharm_venv.Lib.heapq",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.heapq",
        "description": "pycharm_venv.Lib.heapq",
        "peekOfCode": "__all__ = ['heappush', 'heappop', 'heapify', 'heapreplace', 'merge',\n           'nlargest', 'nsmallest', 'heappushpop']\ndef heappush(heap, item):\n    \"\"\"Push item onto heap, maintaining the heap invariant.\"\"\"\n    heap.append(item)\n    _siftdown(heap, 0, len(heap)-1)\ndef heappop(heap):\n    \"\"\"Pop the smallest item off the heap, maintaining the heap invariant.\"\"\"\n    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty\n    if heap:",
        "detail": "pycharm_venv.Lib.heapq",
        "documentation": {}
    },
    {
        "label": "HMAC",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.hmac",
        "description": "pycharm_venv.Lib.hmac",
        "peekOfCode": "class HMAC:\n    \"\"\"RFC 2104 HMAC class.  Also complies with RFC 4231.\n    This supports the API for Cryptographic Hash Functions (PEP 247).\n    \"\"\"\n    blocksize = 64  # 512-bit HMAC; can be changed in subclasses.\n    __slots__ = (\n        \"_hmac\", \"_inner\", \"_outer\", \"block_size\", \"digest_size\"\n    )\n    def __init__(self, key, msg=None, digestmod=''):\n        \"\"\"Create a new HMAC object.",
        "detail": "pycharm_venv.Lib.hmac",
        "documentation": {}
    },
    {
        "label": "new",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.hmac",
        "description": "pycharm_venv.Lib.hmac",
        "peekOfCode": "def new(key, msg=None, digestmod=''):\n    \"\"\"Create a new hashing object and return it.\n    key: bytes or buffer, The starting key for the hash.\n    msg: bytes or buffer, Initial input for the hash, or None.\n    digestmod: A hash name suitable for hashlib.new(). *OR*\n               A hashlib constructor returning a new hash object. *OR*\n               A module supporting PEP 247.\n               Required as of 3.8, despite its position after the optional\n               msg argument.  Passing it as a keyword argument is\n               recommended, though not required for legacy API reasons.",
        "detail": "pycharm_venv.Lib.hmac",
        "documentation": {}
    },
    {
        "label": "digest",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.hmac",
        "description": "pycharm_venv.Lib.hmac",
        "peekOfCode": "def digest(key, msg, digest):\n    \"\"\"Fast inline implementation of HMAC.\n    key: bytes or buffer, The key for the keyed hash object.\n    msg: bytes or buffer, Input message.\n    digest: A hash name suitable for hashlib.new() for best performance. *OR*\n            A hashlib constructor returning a new hash object. *OR*\n            A module supporting PEP 247.\n    \"\"\"\n    if _hashopenssl is not None and isinstance(digest, (str, _functype)):\n        try:",
        "detail": "pycharm_venv.Lib.hmac",
        "documentation": {}
    },
    {
        "label": "trans_5C",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.hmac",
        "description": "pycharm_venv.Lib.hmac",
        "peekOfCode": "trans_5C = bytes((x ^ 0x5C) for x in range(256))\ntrans_36 = bytes((x ^ 0x36) for x in range(256))\n# The size of the digests returned by HMAC depends on the underlying\n# hashing module used.  Use digest_size from the instance of HMAC instead.\ndigest_size = None\nclass HMAC:\n    \"\"\"RFC 2104 HMAC class.  Also complies with RFC 4231.\n    This supports the API for Cryptographic Hash Functions (PEP 247).\n    \"\"\"\n    blocksize = 64  # 512-bit HMAC; can be changed in subclasses.",
        "detail": "pycharm_venv.Lib.hmac",
        "documentation": {}
    },
    {
        "label": "trans_36",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.hmac",
        "description": "pycharm_venv.Lib.hmac",
        "peekOfCode": "trans_36 = bytes((x ^ 0x36) for x in range(256))\n# The size of the digests returned by HMAC depends on the underlying\n# hashing module used.  Use digest_size from the instance of HMAC instead.\ndigest_size = None\nclass HMAC:\n    \"\"\"RFC 2104 HMAC class.  Also complies with RFC 4231.\n    This supports the API for Cryptographic Hash Functions (PEP 247).\n    \"\"\"\n    blocksize = 64  # 512-bit HMAC; can be changed in subclasses.\n    __slots__ = (",
        "detail": "pycharm_venv.Lib.hmac",
        "documentation": {}
    },
    {
        "label": "digest_size",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.hmac",
        "description": "pycharm_venv.Lib.hmac",
        "peekOfCode": "digest_size = None\nclass HMAC:\n    \"\"\"RFC 2104 HMAC class.  Also complies with RFC 4231.\n    This supports the API for Cryptographic Hash Functions (PEP 247).\n    \"\"\"\n    blocksize = 64  # 512-bit HMAC; can be changed in subclasses.\n    __slots__ = (\n        \"_hmac\", \"_inner\", \"_outer\", \"block_size\", \"digest_size\"\n    )\n    def __init__(self, key, msg=None, digestmod=''):",
        "detail": "pycharm_venv.Lib.hmac",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.keyword",
        "description": "pycharm_venv.Lib.keyword",
        "peekOfCode": "__all__ = [\"iskeyword\", \"issoftkeyword\", \"kwlist\", \"softkwlist\"]\nkwlist = [\n    'False',\n    'None',\n    'True',\n    'and',\n    'as',\n    'assert',\n    'async',\n    'await',",
        "detail": "pycharm_venv.Lib.keyword",
        "documentation": {}
    },
    {
        "label": "kwlist",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.keyword",
        "description": "pycharm_venv.Lib.keyword",
        "peekOfCode": "kwlist = [\n    'False',\n    'None',\n    'True',\n    'and',\n    'as',\n    'assert',\n    'async',\n    'await',\n    'break',",
        "detail": "pycharm_venv.Lib.keyword",
        "documentation": {}
    },
    {
        "label": "softkwlist",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.keyword",
        "description": "pycharm_venv.Lib.keyword",
        "peekOfCode": "softkwlist = [\n    '_',\n    'case',\n    'match',\n    'type'\n]\niskeyword = frozenset(kwlist).__contains__\nissoftkeyword = frozenset(softkwlist).__contains__",
        "detail": "pycharm_venv.Lib.keyword",
        "documentation": {}
    },
    {
        "label": "iskeyword",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.keyword",
        "description": "pycharm_venv.Lib.keyword",
        "peekOfCode": "iskeyword = frozenset(kwlist).__contains__\nissoftkeyword = frozenset(softkwlist).__contains__",
        "detail": "pycharm_venv.Lib.keyword",
        "documentation": {}
    },
    {
        "label": "issoftkeyword",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.keyword",
        "description": "pycharm_venv.Lib.keyword",
        "peekOfCode": "issoftkeyword = frozenset(softkwlist).__contains__",
        "detail": "pycharm_venv.Lib.keyword",
        "documentation": {}
    },
    {
        "label": "clearcache",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.linecache",
        "description": "pycharm_venv.Lib.linecache",
        "peekOfCode": "def clearcache():\n    \"\"\"Clear the cache entirely.\"\"\"\n    cache.clear()\ndef getline(filename, lineno, module_globals=None):\n    \"\"\"Get a line for a Python source file from the cache.\n    Update the cache if it doesn't contain an entry for this file already.\"\"\"\n    lines = getlines(filename, module_globals)\n    if 1 <= lineno <= len(lines):\n        return lines[lineno - 1]\n    return ''",
        "detail": "pycharm_venv.Lib.linecache",
        "documentation": {}
    },
    {
        "label": "getline",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.linecache",
        "description": "pycharm_venv.Lib.linecache",
        "peekOfCode": "def getline(filename, lineno, module_globals=None):\n    \"\"\"Get a line for a Python source file from the cache.\n    Update the cache if it doesn't contain an entry for this file already.\"\"\"\n    lines = getlines(filename, module_globals)\n    if 1 <= lineno <= len(lines):\n        return lines[lineno - 1]\n    return ''\ndef getlines(filename, module_globals=None):\n    \"\"\"Get the lines for a Python source file from the cache.\n    Update the cache if it doesn't contain an entry for this file already.\"\"\"",
        "detail": "pycharm_venv.Lib.linecache",
        "documentation": {}
    },
    {
        "label": "getlines",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.linecache",
        "description": "pycharm_venv.Lib.linecache",
        "peekOfCode": "def getlines(filename, module_globals=None):\n    \"\"\"Get the lines for a Python source file from the cache.\n    Update the cache if it doesn't contain an entry for this file already.\"\"\"\n    if filename in cache:\n        entry = cache[filename]\n        if len(entry) != 1:\n            return cache[filename][2]\n    try:\n        return updatecache(filename, module_globals)\n    except MemoryError:",
        "detail": "pycharm_venv.Lib.linecache",
        "documentation": {}
    },
    {
        "label": "checkcache",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.linecache",
        "description": "pycharm_venv.Lib.linecache",
        "peekOfCode": "def checkcache(filename=None):\n    \"\"\"Discard cache entries that are out of date.\n    (This is not checked upon each call!)\"\"\"\n    if filename is None:\n        filenames = list(cache.keys())\n    elif filename in cache:\n        filenames = [filename]\n    else:\n        return\n    for filename in filenames:",
        "detail": "pycharm_venv.Lib.linecache",
        "documentation": {}
    },
    {
        "label": "updatecache",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.linecache",
        "description": "pycharm_venv.Lib.linecache",
        "peekOfCode": "def updatecache(filename, module_globals=None):\n    \"\"\"Update a cache entry and return its list of lines.\n    If something's wrong, print a message, discard the cache entry,\n    and return an empty list.\"\"\"\n    # These imports are not at top level because linecache is in the critical\n    # path of the interpreter startup and importing os and sys take a lot of time\n    # and slows down the startup sequence.\n    import os\n    import sys\n    import tokenize",
        "detail": "pycharm_venv.Lib.linecache",
        "documentation": {}
    },
    {
        "label": "lazycache",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.linecache",
        "description": "pycharm_venv.Lib.linecache",
        "peekOfCode": "def lazycache(filename, module_globals):\n    \"\"\"Seed the cache for filename with module_globals.\n    The module loader will be asked for the source only when getlines is\n    called, not immediately.\n    If there is an entry in the cache already, it is not altered.\n    :return: True if a lazy load is registered in the cache,\n        otherwise False. To register such a load a module loader with a\n        get_source method must be found, the filename must be a cacheable\n        filename, and the filename must not be already cached.\n    \"\"\"",
        "detail": "pycharm_venv.Lib.linecache",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.linecache",
        "description": "pycharm_venv.Lib.linecache",
        "peekOfCode": "__all__ = [\"getline\", \"clearcache\", \"checkcache\", \"lazycache\"]\n# The cache. Maps filenames to either a thunk which will provide source code,\n# or a tuple (size, mtime, lines, fullname) once loaded.\ncache = {}\ndef clearcache():\n    \"\"\"Clear the cache entirely.\"\"\"\n    cache.clear()\ndef getline(filename, lineno, module_globals=None):\n    \"\"\"Get a line for a Python source file from the cache.\n    Update the cache if it doesn't contain an entry for this file already.\"\"\"",
        "detail": "pycharm_venv.Lib.linecache",
        "documentation": {}
    },
    {
        "label": "cache",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.linecache",
        "description": "pycharm_venv.Lib.linecache",
        "peekOfCode": "cache = {}\ndef clearcache():\n    \"\"\"Clear the cache entirely.\"\"\"\n    cache.clear()\ndef getline(filename, lineno, module_globals=None):\n    \"\"\"Get a line for a Python source file from the cache.\n    Update the cache if it doesn't contain an entry for this file already.\"\"\"\n    lines = getlines(filename, module_globals)\n    if 1 <= lineno <= len(lines):\n        return lines[lineno - 1]",
        "detail": "pycharm_venv.Lib.linecache",
        "documentation": {}
    },
    {
        "label": "localeconv",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "def localeconv():\n    d = _localeconv()\n    if _override_localeconv:\n        d.update(_override_localeconv)\n    return d\n### Number formatting APIs\n# Author: Martin von Loewis\n# improved by Georg Brandl\n# Iterate over grouping intervals\ndef _grouping_intervals(grouping):",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "format_string",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "def format_string(f, val, grouping=False, monetary=False):\n    \"\"\"Formats a string in the same way that the % formatting would use,\n    but takes the current locale into account.\n    Grouping is applied if the third parameter is true.\n    Conversion uses monetary thousands separator and grouping strings if\n    forth parameter monetary is true.\"\"\"\n    percents = list(_percent_re.finditer(f))\n    new_f = _percent_re.sub('%s', f)\n    if isinstance(val, _collections_abc.Mapping):\n        new_val = []",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "currency",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "def currency(val, symbol=True, grouping=False, international=False):\n    \"\"\"Formats val according to the currency settings\n    in the current locale.\"\"\"\n    conv = localeconv()\n    # check for illegal values\n    digits = conv[international and 'int_frac_digits' or 'frac_digits']\n    if digits == 127:\n        raise ValueError(\"Currency formatting is not possible using \"\n                         \"the 'C' locale.\")\n    s = _localize(f'{abs(val):.{digits}f}', grouping, monetary=True)",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "str",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "def str(val):\n    \"\"\"Convert float to string, taking the locale into account.\"\"\"\n    return _format(\"%.12g\", val)\ndef delocalize(string):\n    \"Parses a string as a normalized number according to the locale settings.\"\n    conv = localeconv()\n    #First, get rid of the grouping\n    ts = conv['thousands_sep']\n    if ts:\n        string = string.replace(ts, '')",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "delocalize",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "def delocalize(string):\n    \"Parses a string as a normalized number according to the locale settings.\"\n    conv = localeconv()\n    #First, get rid of the grouping\n    ts = conv['thousands_sep']\n    if ts:\n        string = string.replace(ts, '')\n    #next, replace the decimal point with a dot\n    dd = conv['decimal_point']\n    if dd:",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "localize",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "def localize(string, grouping=False, monetary=False):\n    \"\"\"Parses a string as locale number according to the locale settings.\"\"\"\n    return _localize(string, grouping, monetary)\ndef atof(string, func=float):\n    \"Parses a string as a float according to the locale settings.\"\n    return func(delocalize(string))\ndef atoi(string):\n    \"Converts a string to an integer according to the locale settings.\"\n    return int(delocalize(string))\ndef _test():",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "atof",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "def atof(string, func=float):\n    \"Parses a string as a float according to the locale settings.\"\n    return func(delocalize(string))\ndef atoi(string):\n    \"Converts a string to an integer according to the locale settings.\"\n    return int(delocalize(string))\ndef _test():\n    setlocale(LC_ALL, \"\")\n    #do grouping\n    s1 = format_string(\"%d\", 123456789,1)",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "atoi",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "def atoi(string):\n    \"Converts a string to an integer according to the locale settings.\"\n    return int(delocalize(string))\ndef _test():\n    setlocale(LC_ALL, \"\")\n    #do grouping\n    s1 = format_string(\"%d\", 123456789,1)\n    print(s1, \"is\", atoi(s1))\n    #standard formatting\n    s1 = str(3.14)",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "normalize",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "def normalize(localename):\n    \"\"\" Returns a normalized locale code for the given locale\n        name.\n        The returned locale code is formatted for use with\n        setlocale().\n        If normalization fails, the original name is returned\n        unchanged.\n        If the given encoding is not known, the function defaults to\n        the default encoding for the locale code just like setlocale()\n        does.",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "getdefaultlocale",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "def getdefaultlocale(envvars=('LC_ALL', 'LC_CTYPE', 'LANG', 'LANGUAGE')):\n    \"\"\" Tries to determine the default locale settings and returns\n        them as tuple (language code, encoding).\n        According to POSIX, a program which has not called\n        setlocale(LC_ALL, \"\") runs using the portable 'C' locale.\n        Calling setlocale(LC_ALL, \"\") lets it use the default locale as\n        defined by the LANG variable. Since we don't want to interfere\n        with the current locale setting we thus emulate the behavior\n        in the way described above.\n        To maintain compatibility with other platforms, not only the",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "getlocale",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "def getlocale(category=LC_CTYPE):\n    \"\"\" Returns the current setting for the given locale category as\n        tuple (language code, encoding).\n        category may be one of the LC_* value except LC_ALL. It\n        defaults to LC_CTYPE.\n        Except for the code 'C', the language code corresponds to RFC\n        1766.  code and encoding can be None in case the values cannot\n        be determined.\n    \"\"\"\n    localename = _setlocale(category)",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "setlocale",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "def setlocale(category, locale=None):\n    \"\"\" Set the locale for the given category.  The locale can be\n        a string, an iterable of two strings (language code and encoding),\n        or None.\n        Iterables are converted to strings using the locale aliasing\n        engine.  Locale strings are passed directly to the C lib.\n        category may be given as one of the LC_* values.\n    \"\"\"\n    if locale and not isinstance(locale, _builtin_str):\n        # convert to string",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "__all__ = [\"getlocale\", \"getdefaultlocale\", \"getpreferredencoding\", \"Error\",\n           \"setlocale\", \"localeconv\", \"strcoll\", \"strxfrm\",\n           \"str\", \"atof\", \"atoi\", \"format_string\", \"currency\",\n           \"normalize\", \"LC_CTYPE\", \"LC_COLLATE\", \"LC_TIME\", \"LC_MONETARY\",\n           \"LC_NUMERIC\", \"LC_ALL\", \"CHAR_MAX\", \"getencoding\"]\ndef _strcoll(a,b):\n    \"\"\" strcoll(string,string) -> int.\n        Compares two strings according to the locale.\n    \"\"\"\n    return (a > b) - (a < b)",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "_localeconv",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "_localeconv = localeconv\n# With this dict, you can override some items of localeconv's return value.\n# This is useful for testing purposes.\n_override_localeconv = {}\n@functools.wraps(_localeconv)\ndef localeconv():\n    d = _localeconv()\n    if _override_localeconv:\n        d.update(_override_localeconv)\n    return d",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "_override_localeconv",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "_override_localeconv = {}\n@functools.wraps(_localeconv)\ndef localeconv():\n    d = _localeconv()\n    if _override_localeconv:\n        d.update(_override_localeconv)\n    return d\n### Number formatting APIs\n# Author: Martin von Loewis\n# improved by Georg Brandl",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "_percent_re",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "_percent_re = re.compile(r'%(?:\\((?P<key>.*?)\\))?'\n                         r'(?P<modifiers>[-#0-9 +*.hlL]*?)[eEfFgGdiouxXcrs%]')\ndef _format(percent, value, grouping=False, monetary=False, *additional):\n    if additional:\n        formatted = percent % ((value,) + additional)\n    else:\n        formatted = percent % value\n    if percent[-1] in 'eEfFgGdiu':\n        formatted = _localize(formatted, grouping, monetary)\n    return formatted",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "_setlocale",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "_setlocale = setlocale\ndef _replace_encoding(code, encoding):\n    if '.' in code:\n        langname = code[:code.index('.')]\n    else:\n        langname = code\n    # Convert the encoding to a C lib compatible encoding string\n    norm_encoding = encodings.normalize_encoding(encoding)\n    #print('norm encoding: %r' % norm_encoding)\n    norm_encoding = encodings.aliases.aliases.get(norm_encoding.lower(),",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "locale_encoding_alias",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "locale_encoding_alias = {\n    # Mappings for non-standard encoding names used in locale names\n    '437':                          'C',\n    'c':                            'C',\n    'en':                           'ISO8859-1',\n    'jis':                          'JIS7',\n    'jis7':                         'JIS7',\n    'ajec':                         'eucJP',\n    'koi8c':                        'KOI8-C',\n    'microsoftcp1251':              'CP1251',",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "locale_alias",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "locale_alias = {\n    'a3':                                   'az_AZ.KOI8-C',\n    'a3_az':                                'az_AZ.KOI8-C',\n    'a3_az.koic':                           'az_AZ.KOI8-C',\n    'aa_dj':                                'aa_DJ.ISO8859-1',\n    'aa_er':                                'aa_ER.UTF-8',\n    'aa_et':                                'aa_ET.UTF-8',\n    'af':                                   'af_ZA.ISO8859-1',\n    'af_za':                                'af_ZA.ISO8859-1',\n    'agr_pe':                               'agr_PE.UTF-8',",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "windows_locale",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.locale",
        "description": "pycharm_venv.Lib.locale",
        "peekOfCode": "windows_locale = {\n    0x0436: \"af_ZA\", # Afrikaans\n    0x041c: \"sq_AL\", # Albanian\n    0x0484: \"gsw_FR\",# Alsatian - France\n    0x045e: \"am_ET\", # Amharic - Ethiopia\n    0x0401: \"ar_SA\", # Arabic - Saudi Arabia\n    0x0801: \"ar_IQ\", # Arabic - Iraq\n    0x0c01: \"ar_EG\", # Arabic - Egypt\n    0x1001: \"ar_LY\", # Arabic - Libya\n    0x1401: \"ar_DZ\", # Arabic - Algeria",
        "detail": "pycharm_venv.Lib.locale",
        "documentation": {}
    },
    {
        "label": "attrgetter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "class attrgetter:\n    \"\"\"\n    Return a callable object that fetches the given attribute(s) from its operand.\n    After f = attrgetter('name'), the call f(r) returns r.name.\n    After g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).\n    After h = attrgetter('name.first', 'name.last'), the call h(r) returns\n    (r.name.first, r.name.last).\n    \"\"\"\n    __slots__ = ('_attrs', '_call')\n    def __init__(self, attr, /, *attrs):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "itemgetter",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "class itemgetter:\n    \"\"\"\n    Return a callable object that fetches the given item(s) from its operand.\n    After f = itemgetter(2), the call f(r) returns r[2].\n    After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])\n    \"\"\"\n    __slots__ = ('_items', '_call')\n    def __init__(self, item, /, *items):\n        if not items:\n            self._items = (item,)",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "methodcaller",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "class methodcaller:\n    \"\"\"\n    Return a callable object that calls the given method on its operand.\n    After f = methodcaller('name'), the call f(r) returns r.name().\n    After g = methodcaller('name', 'date', foo=1), the call g(r) returns\n    r.name('date', foo=1).\n    \"\"\"\n    __slots__ = ('_name', '_args', '_kwargs')\n    def __init__(self, name, /, *args, **kwargs):\n        self._name = name",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "lt",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def lt(a, b):\n    \"Same as a < b.\"\n    return a < b\ndef le(a, b):\n    \"Same as a <= b.\"\n    return a <= b\ndef eq(a, b):\n    \"Same as a == b.\"\n    return a == b\ndef ne(a, b):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "le",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def le(a, b):\n    \"Same as a <= b.\"\n    return a <= b\ndef eq(a, b):\n    \"Same as a == b.\"\n    return a == b\ndef ne(a, b):\n    \"Same as a != b.\"\n    return a != b\ndef ge(a, b):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "eq",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def eq(a, b):\n    \"Same as a == b.\"\n    return a == b\ndef ne(a, b):\n    \"Same as a != b.\"\n    return a != b\ndef ge(a, b):\n    \"Same as a >= b.\"\n    return a >= b\ndef gt(a, b):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "ne",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def ne(a, b):\n    \"Same as a != b.\"\n    return a != b\ndef ge(a, b):\n    \"Same as a >= b.\"\n    return a >= b\ndef gt(a, b):\n    \"Same as a > b.\"\n    return a > b\n# Logical Operations **********************************************************#",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "ge",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def ge(a, b):\n    \"Same as a >= b.\"\n    return a >= b\ndef gt(a, b):\n    \"Same as a > b.\"\n    return a > b\n# Logical Operations **********************************************************#\ndef not_(a):\n    \"Same as not a.\"\n    return not a",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "gt",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def gt(a, b):\n    \"Same as a > b.\"\n    return a > b\n# Logical Operations **********************************************************#\ndef not_(a):\n    \"Same as not a.\"\n    return not a\ndef truth(a):\n    \"Return True if a is true, False otherwise.\"\n    return True if a else False",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "not_",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def not_(a):\n    \"Same as not a.\"\n    return not a\ndef truth(a):\n    \"Return True if a is true, False otherwise.\"\n    return True if a else False\ndef is_(a, b):\n    \"Same as a is b.\"\n    return a is b\ndef is_not(a, b):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "truth",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def truth(a):\n    \"Return True if a is true, False otherwise.\"\n    return True if a else False\ndef is_(a, b):\n    \"Same as a is b.\"\n    return a is b\ndef is_not(a, b):\n    \"Same as a is not b.\"\n    return a is not b\n# Mathematical/Bitwise Operations *********************************************#",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "is_",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def is_(a, b):\n    \"Same as a is b.\"\n    return a is b\ndef is_not(a, b):\n    \"Same as a is not b.\"\n    return a is not b\n# Mathematical/Bitwise Operations *********************************************#\ndef abs(a):\n    \"Same as abs(a).\"\n    return _abs(a)",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "is_not",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def is_not(a, b):\n    \"Same as a is not b.\"\n    return a is not b\n# Mathematical/Bitwise Operations *********************************************#\ndef abs(a):\n    \"Same as abs(a).\"\n    return _abs(a)\ndef add(a, b):\n    \"Same as a + b.\"\n    return a + b",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "abs",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def abs(a):\n    \"Same as abs(a).\"\n    return _abs(a)\ndef add(a, b):\n    \"Same as a + b.\"\n    return a + b\ndef and_(a, b):\n    \"Same as a & b.\"\n    return a & b\ndef floordiv(a, b):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "add",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def add(a, b):\n    \"Same as a + b.\"\n    return a + b\ndef and_(a, b):\n    \"Same as a & b.\"\n    return a & b\ndef floordiv(a, b):\n    \"Same as a // b.\"\n    return a // b\ndef index(a):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "and_",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def and_(a, b):\n    \"Same as a & b.\"\n    return a & b\ndef floordiv(a, b):\n    \"Same as a // b.\"\n    return a // b\ndef index(a):\n    \"Same as a.__index__().\"\n    return a.__index__()\ndef inv(a):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "floordiv",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def floordiv(a, b):\n    \"Same as a // b.\"\n    return a // b\ndef index(a):\n    \"Same as a.__index__().\"\n    return a.__index__()\ndef inv(a):\n    \"Same as ~a.\"\n    return ~a\ninvert = inv",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def index(a):\n    \"Same as a.__index__().\"\n    return a.__index__()\ndef inv(a):\n    \"Same as ~a.\"\n    return ~a\ninvert = inv\ndef lshift(a, b):\n    \"Same as a << b.\"\n    return a << b",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "inv",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def inv(a):\n    \"Same as ~a.\"\n    return ~a\ninvert = inv\ndef lshift(a, b):\n    \"Same as a << b.\"\n    return a << b\ndef mod(a, b):\n    \"Same as a % b.\"\n    return a % b",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "lshift",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def lshift(a, b):\n    \"Same as a << b.\"\n    return a << b\ndef mod(a, b):\n    \"Same as a % b.\"\n    return a % b\ndef mul(a, b):\n    \"Same as a * b.\"\n    return a * b\ndef matmul(a, b):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "mod",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def mod(a, b):\n    \"Same as a % b.\"\n    return a % b\ndef mul(a, b):\n    \"Same as a * b.\"\n    return a * b\ndef matmul(a, b):\n    \"Same as a @ b.\"\n    return a @ b\ndef neg(a):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "mul",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def mul(a, b):\n    \"Same as a * b.\"\n    return a * b\ndef matmul(a, b):\n    \"Same as a @ b.\"\n    return a @ b\ndef neg(a):\n    \"Same as -a.\"\n    return -a\ndef or_(a, b):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "matmul",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def matmul(a, b):\n    \"Same as a @ b.\"\n    return a @ b\ndef neg(a):\n    \"Same as -a.\"\n    return -a\ndef or_(a, b):\n    \"Same as a | b.\"\n    return a | b\ndef pos(a):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "neg",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def neg(a):\n    \"Same as -a.\"\n    return -a\ndef or_(a, b):\n    \"Same as a | b.\"\n    return a | b\ndef pos(a):\n    \"Same as +a.\"\n    return +a\ndef pow(a, b):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "or_",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def or_(a, b):\n    \"Same as a | b.\"\n    return a | b\ndef pos(a):\n    \"Same as +a.\"\n    return +a\ndef pow(a, b):\n    \"Same as a ** b.\"\n    return a ** b\ndef rshift(a, b):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "pos",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def pos(a):\n    \"Same as +a.\"\n    return +a\ndef pow(a, b):\n    \"Same as a ** b.\"\n    return a ** b\ndef rshift(a, b):\n    \"Same as a >> b.\"\n    return a >> b\ndef sub(a, b):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "pow",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def pow(a, b):\n    \"Same as a ** b.\"\n    return a ** b\ndef rshift(a, b):\n    \"Same as a >> b.\"\n    return a >> b\ndef sub(a, b):\n    \"Same as a - b.\"\n    return a - b\ndef truediv(a, b):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "rshift",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def rshift(a, b):\n    \"Same as a >> b.\"\n    return a >> b\ndef sub(a, b):\n    \"Same as a - b.\"\n    return a - b\ndef truediv(a, b):\n    \"Same as a / b.\"\n    return a / b\ndef xor(a, b):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "sub",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def sub(a, b):\n    \"Same as a - b.\"\n    return a - b\ndef truediv(a, b):\n    \"Same as a / b.\"\n    return a / b\ndef xor(a, b):\n    \"Same as a ^ b.\"\n    return a ^ b\n# Sequence Operations *********************************************************#",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "truediv",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def truediv(a, b):\n    \"Same as a / b.\"\n    return a / b\ndef xor(a, b):\n    \"Same as a ^ b.\"\n    return a ^ b\n# Sequence Operations *********************************************************#\ndef concat(a, b):\n    \"Same as a + b, for a and b sequences.\"\n    if not hasattr(a, '__getitem__'):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "xor",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def xor(a, b):\n    \"Same as a ^ b.\"\n    return a ^ b\n# Sequence Operations *********************************************************#\ndef concat(a, b):\n    \"Same as a + b, for a and b sequences.\"\n    if not hasattr(a, '__getitem__'):\n        msg = \"'%s' object can't be concatenated\" % type(a).__name__\n        raise TypeError(msg)\n    return a + b",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "concat",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def concat(a, b):\n    \"Same as a + b, for a and b sequences.\"\n    if not hasattr(a, '__getitem__'):\n        msg = \"'%s' object can't be concatenated\" % type(a).__name__\n        raise TypeError(msg)\n    return a + b\ndef contains(a, b):\n    \"Same as b in a (note reversed operands).\"\n    return b in a\ndef countOf(a, b):",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "contains",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def contains(a, b):\n    \"Same as b in a (note reversed operands).\"\n    return b in a\ndef countOf(a, b):\n    \"Return the number of items in a which are, or which equal, b.\"\n    count = 0\n    for i in a:\n        if i is b or i == b:\n            count += 1\n    return count",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "countOf",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def countOf(a, b):\n    \"Return the number of items in a which are, or which equal, b.\"\n    count = 0\n    for i in a:\n        if i is b or i == b:\n            count += 1\n    return count\ndef delitem(a, b):\n    \"Same as del a[b].\"\n    del a[b]",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "delitem",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def delitem(a, b):\n    \"Same as del a[b].\"\n    del a[b]\ndef getitem(a, b):\n    \"Same as a[b].\"\n    return a[b]\ndef indexOf(a, b):\n    \"Return the first index of b in a.\"\n    for i, j in enumerate(a):\n        if j is b or j == b:",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "getitem",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def getitem(a, b):\n    \"Same as a[b].\"\n    return a[b]\ndef indexOf(a, b):\n    \"Return the first index of b in a.\"\n    for i, j in enumerate(a):\n        if j is b or j == b:\n            return i\n    else:\n        raise ValueError('sequence.index(x): x not in sequence')",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "indexOf",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def indexOf(a, b):\n    \"Return the first index of b in a.\"\n    for i, j in enumerate(a):\n        if j is b or j == b:\n            return i\n    else:\n        raise ValueError('sequence.index(x): x not in sequence')\ndef setitem(a, b, c):\n    \"Same as a[b] = c.\"\n    a[b] = c",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "setitem",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def setitem(a, b, c):\n    \"Same as a[b] = c.\"\n    a[b] = c\ndef length_hint(obj, default=0):\n    \"\"\"\n    Return an estimate of the number of items in obj.\n    This is useful for presizing containers when building from an iterable.\n    If the object supports len(), the result will be exact. Otherwise, it may\n    over- or under-estimate by an arbitrary amount. The result will be an\n    integer >= 0.",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "length_hint",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def length_hint(obj, default=0):\n    \"\"\"\n    Return an estimate of the number of items in obj.\n    This is useful for presizing containers when building from an iterable.\n    If the object supports len(), the result will be exact. Otherwise, it may\n    over- or under-estimate by an arbitrary amount. The result will be an\n    integer >= 0.\n    \"\"\"\n    if not isinstance(default, int):\n        msg = (\"'%s' object cannot be interpreted as an integer\" %",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "call",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def call(obj, /, *args, **kwargs):\n    \"\"\"Same as obj(*args, **kwargs).\"\"\"\n    return obj(*args, **kwargs)\n# Generalized Lookup Objects **************************************************#\nclass attrgetter:\n    \"\"\"\n    Return a callable object that fetches the given attribute(s) from its operand.\n    After f = attrgetter('name'), the call f(r) returns r.name.\n    After g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).\n    After h = attrgetter('name.first', 'name.last'), the call h(r) returns",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "iadd",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def iadd(a, b):\n    \"Same as a += b.\"\n    a += b\n    return a\ndef iand(a, b):\n    \"Same as a &= b.\"\n    a &= b\n    return a\ndef iconcat(a, b):\n    \"Same as a += b, for a and b sequences.\"",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "iand",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def iand(a, b):\n    \"Same as a &= b.\"\n    a &= b\n    return a\ndef iconcat(a, b):\n    \"Same as a += b, for a and b sequences.\"\n    if not hasattr(a, '__getitem__'):\n        msg = \"'%s' object can't be concatenated\" % type(a).__name__\n        raise TypeError(msg)\n    a += b",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "iconcat",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def iconcat(a, b):\n    \"Same as a += b, for a and b sequences.\"\n    if not hasattr(a, '__getitem__'):\n        msg = \"'%s' object can't be concatenated\" % type(a).__name__\n        raise TypeError(msg)\n    a += b\n    return a\ndef ifloordiv(a, b):\n    \"Same as a //= b.\"\n    a //= b",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "ifloordiv",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def ifloordiv(a, b):\n    \"Same as a //= b.\"\n    a //= b\n    return a\ndef ilshift(a, b):\n    \"Same as a <<= b.\"\n    a <<= b\n    return a\ndef imod(a, b):\n    \"Same as a %= b.\"",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "ilshift",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def ilshift(a, b):\n    \"Same as a <<= b.\"\n    a <<= b\n    return a\ndef imod(a, b):\n    \"Same as a %= b.\"\n    a %= b\n    return a\ndef imul(a, b):\n    \"Same as a *= b.\"",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "imod",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def imod(a, b):\n    \"Same as a %= b.\"\n    a %= b\n    return a\ndef imul(a, b):\n    \"Same as a *= b.\"\n    a *= b\n    return a\ndef imatmul(a, b):\n    \"Same as a @= b.\"",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "imul",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def imul(a, b):\n    \"Same as a *= b.\"\n    a *= b\n    return a\ndef imatmul(a, b):\n    \"Same as a @= b.\"\n    a @= b\n    return a\ndef ior(a, b):\n    \"Same as a |= b.\"",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "imatmul",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def imatmul(a, b):\n    \"Same as a @= b.\"\n    a @= b\n    return a\ndef ior(a, b):\n    \"Same as a |= b.\"\n    a |= b\n    return a\ndef ipow(a, b):\n    \"Same as a **= b.\"",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "ior",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def ior(a, b):\n    \"Same as a |= b.\"\n    a |= b\n    return a\ndef ipow(a, b):\n    \"Same as a **= b.\"\n    a **=b\n    return a\ndef irshift(a, b):\n    \"Same as a >>= b.\"",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "ipow",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def ipow(a, b):\n    \"Same as a **= b.\"\n    a **=b\n    return a\ndef irshift(a, b):\n    \"Same as a >>= b.\"\n    a >>= b\n    return a\ndef isub(a, b):\n    \"Same as a -= b.\"",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "irshift",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def irshift(a, b):\n    \"Same as a >>= b.\"\n    a >>= b\n    return a\ndef isub(a, b):\n    \"Same as a -= b.\"\n    a -= b\n    return a\ndef itruediv(a, b):\n    \"Same as a /= b.\"",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "isub",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def isub(a, b):\n    \"Same as a -= b.\"\n    a -= b\n    return a\ndef itruediv(a, b):\n    \"Same as a /= b.\"\n    a /= b\n    return a\ndef ixor(a, b):\n    \"Same as a ^= b.\"",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "itruediv",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def itruediv(a, b):\n    \"Same as a /= b.\"\n    a /= b\n    return a\ndef ixor(a, b):\n    \"Same as a ^= b.\"\n    a ^= b\n    return a\ntry:\n    from _operator import *",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "ixor",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "def ixor(a, b):\n    \"Same as a ^= b.\"\n    a ^= b\n    return a\ntry:\n    from _operator import *\nexcept ImportError:\n    pass\nelse:\n    from _operator import __doc__",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__all__ = ['abs', 'add', 'and_', 'attrgetter', 'call', 'concat', 'contains', 'countOf',\n           'delitem', 'eq', 'floordiv', 'ge', 'getitem', 'gt', 'iadd', 'iand',\n           'iconcat', 'ifloordiv', 'ilshift', 'imatmul', 'imod', 'imul',\n           'index', 'indexOf', 'inv', 'invert', 'ior', 'ipow', 'irshift',\n           'is_', 'is_not', 'isub', 'itemgetter', 'itruediv', 'ixor', 'le',\n           'length_hint', 'lshift', 'lt', 'matmul', 'methodcaller', 'mod',\n           'mul', 'ne', 'neg', 'not_', 'or_', 'pos', 'pow', 'rshift',\n           'setitem', 'sub', 'truediv', 'truth', 'xor']\nfrom builtins import abs as _abs\n# Comparison Operations *******************************************************#",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "invert",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "invert = inv\ndef lshift(a, b):\n    \"Same as a << b.\"\n    return a << b\ndef mod(a, b):\n    \"Same as a % b.\"\n    return a % b\ndef mul(a, b):\n    \"Same as a * b.\"\n    return a * b",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__lt__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__lt__ = lt\n__le__ = le\n__eq__ = eq\n__ne__ = ne\n__ge__ = ge\n__gt__ = gt\n__not__ = not_\n__abs__ = abs\n__add__ = add\n__and__ = and_",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__le__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__le__ = le\n__eq__ = eq\n__ne__ = ne\n__ge__ = ge\n__gt__ = gt\n__not__ = not_\n__abs__ = abs\n__add__ = add\n__and__ = and_\n__call__ = call",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__eq__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__eq__ = eq\n__ne__ = ne\n__ge__ = ge\n__gt__ = gt\n__not__ = not_\n__abs__ = abs\n__add__ = add\n__and__ = and_\n__call__ = call\n__floordiv__ = floordiv",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__ne__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__ne__ = ne\n__ge__ = ge\n__gt__ = gt\n__not__ = not_\n__abs__ = abs\n__add__ = add\n__and__ = and_\n__call__ = call\n__floordiv__ = floordiv\n__index__ = index",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__ge__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__ge__ = ge\n__gt__ = gt\n__not__ = not_\n__abs__ = abs\n__add__ = add\n__and__ = and_\n__call__ = call\n__floordiv__ = floordiv\n__index__ = index\n__inv__ = inv",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__gt__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__gt__ = gt\n__not__ = not_\n__abs__ = abs\n__add__ = add\n__and__ = and_\n__call__ = call\n__floordiv__ = floordiv\n__index__ = index\n__inv__ = inv\n__invert__ = invert",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__not__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__not__ = not_\n__abs__ = abs\n__add__ = add\n__and__ = and_\n__call__ = call\n__floordiv__ = floordiv\n__index__ = index\n__inv__ = inv\n__invert__ = invert\n__lshift__ = lshift",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__abs__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__abs__ = abs\n__add__ = add\n__and__ = and_\n__call__ = call\n__floordiv__ = floordiv\n__index__ = index\n__inv__ = inv\n__invert__ = invert\n__lshift__ = lshift\n__mod__ = mod",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__add__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__add__ = add\n__and__ = and_\n__call__ = call\n__floordiv__ = floordiv\n__index__ = index\n__inv__ = inv\n__invert__ = invert\n__lshift__ = lshift\n__mod__ = mod\n__mul__ = mul",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__and__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__and__ = and_\n__call__ = call\n__floordiv__ = floordiv\n__index__ = index\n__inv__ = inv\n__invert__ = invert\n__lshift__ = lshift\n__mod__ = mod\n__mul__ = mul\n__matmul__ = matmul",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__call__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__call__ = call\n__floordiv__ = floordiv\n__index__ = index\n__inv__ = inv\n__invert__ = invert\n__lshift__ = lshift\n__mod__ = mod\n__mul__ = mul\n__matmul__ = matmul\n__neg__ = neg",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__floordiv__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__floordiv__ = floordiv\n__index__ = index\n__inv__ = inv\n__invert__ = invert\n__lshift__ = lshift\n__mod__ = mod\n__mul__ = mul\n__matmul__ = matmul\n__neg__ = neg\n__or__ = or_",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__index__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__index__ = index\n__inv__ = inv\n__invert__ = invert\n__lshift__ = lshift\n__mod__ = mod\n__mul__ = mul\n__matmul__ = matmul\n__neg__ = neg\n__or__ = or_\n__pos__ = pos",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__inv__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__inv__ = inv\n__invert__ = invert\n__lshift__ = lshift\n__mod__ = mod\n__mul__ = mul\n__matmul__ = matmul\n__neg__ = neg\n__or__ = or_\n__pos__ = pos\n__pow__ = pow",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__invert__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__invert__ = invert\n__lshift__ = lshift\n__mod__ = mod\n__mul__ = mul\n__matmul__ = matmul\n__neg__ = neg\n__or__ = or_\n__pos__ = pos\n__pow__ = pow\n__rshift__ = rshift",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__lshift__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__lshift__ = lshift\n__mod__ = mod\n__mul__ = mul\n__matmul__ = matmul\n__neg__ = neg\n__or__ = or_\n__pos__ = pos\n__pow__ = pow\n__rshift__ = rshift\n__sub__ = sub",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__mod__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__mod__ = mod\n__mul__ = mul\n__matmul__ = matmul\n__neg__ = neg\n__or__ = or_\n__pos__ = pos\n__pow__ = pow\n__rshift__ = rshift\n__sub__ = sub\n__truediv__ = truediv",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__mul__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__mul__ = mul\n__matmul__ = matmul\n__neg__ = neg\n__or__ = or_\n__pos__ = pos\n__pow__ = pow\n__rshift__ = rshift\n__sub__ = sub\n__truediv__ = truediv\n__xor__ = xor",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__matmul__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__matmul__ = matmul\n__neg__ = neg\n__or__ = or_\n__pos__ = pos\n__pow__ = pow\n__rshift__ = rshift\n__sub__ = sub\n__truediv__ = truediv\n__xor__ = xor\n__concat__ = concat",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__neg__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__neg__ = neg\n__or__ = or_\n__pos__ = pos\n__pow__ = pow\n__rshift__ = rshift\n__sub__ = sub\n__truediv__ = truediv\n__xor__ = xor\n__concat__ = concat\n__contains__ = contains",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__or__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__or__ = or_\n__pos__ = pos\n__pow__ = pow\n__rshift__ = rshift\n__sub__ = sub\n__truediv__ = truediv\n__xor__ = xor\n__concat__ = concat\n__contains__ = contains\n__delitem__ = delitem",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__pos__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__pos__ = pos\n__pow__ = pow\n__rshift__ = rshift\n__sub__ = sub\n__truediv__ = truediv\n__xor__ = xor\n__concat__ = concat\n__contains__ = contains\n__delitem__ = delitem\n__getitem__ = getitem",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__pow__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__pow__ = pow\n__rshift__ = rshift\n__sub__ = sub\n__truediv__ = truediv\n__xor__ = xor\n__concat__ = concat\n__contains__ = contains\n__delitem__ = delitem\n__getitem__ = getitem\n__setitem__ = setitem",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__rshift__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__rshift__ = rshift\n__sub__ = sub\n__truediv__ = truediv\n__xor__ = xor\n__concat__ = concat\n__contains__ = contains\n__delitem__ = delitem\n__getitem__ = getitem\n__setitem__ = setitem\n__iadd__ = iadd",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__sub__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__sub__ = sub\n__truediv__ = truediv\n__xor__ = xor\n__concat__ = concat\n__contains__ = contains\n__delitem__ = delitem\n__getitem__ = getitem\n__setitem__ = setitem\n__iadd__ = iadd\n__iand__ = iand",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__truediv__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__truediv__ = truediv\n__xor__ = xor\n__concat__ = concat\n__contains__ = contains\n__delitem__ = delitem\n__getitem__ = getitem\n__setitem__ = setitem\n__iadd__ = iadd\n__iand__ = iand\n__iconcat__ = iconcat",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__xor__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__xor__ = xor\n__concat__ = concat\n__contains__ = contains\n__delitem__ = delitem\n__getitem__ = getitem\n__setitem__ = setitem\n__iadd__ = iadd\n__iand__ = iand\n__iconcat__ = iconcat\n__ifloordiv__ = ifloordiv",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__concat__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__concat__ = concat\n__contains__ = contains\n__delitem__ = delitem\n__getitem__ = getitem\n__setitem__ = setitem\n__iadd__ = iadd\n__iand__ = iand\n__iconcat__ = iconcat\n__ifloordiv__ = ifloordiv\n__ilshift__ = ilshift",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__contains__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__contains__ = contains\n__delitem__ = delitem\n__getitem__ = getitem\n__setitem__ = setitem\n__iadd__ = iadd\n__iand__ = iand\n__iconcat__ = iconcat\n__ifloordiv__ = ifloordiv\n__ilshift__ = ilshift\n__imod__ = imod",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__delitem__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__delitem__ = delitem\n__getitem__ = getitem\n__setitem__ = setitem\n__iadd__ = iadd\n__iand__ = iand\n__iconcat__ = iconcat\n__ifloordiv__ = ifloordiv\n__ilshift__ = ilshift\n__imod__ = imod\n__imul__ = imul",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__getitem__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__getitem__ = getitem\n__setitem__ = setitem\n__iadd__ = iadd\n__iand__ = iand\n__iconcat__ = iconcat\n__ifloordiv__ = ifloordiv\n__ilshift__ = ilshift\n__imod__ = imod\n__imul__ = imul\n__imatmul__ = imatmul",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__setitem__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__setitem__ = setitem\n__iadd__ = iadd\n__iand__ = iand\n__iconcat__ = iconcat\n__ifloordiv__ = ifloordiv\n__ilshift__ = ilshift\n__imod__ = imod\n__imul__ = imul\n__imatmul__ = imatmul\n__ior__ = ior",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__iadd__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__iadd__ = iadd\n__iand__ = iand\n__iconcat__ = iconcat\n__ifloordiv__ = ifloordiv\n__ilshift__ = ilshift\n__imod__ = imod\n__imul__ = imul\n__imatmul__ = imatmul\n__ior__ = ior\n__ipow__ = ipow",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__iand__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__iand__ = iand\n__iconcat__ = iconcat\n__ifloordiv__ = ifloordiv\n__ilshift__ = ilshift\n__imod__ = imod\n__imul__ = imul\n__imatmul__ = imatmul\n__ior__ = ior\n__ipow__ = ipow\n__irshift__ = irshift",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__iconcat__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__iconcat__ = iconcat\n__ifloordiv__ = ifloordiv\n__ilshift__ = ilshift\n__imod__ = imod\n__imul__ = imul\n__imatmul__ = imatmul\n__ior__ = ior\n__ipow__ = ipow\n__irshift__ = irshift\n__isub__ = isub",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__ifloordiv__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__ifloordiv__ = ifloordiv\n__ilshift__ = ilshift\n__imod__ = imod\n__imul__ = imul\n__imatmul__ = imatmul\n__ior__ = ior\n__ipow__ = ipow\n__irshift__ = irshift\n__isub__ = isub\n__itruediv__ = itruediv",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__ilshift__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__ilshift__ = ilshift\n__imod__ = imod\n__imul__ = imul\n__imatmul__ = imatmul\n__ior__ = ior\n__ipow__ = ipow\n__irshift__ = irshift\n__isub__ = isub\n__itruediv__ = itruediv\n__ixor__ = ixor",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__imod__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__imod__ = imod\n__imul__ = imul\n__imatmul__ = imatmul\n__ior__ = ior\n__ipow__ = ipow\n__irshift__ = irshift\n__isub__ = isub\n__itruediv__ = itruediv\n__ixor__ = ixor",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__imul__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__imul__ = imul\n__imatmul__ = imatmul\n__ior__ = ior\n__ipow__ = ipow\n__irshift__ = irshift\n__isub__ = isub\n__itruediv__ = itruediv\n__ixor__ = ixor",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__imatmul__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__imatmul__ = imatmul\n__ior__ = ior\n__ipow__ = ipow\n__irshift__ = irshift\n__isub__ = isub\n__itruediv__ = itruediv\n__ixor__ = ixor",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__ior__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__ior__ = ior\n__ipow__ = ipow\n__irshift__ = irshift\n__isub__ = isub\n__itruediv__ = itruediv\n__ixor__ = ixor",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__ipow__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__ipow__ = ipow\n__irshift__ = irshift\n__isub__ = isub\n__itruediv__ = itruediv\n__ixor__ = ixor",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__irshift__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__irshift__ = irshift\n__isub__ = isub\n__itruediv__ = itruediv\n__ixor__ = ixor",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__isub__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__isub__ = isub\n__itruediv__ = itruediv\n__ixor__ = ixor",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__itruediv__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__itruediv__ = itruediv\n__ixor__ = ixor",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "__ixor__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.operator",
        "description": "pycharm_venv.Lib.operator",
        "peekOfCode": "__ixor__ = ixor",
        "detail": "pycharm_venv.Lib.operator",
        "documentation": {}
    },
    {
        "label": "Random",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "class Random(_random.Random):\n    \"\"\"Random number generator base class used by bound module functions.\n    Used to instantiate instances of Random to get generators that don't\n    share state.\n    Class Random can also be subclassed if you want to use a different basic\n    generator of your own devising: in that case, override the following\n    methods:  random(), seed(), getstate(), and setstate().\n    Optionally, implement a getrandbits() method so that randrange()\n    can cover arbitrarily large ranges.\n    \"\"\"",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "SystemRandom",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "class SystemRandom(Random):\n    \"\"\"Alternate random number generator using sources provided\n    by the operating system (such as /dev/urandom on Unix or\n    CryptGenRandom on Windows).\n     Not available on all systems (see os.urandom() for details).\n    \"\"\"\n    def random(self):\n        \"\"\"Get the next random number in the range 0.0 <= X < 1.0.\"\"\"\n        return (int.from_bytes(_urandom(7)) >> 3) * RECIP_BPF\n    def getrandbits(self, k):",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "def main(arg_list: list[str] | None = None) -> int | str:\n    args, help_text = _parse_args(arg_list)\n    # Explicit arguments\n    if args.choice:\n        return choice(args.choice)\n    if args.integer is not None:\n        return randint(1, args.integer)\n    if args.float is not None:\n        return uniform(0, args.float)\n    if args.test:",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "__all__ = [\n    \"Random\",\n    \"SystemRandom\",\n    \"betavariate\",\n    \"binomialvariate\",\n    \"choice\",\n    \"choices\",\n    \"expovariate\",\n    \"gammavariate\",\n    \"gauss\",",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "NV_MAGICCONST",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "NV_MAGICCONST = 4 * _exp(-0.5) / _sqrt(2.0)\nLOG4 = _log(4.0)\nSG_MAGICCONST = 1.0 + _log(4.5)\nBPF = 53        # Number of bits in a float\nRECIP_BPF = 2 ** -BPF\n_ONE = 1\n_sha512 = None\nclass Random(_random.Random):\n    \"\"\"Random number generator base class used by bound module functions.\n    Used to instantiate instances of Random to get generators that don't",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "LOG4",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "LOG4 = _log(4.0)\nSG_MAGICCONST = 1.0 + _log(4.5)\nBPF = 53        # Number of bits in a float\nRECIP_BPF = 2 ** -BPF\n_ONE = 1\n_sha512 = None\nclass Random(_random.Random):\n    \"\"\"Random number generator base class used by bound module functions.\n    Used to instantiate instances of Random to get generators that don't\n    share state.",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "SG_MAGICCONST",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "SG_MAGICCONST = 1.0 + _log(4.5)\nBPF = 53        # Number of bits in a float\nRECIP_BPF = 2 ** -BPF\n_ONE = 1\n_sha512 = None\nclass Random(_random.Random):\n    \"\"\"Random number generator base class used by bound module functions.\n    Used to instantiate instances of Random to get generators that don't\n    share state.\n    Class Random can also be subclassed if you want to use a different basic",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "BPF",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "BPF = 53        # Number of bits in a float\nRECIP_BPF = 2 ** -BPF\n_ONE = 1\n_sha512 = None\nclass Random(_random.Random):\n    \"\"\"Random number generator base class used by bound module functions.\n    Used to instantiate instances of Random to get generators that don't\n    share state.\n    Class Random can also be subclassed if you want to use a different basic\n    generator of your own devising: in that case, override the following",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "RECIP_BPF",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "RECIP_BPF = 2 ** -BPF\n_ONE = 1\n_sha512 = None\nclass Random(_random.Random):\n    \"\"\"Random number generator base class used by bound module functions.\n    Used to instantiate instances of Random to get generators that don't\n    share state.\n    Class Random can also be subclassed if you want to use a different basic\n    generator of your own devising: in that case, override the following\n    methods:  random(), seed(), getstate(), and setstate().",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "_ONE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "_ONE = 1\n_sha512 = None\nclass Random(_random.Random):\n    \"\"\"Random number generator base class used by bound module functions.\n    Used to instantiate instances of Random to get generators that don't\n    share state.\n    Class Random can also be subclassed if you want to use a different basic\n    generator of your own devising: in that case, override the following\n    methods:  random(), seed(), getstate(), and setstate().\n    Optionally, implement a getrandbits() method so that randrange()",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "_sha512",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "_sha512 = None\nclass Random(_random.Random):\n    \"\"\"Random number generator base class used by bound module functions.\n    Used to instantiate instances of Random to get generators that don't\n    share state.\n    Class Random can also be subclassed if you want to use a different basic\n    generator of your own devising: in that case, override the following\n    methods:  random(), seed(), getstate(), and setstate().\n    Optionally, implement a getrandbits() method so that randrange()\n    can cover arbitrarily large ranges.",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "_inst",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "_inst = Random()\nseed = _inst.seed\nrandom = _inst.random\nuniform = _inst.uniform\ntriangular = _inst.triangular\nrandint = _inst.randint\nchoice = _inst.choice\nrandrange = _inst.randrange\nsample = _inst.sample\nshuffle = _inst.shuffle",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "seed",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "seed = _inst.seed\nrandom = _inst.random\nuniform = _inst.uniform\ntriangular = _inst.triangular\nrandint = _inst.randint\nchoice = _inst.choice\nrandrange = _inst.randrange\nsample = _inst.sample\nshuffle = _inst.shuffle\nchoices = _inst.choices",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "random = _inst.random\nuniform = _inst.uniform\ntriangular = _inst.triangular\nrandint = _inst.randint\nchoice = _inst.choice\nrandrange = _inst.randrange\nsample = _inst.sample\nshuffle = _inst.shuffle\nchoices = _inst.choices\nnormalvariate = _inst.normalvariate",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "uniform",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "uniform = _inst.uniform\ntriangular = _inst.triangular\nrandint = _inst.randint\nchoice = _inst.choice\nrandrange = _inst.randrange\nsample = _inst.sample\nshuffle = _inst.shuffle\nchoices = _inst.choices\nnormalvariate = _inst.normalvariate\nlognormvariate = _inst.lognormvariate",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "triangular",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "triangular = _inst.triangular\nrandint = _inst.randint\nchoice = _inst.choice\nrandrange = _inst.randrange\nsample = _inst.sample\nshuffle = _inst.shuffle\nchoices = _inst.choices\nnormalvariate = _inst.normalvariate\nlognormvariate = _inst.lognormvariate\nexpovariate = _inst.expovariate",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "randint",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "randint = _inst.randint\nchoice = _inst.choice\nrandrange = _inst.randrange\nsample = _inst.sample\nshuffle = _inst.shuffle\nchoices = _inst.choices\nnormalvariate = _inst.normalvariate\nlognormvariate = _inst.lognormvariate\nexpovariate = _inst.expovariate\nvonmisesvariate = _inst.vonmisesvariate",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "choice",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "choice = _inst.choice\nrandrange = _inst.randrange\nsample = _inst.sample\nshuffle = _inst.shuffle\nchoices = _inst.choices\nnormalvariate = _inst.normalvariate\nlognormvariate = _inst.lognormvariate\nexpovariate = _inst.expovariate\nvonmisesvariate = _inst.vonmisesvariate\ngammavariate = _inst.gammavariate",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "randrange",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "randrange = _inst.randrange\nsample = _inst.sample\nshuffle = _inst.shuffle\nchoices = _inst.choices\nnormalvariate = _inst.normalvariate\nlognormvariate = _inst.lognormvariate\nexpovariate = _inst.expovariate\nvonmisesvariate = _inst.vonmisesvariate\ngammavariate = _inst.gammavariate\ngauss = _inst.gauss",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "sample",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "sample = _inst.sample\nshuffle = _inst.shuffle\nchoices = _inst.choices\nnormalvariate = _inst.normalvariate\nlognormvariate = _inst.lognormvariate\nexpovariate = _inst.expovariate\nvonmisesvariate = _inst.vonmisesvariate\ngammavariate = _inst.gammavariate\ngauss = _inst.gauss\nbetavariate = _inst.betavariate",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "shuffle",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "shuffle = _inst.shuffle\nchoices = _inst.choices\nnormalvariate = _inst.normalvariate\nlognormvariate = _inst.lognormvariate\nexpovariate = _inst.expovariate\nvonmisesvariate = _inst.vonmisesvariate\ngammavariate = _inst.gammavariate\ngauss = _inst.gauss\nbetavariate = _inst.betavariate\nbinomialvariate = _inst.binomialvariate",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "choices",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "choices = _inst.choices\nnormalvariate = _inst.normalvariate\nlognormvariate = _inst.lognormvariate\nexpovariate = _inst.expovariate\nvonmisesvariate = _inst.vonmisesvariate\ngammavariate = _inst.gammavariate\ngauss = _inst.gauss\nbetavariate = _inst.betavariate\nbinomialvariate = _inst.binomialvariate\nparetovariate = _inst.paretovariate",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "normalvariate",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "normalvariate = _inst.normalvariate\nlognormvariate = _inst.lognormvariate\nexpovariate = _inst.expovariate\nvonmisesvariate = _inst.vonmisesvariate\ngammavariate = _inst.gammavariate\ngauss = _inst.gauss\nbetavariate = _inst.betavariate\nbinomialvariate = _inst.binomialvariate\nparetovariate = _inst.paretovariate\nweibullvariate = _inst.weibullvariate",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "lognormvariate",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "lognormvariate = _inst.lognormvariate\nexpovariate = _inst.expovariate\nvonmisesvariate = _inst.vonmisesvariate\ngammavariate = _inst.gammavariate\ngauss = _inst.gauss\nbetavariate = _inst.betavariate\nbinomialvariate = _inst.binomialvariate\nparetovariate = _inst.paretovariate\nweibullvariate = _inst.weibullvariate\ngetstate = _inst.getstate",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "expovariate",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "expovariate = _inst.expovariate\nvonmisesvariate = _inst.vonmisesvariate\ngammavariate = _inst.gammavariate\ngauss = _inst.gauss\nbetavariate = _inst.betavariate\nbinomialvariate = _inst.binomialvariate\nparetovariate = _inst.paretovariate\nweibullvariate = _inst.weibullvariate\ngetstate = _inst.getstate\nsetstate = _inst.setstate",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "vonmisesvariate",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "vonmisesvariate = _inst.vonmisesvariate\ngammavariate = _inst.gammavariate\ngauss = _inst.gauss\nbetavariate = _inst.betavariate\nbinomialvariate = _inst.binomialvariate\nparetovariate = _inst.paretovariate\nweibullvariate = _inst.weibullvariate\ngetstate = _inst.getstate\nsetstate = _inst.setstate\ngetrandbits = _inst.getrandbits",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "gammavariate",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "gammavariate = _inst.gammavariate\ngauss = _inst.gauss\nbetavariate = _inst.betavariate\nbinomialvariate = _inst.binomialvariate\nparetovariate = _inst.paretovariate\nweibullvariate = _inst.weibullvariate\ngetstate = _inst.getstate\nsetstate = _inst.setstate\ngetrandbits = _inst.getrandbits\nrandbytes = _inst.randbytes",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "gauss",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "gauss = _inst.gauss\nbetavariate = _inst.betavariate\nbinomialvariate = _inst.binomialvariate\nparetovariate = _inst.paretovariate\nweibullvariate = _inst.weibullvariate\ngetstate = _inst.getstate\nsetstate = _inst.setstate\ngetrandbits = _inst.getrandbits\nrandbytes = _inst.randbytes\n## ------------------------------------------------------",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "betavariate",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "betavariate = _inst.betavariate\nbinomialvariate = _inst.binomialvariate\nparetovariate = _inst.paretovariate\nweibullvariate = _inst.weibullvariate\ngetstate = _inst.getstate\nsetstate = _inst.setstate\ngetrandbits = _inst.getrandbits\nrandbytes = _inst.randbytes\n## ------------------------------------------------------\n## ----------------- test program -----------------------",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "binomialvariate",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "binomialvariate = _inst.binomialvariate\nparetovariate = _inst.paretovariate\nweibullvariate = _inst.weibullvariate\ngetstate = _inst.getstate\nsetstate = _inst.setstate\ngetrandbits = _inst.getrandbits\nrandbytes = _inst.randbytes\n## ------------------------------------------------------\n## ----------------- test program -----------------------\ndef _test_generator(n, func, args):",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "paretovariate",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "paretovariate = _inst.paretovariate\nweibullvariate = _inst.weibullvariate\ngetstate = _inst.getstate\nsetstate = _inst.setstate\ngetrandbits = _inst.getrandbits\nrandbytes = _inst.randbytes\n## ------------------------------------------------------\n## ----------------- test program -----------------------\ndef _test_generator(n, func, args):\n    from statistics import stdev, fmean as mean",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "weibullvariate",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "weibullvariate = _inst.weibullvariate\ngetstate = _inst.getstate\nsetstate = _inst.setstate\ngetrandbits = _inst.getrandbits\nrandbytes = _inst.randbytes\n## ------------------------------------------------------\n## ----------------- test program -----------------------\ndef _test_generator(n, func, args):\n    from statistics import stdev, fmean as mean\n    from time import perf_counter",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "getstate",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "getstate = _inst.getstate\nsetstate = _inst.setstate\ngetrandbits = _inst.getrandbits\nrandbytes = _inst.randbytes\n## ------------------------------------------------------\n## ----------------- test program -----------------------\ndef _test_generator(n, func, args):\n    from statistics import stdev, fmean as mean\n    from time import perf_counter\n    t0 = perf_counter()",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "setstate",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "setstate = _inst.setstate\ngetrandbits = _inst.getrandbits\nrandbytes = _inst.randbytes\n## ------------------------------------------------------\n## ----------------- test program -----------------------\ndef _test_generator(n, func, args):\n    from statistics import stdev, fmean as mean\n    from time import perf_counter\n    t0 = perf_counter()\n    data = [func(*args) for i in _repeat(None, n)]",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "getrandbits",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "getrandbits = _inst.getrandbits\nrandbytes = _inst.randbytes\n## ------------------------------------------------------\n## ----------------- test program -----------------------\ndef _test_generator(n, func, args):\n    from statistics import stdev, fmean as mean\n    from time import perf_counter\n    t0 = perf_counter()\n    data = [func(*args) for i in _repeat(None, n)]\n    t1 = perf_counter()",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "randbytes",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.random",
        "description": "pycharm_venv.Lib.random",
        "peekOfCode": "randbytes = _inst.randbytes\n## ------------------------------------------------------\n## ----------------- test program -----------------------\ndef _test_generator(n, func, args):\n    from statistics import stdev, fmean as mean\n    from time import perf_counter\n    t0 = perf_counter()\n    data = [func(*args) for i in _repeat(None, n)]\n    t1 = perf_counter()\n    xbar = mean(data)",
        "detail": "pycharm_venv.Lib.random",
        "documentation": {}
    },
    {
        "label": "Repr",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.reprlib",
        "description": "pycharm_venv.Lib.reprlib",
        "peekOfCode": "class Repr:\n    def __init__(\n        self, *, maxlevel=6, maxtuple=6, maxlist=6, maxarray=5, maxdict=4,\n        maxset=6, maxfrozenset=6, maxdeque=6, maxstring=30, maxlong=40,\n        maxother=30, fillvalue='...', indent=None,\n    ):\n        self.maxlevel = maxlevel\n        self.maxtuple = maxtuple\n        self.maxlist = maxlist\n        self.maxarray = maxarray",
        "detail": "pycharm_venv.Lib.reprlib",
        "documentation": {}
    },
    {
        "label": "recursive_repr",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.reprlib",
        "description": "pycharm_venv.Lib.reprlib",
        "peekOfCode": "def recursive_repr(fillvalue='...'):\n    'Decorator to make a repr function return fillvalue for a recursive call'\n    def decorating_function(user_function):\n        repr_running = set()\n        def wrapper(self):\n            key = id(self), get_ident()\n            if key in repr_running:\n                return fillvalue\n            repr_running.add(key)\n            try:",
        "detail": "pycharm_venv.Lib.reprlib",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.reprlib",
        "description": "pycharm_venv.Lib.reprlib",
        "peekOfCode": "__all__ = [\"Repr\", \"repr\", \"recursive_repr\"]\nimport builtins\nfrom itertools import islice\nfrom _thread import get_ident\ndef recursive_repr(fillvalue='...'):\n    'Decorator to make a repr function return fillvalue for a recursive call'\n    def decorating_function(user_function):\n        repr_running = set()\n        def wrapper(self):\n            key = id(self), get_ident()",
        "detail": "pycharm_venv.Lib.reprlib",
        "documentation": {}
    },
    {
        "label": "aRepr",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.reprlib",
        "description": "pycharm_venv.Lib.reprlib",
        "peekOfCode": "aRepr = Repr()\nrepr = aRepr.repr",
        "detail": "pycharm_venv.Lib.reprlib",
        "documentation": {}
    },
    {
        "label": "repr",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.reprlib",
        "description": "pycharm_venv.Lib.reprlib",
        "peekOfCode": "repr = aRepr.repr",
        "detail": "pycharm_venv.Lib.reprlib",
        "documentation": {}
    },
    {
        "label": "Completer",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.rlcompleter",
        "description": "pycharm_venv.Lib.rlcompleter",
        "peekOfCode": "class Completer:\n    def __init__(self, namespace = None):\n        \"\"\"Create a new completer for the command line.\n        Completer([namespace]) -> completer instance.\n        If unspecified, the default namespace where completions are performed\n        is __main__ (technically, __main__.__dict__). Namespaces should be\n        given as dictionaries.\n        Completer instances should be used as the completion mechanism of\n        readline via the set_completer() call:\n        readline.set_completer(Completer(my_namespace).complete)",
        "detail": "pycharm_venv.Lib.rlcompleter",
        "documentation": {}
    },
    {
        "label": "get_class_members",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.rlcompleter",
        "description": "pycharm_venv.Lib.rlcompleter",
        "peekOfCode": "def get_class_members(klass):\n    ret = dir(klass)\n    if hasattr(klass,'__bases__'):\n        for base in klass.__bases__:\n            ret = ret + get_class_members(base)\n    return ret\ntry:\n    import readline\nexcept ImportError:\n    _readline_available = False",
        "detail": "pycharm_venv.Lib.rlcompleter",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.rlcompleter",
        "description": "pycharm_venv.Lib.rlcompleter",
        "peekOfCode": "__all__ = [\"Completer\"]\nclass Completer:\n    def __init__(self, namespace = None):\n        \"\"\"Create a new completer for the command line.\n        Completer([namespace]) -> completer instance.\n        If unspecified, the default namespace where completions are performed\n        is __main__ (technically, __main__.__dict__). Namespaces should be\n        given as dictionaries.\n        Completer instances should be used as the completion mechanism of\n        readline via the set_completer() call:",
        "detail": "pycharm_venv.Lib.rlcompleter",
        "documentation": {}
    },
    {
        "label": "Error",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "class Error(OSError):\n    pass\nclass SameFileError(Error):\n    \"\"\"Raised when source and destination are the same file.\"\"\"\nclass SpecialFileError(OSError):\n    \"\"\"Raised when trying to do a kind of operation (e.g. copying) which is\n    not supported on a special file (e.g. a named pipe)\"\"\"\nclass ExecError(OSError):\n    \"\"\"Raised when a command could not be executed\"\"\"\nclass ReadError(OSError):",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "SameFileError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "class SameFileError(Error):\n    \"\"\"Raised when source and destination are the same file.\"\"\"\nclass SpecialFileError(OSError):\n    \"\"\"Raised when trying to do a kind of operation (e.g. copying) which is\n    not supported on a special file (e.g. a named pipe)\"\"\"\nclass ExecError(OSError):\n    \"\"\"Raised when a command could not be executed\"\"\"\nclass ReadError(OSError):\n    \"\"\"Raised when an archive cannot be read\"\"\"\nclass RegistryError(Exception):",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "SpecialFileError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "class SpecialFileError(OSError):\n    \"\"\"Raised when trying to do a kind of operation (e.g. copying) which is\n    not supported on a special file (e.g. a named pipe)\"\"\"\nclass ExecError(OSError):\n    \"\"\"Raised when a command could not be executed\"\"\"\nclass ReadError(OSError):\n    \"\"\"Raised when an archive cannot be read\"\"\"\nclass RegistryError(Exception):\n    \"\"\"Raised when a registry operation with the archiving\n    and unpacking registries fails\"\"\"",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "ExecError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "class ExecError(OSError):\n    \"\"\"Raised when a command could not be executed\"\"\"\nclass ReadError(OSError):\n    \"\"\"Raised when an archive cannot be read\"\"\"\nclass RegistryError(Exception):\n    \"\"\"Raised when a registry operation with the archiving\n    and unpacking registries fails\"\"\"\nclass _GiveupOnFastCopy(Exception):\n    \"\"\"Raised as a signal to fallback on using raw read()/write()\n    file copy when fast-copy functions fail to do so.",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "ReadError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "class ReadError(OSError):\n    \"\"\"Raised when an archive cannot be read\"\"\"\nclass RegistryError(Exception):\n    \"\"\"Raised when a registry operation with the archiving\n    and unpacking registries fails\"\"\"\nclass _GiveupOnFastCopy(Exception):\n    \"\"\"Raised as a signal to fallback on using raw read()/write()\n    file copy when fast-copy functions fail to do so.\n    \"\"\"\ndef _fastcopy_fcopyfile(fsrc, fdst, flags):",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "RegistryError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "class RegistryError(Exception):\n    \"\"\"Raised when a registry operation with the archiving\n    and unpacking registries fails\"\"\"\nclass _GiveupOnFastCopy(Exception):\n    \"\"\"Raised as a signal to fallback on using raw read()/write()\n    file copy when fast-copy functions fail to do so.\n    \"\"\"\ndef _fastcopy_fcopyfile(fsrc, fdst, flags):\n    \"\"\"Copy a regular file content or metadata by using high-performance\n    fcopyfile(3) syscall (macOS).",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "_GiveupOnFastCopy",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "class _GiveupOnFastCopy(Exception):\n    \"\"\"Raised as a signal to fallback on using raw read()/write()\n    file copy when fast-copy functions fail to do so.\n    \"\"\"\ndef _fastcopy_fcopyfile(fsrc, fdst, flags):\n    \"\"\"Copy a regular file content or metadata by using high-performance\n    fcopyfile(3) syscall (macOS).\n    \"\"\"\n    try:\n        infd = fsrc.fileno()",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "copyfileobj",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def copyfileobj(fsrc, fdst, length=0):\n    \"\"\"copy data from file-like object fsrc to file-like object fdst\"\"\"\n    if not length:\n        length = COPY_BUFSIZE\n    # Localize variable access to minimize overhead.\n    fsrc_read = fsrc.read\n    fdst_write = fdst.write\n    while buf := fsrc_read(length):\n        fdst_write(buf)\ndef _samefile(src, dst):",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "copyfile",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def copyfile(src, dst, *, follow_symlinks=True):\n    \"\"\"Copy data from src to dst in the most efficient way possible.\n    If follow_symlinks is not set and src is a symbolic link, a new\n    symlink will be created instead of copying the file it points to.\n    \"\"\"\n    sys.audit(\"shutil.copyfile\", src, dst)\n    if _samefile(src, dst):\n        raise SameFileError(\"{!r} and {!r} are the same file\".format(src, dst))\n    file_size = 0\n    for i, fn in enumerate([src, dst]):",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "copymode",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def copymode(src, dst, *, follow_symlinks=True):\n    \"\"\"Copy mode bits from src to dst.\n    If follow_symlinks is not set, symlinks aren't followed if and only\n    if both `src` and `dst` are symlinks.  If `lchmod` isn't available\n    (e.g. Linux) this method does nothing.\n    \"\"\"\n    sys.audit(\"shutil.copymode\", src, dst)\n    if not follow_symlinks and _islink(src) and os.path.islink(dst):\n        if hasattr(os, 'lchmod'):\n            stat_func, chmod_func = os.lstat, os.lchmod",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "copystat",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def copystat(src, dst, *, follow_symlinks=True):\n    \"\"\"Copy file metadata\n    Copy the permission bits, last access time, last modification time, and\n    flags from `src` to `dst`. On Linux, copystat() also copies the \"extended\n    attributes\" where possible. The file contents, owner, and group are\n    unaffected. `src` and `dst` are path-like objects or path names given as\n    strings.\n    If the optional flag `follow_symlinks` is not set, symlinks aren't\n    followed if and only if both `src` and `dst` are symlinks.\n    \"\"\"",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def copy(src, dst, *, follow_symlinks=True):\n    \"\"\"Copy data and mode bits (\"cp src dst\"). Return the file's destination.\n    The destination may be a directory.\n    If follow_symlinks is false, symlinks won't be followed. This\n    resembles GNU's \"cp -P src dst\".\n    If source and destination are the same file, a SameFileError will be\n    raised.\n    \"\"\"\n    if os.path.isdir(dst):\n        dst = os.path.join(dst, os.path.basename(src))",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "copy2",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def copy2(src, dst, *, follow_symlinks=True):\n    \"\"\"Copy data and metadata. Return the file's destination.\n    Metadata is copied with copystat(). Please see the copystat function\n    for more information.\n    The destination may be a directory.\n    If follow_symlinks is false, symlinks won't be followed. This\n    resembles GNU's \"cp -P src dst\".\n    \"\"\"\n    if os.path.isdir(dst):\n        dst = os.path.join(dst, os.path.basename(src))",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "ignore_patterns",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def ignore_patterns(*patterns):\n    \"\"\"Function that can be used as copytree() ignore parameter.\n    Patterns is a sequence of glob-style patterns\n    that are used to exclude files\"\"\"\n    def _ignore_patterns(path, names):\n        ignored_names = []\n        for pattern in patterns:\n            ignored_names.extend(fnmatch.filter(names, pattern))\n        return set(ignored_names)\n    return _ignore_patterns",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "copytree",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n             ignore_dangling_symlinks=False, dirs_exist_ok=False):\n    \"\"\"Recursively copy a directory tree and return the destination directory.\n    If exception(s) occur, an Error is raised with a list of reasons.\n    If the optional symlinks flag is true, symbolic links in the\n    source tree result in symbolic links in the destination tree; if\n    it is false, the contents of the files pointed to by symbolic\n    links are copied. If the file pointed to by the symlink doesn't\n    exist, an exception will be added in the list of errors raised in\n    an Error exception at the end of the copy process.",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "rmtree",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def rmtree(path, ignore_errors=False, onerror=None, *, onexc=None, dir_fd=None):\n    \"\"\"Recursively delete a directory tree.\n    If dir_fd is not None, it should be a file descriptor open to a directory;\n    path will then be relative to that directory.\n    dir_fd may not be implemented on your platform.\n    If it is unavailable, using it will raise a NotImplementedError.\n    If ignore_errors is set, errors are ignored; otherwise, if onexc or\n    onerror is set, it is called to handle the error with arguments (func,\n    path, exc_info) where func is platform and implementation dependent;\n    path is the argument to that function that caused it to fail; and",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "move",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def move(src, dst, copy_function=copy2):\n    \"\"\"Recursively move a file or directory to another location. This is\n    similar to the Unix \"mv\" command. Return the file or directory's\n    destination.\n    If dst is an existing directory or a symlink to a directory, then src is\n    moved inside that directory. The destination path in that directory must\n    not already exist.\n    If dst already exists but is not a directory, it may be overwritten\n    depending on os.rename() semantics.\n    If the destination is on our current filesystem, then rename() is used.",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "get_archive_formats",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def get_archive_formats():\n    \"\"\"Returns a list of supported formats for archiving and unarchiving.\n    Each element of the returned sequence is a tuple (name, description)\n    \"\"\"\n    formats = [(name, registry[2]) for name, registry in\n               _ARCHIVE_FORMATS.items()]\n    formats.sort()\n    return formats\ndef register_archive_format(name, function, extra_args=None, description=''):\n    \"\"\"Registers an archive format.",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "register_archive_format",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def register_archive_format(name, function, extra_args=None, description=''):\n    \"\"\"Registers an archive format.\n    name is the name of the format. function is the callable that will be\n    used to create archives. If provided, extra_args is a sequence of\n    (name, value) tuples that will be passed as arguments to the callable.\n    description can be provided to describe the format, and will be returned\n    by the get_archive_formats() function.\n    \"\"\"\n    if extra_args is None:\n        extra_args = []",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "unregister_archive_format",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def unregister_archive_format(name):\n    del _ARCHIVE_FORMATS[name]\ndef make_archive(base_name, format, root_dir=None, base_dir=None, verbose=0,\n                 dry_run=0, owner=None, group=None, logger=None):\n    \"\"\"Create an archive file (eg. zip or tar).\n    'base_name' is the name of the file to create, minus any format-specific\n    extension; 'format' is the archive format: one of \"zip\", \"tar\", \"gztar\",\n    \"bztar\", or \"xztar\".  Or any other registered format.\n    'root_dir' is a directory that will be the root directory of the\n    archive; ie. we typically chdir into 'root_dir' before creating the",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "make_archive",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def make_archive(base_name, format, root_dir=None, base_dir=None, verbose=0,\n                 dry_run=0, owner=None, group=None, logger=None):\n    \"\"\"Create an archive file (eg. zip or tar).\n    'base_name' is the name of the file to create, minus any format-specific\n    extension; 'format' is the archive format: one of \"zip\", \"tar\", \"gztar\",\n    \"bztar\", or \"xztar\".  Or any other registered format.\n    'root_dir' is a directory that will be the root directory of the\n    archive; ie. we typically chdir into 'root_dir' before creating the\n    archive.  'base_dir' is the directory where we start archiving from;\n    ie. 'base_dir' will be the common prefix of all files and",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "get_unpack_formats",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def get_unpack_formats():\n    \"\"\"Returns a list of supported formats for unpacking.\n    Each element of the returned sequence is a tuple\n    (name, extensions, description)\n    \"\"\"\n    formats = [(name, info[0], info[3]) for name, info in\n               _UNPACK_FORMATS.items()]\n    formats.sort()\n    return formats\ndef _check_unpack_options(extensions, function, extra_args):",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "register_unpack_format",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def register_unpack_format(name, extensions, function, extra_args=None,\n                           description=''):\n    \"\"\"Registers an unpack format.\n    `name` is the name of the format. `extensions` is a list of extensions\n    corresponding to the format.\n    `function` is the callable that will be\n    used to unpack archives. The callable will receive archives to unpack.\n    If it's unable to handle an archive, it needs to raise a ReadError\n    exception.\n    If provided, `extra_args` is a sequence of",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "unregister_unpack_format",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def unregister_unpack_format(name):\n    \"\"\"Removes the pack format from the registry.\"\"\"\n    del _UNPACK_FORMATS[name]\ndef _ensure_directory(path):\n    \"\"\"Ensure that the parent directory of `path` exists\"\"\"\n    dirname = os.path.dirname(path)\n    if not os.path.isdir(dirname):\n        os.makedirs(dirname)\ndef _unpack_zipfile(filename, extract_dir):\n    \"\"\"Unpack zip `filename` to `extract_dir`",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "unpack_archive",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def unpack_archive(filename, extract_dir=None, format=None, *, filter=None):\n    \"\"\"Unpack an archive.\n    `filename` is the name of the archive.\n    `extract_dir` is the name of the target directory, where the archive\n    is unpacked. If not provided, the current working directory is used.\n    `format` is the archive format: one of \"zip\", \"tar\", \"gztar\", \"bztar\",\n    or \"xztar\".  Or any other registered format.  If not provided,\n    unpack_archive will use the filename extension and see if an unpacker\n    was registered for that extension.\n    In case none is found, a ValueError is raised.",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "chown",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def chown(path, user=None, group=None, *, dir_fd=None, follow_symlinks=True):\n    \"\"\"Change owner user and group of the given path.\n    user and group can be the uid/gid or the user/group names, and in that case,\n    they are converted to their respective uid/gid.\n    If dir_fd is set, it should be an open file descriptor to the directory to\n    be used as the root of *path* if it is relative.\n    If follow_symlinks is set to False and the last element of the path is a\n    symbolic link, chown will modify the link itself and not the file being\n    referenced by the link.\n    \"\"\"",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "get_terminal_size",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def get_terminal_size(fallback=(80, 24)):\n    \"\"\"Get the size of the terminal window.\n    For each of the two dimensions, the environment variable, COLUMNS\n    and LINES respectively, is checked. If the variable is defined and\n    the value is a positive integer, it is used.\n    When COLUMNS or LINES is not defined, which is the common case,\n    the terminal connected to sys.__stdout__ is queried\n    by invoking os.get_terminal_size.\n    If the terminal size cannot be successfully queried, either because\n    the system doesn't support querying, or because we are not",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "which",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "def which(cmd, mode=os.F_OK | os.X_OK, path=None):\n    \"\"\"Given a command, mode, and a PATH string, return the path which\n    conforms to the given mode on the PATH, or None if there is no such\n    file.\n    `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result\n    of os.environ.get(\"PATH\"), or can be overridden with a custom search\n    path.\n    \"\"\"\n    use_bytes = isinstance(cmd, bytes)\n    # If we're given a path with a directory part, look it up directly rather",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "_WINDOWS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "_WINDOWS = os.name == 'nt'\nposix = nt = None\nif os.name == 'posix':\n    import posix\nelif _WINDOWS:\n    import nt\nif sys.platform == 'win32':\n    import _winapi\nelse:\n    _winapi = None",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "posix",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "posix = nt = None\nif os.name == 'posix':\n    import posix\nelif _WINDOWS:\n    import nt\nif sys.platform == 'win32':\n    import _winapi\nelse:\n    _winapi = None\nCOPY_BUFSIZE = 1024 * 1024 if _WINDOWS else 64 * 1024",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "COPY_BUFSIZE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "COPY_BUFSIZE = 1024 * 1024 if _WINDOWS else 64 * 1024\n# This should never be removed, see rationale in:\n# https://bugs.python.org/issue43743#msg393429\n_USE_CP_SENDFILE = (hasattr(os, \"sendfile\")\n                    and sys.platform.startswith((\"linux\", \"android\")))\n_HAS_FCOPYFILE = posix and hasattr(posix, \"_fcopyfile\")  # macOS\n# CMD defaults in Windows 10\n_WIN_DEFAULT_PATHEXT = \".COM;.EXE;.BAT;.CMD;.VBS;.JS;.WS;.MSC\"\n__all__ = [\"copyfileobj\", \"copyfile\", \"copymode\", \"copystat\", \"copy\", \"copy2\",\n           \"copytree\", \"move\", \"rmtree\", \"Error\", \"SpecialFileError\",",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "_USE_CP_SENDFILE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "_USE_CP_SENDFILE = (hasattr(os, \"sendfile\")\n                    and sys.platform.startswith((\"linux\", \"android\")))\n_HAS_FCOPYFILE = posix and hasattr(posix, \"_fcopyfile\")  # macOS\n# CMD defaults in Windows 10\n_WIN_DEFAULT_PATHEXT = \".COM;.EXE;.BAT;.CMD;.VBS;.JS;.WS;.MSC\"\n__all__ = [\"copyfileobj\", \"copyfile\", \"copymode\", \"copystat\", \"copy\", \"copy2\",\n           \"copytree\", \"move\", \"rmtree\", \"Error\", \"SpecialFileError\",\n           \"ExecError\", \"make_archive\", \"get_archive_formats\",\n           \"register_archive_format\", \"unregister_archive_format\",\n           \"get_unpack_formats\", \"register_unpack_format\",",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "_HAS_FCOPYFILE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "_HAS_FCOPYFILE = posix and hasattr(posix, \"_fcopyfile\")  # macOS\n# CMD defaults in Windows 10\n_WIN_DEFAULT_PATHEXT = \".COM;.EXE;.BAT;.CMD;.VBS;.JS;.WS;.MSC\"\n__all__ = [\"copyfileobj\", \"copyfile\", \"copymode\", \"copystat\", \"copy\", \"copy2\",\n           \"copytree\", \"move\", \"rmtree\", \"Error\", \"SpecialFileError\",\n           \"ExecError\", \"make_archive\", \"get_archive_formats\",\n           \"register_archive_format\", \"unregister_archive_format\",\n           \"get_unpack_formats\", \"register_unpack_format\",\n           \"unregister_unpack_format\", \"unpack_archive\",\n           \"ignore_patterns\", \"chown\", \"which\", \"get_terminal_size\",",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "_WIN_DEFAULT_PATHEXT",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "_WIN_DEFAULT_PATHEXT = \".COM;.EXE;.BAT;.CMD;.VBS;.JS;.WS;.MSC\"\n__all__ = [\"copyfileobj\", \"copyfile\", \"copymode\", \"copystat\", \"copy\", \"copy2\",\n           \"copytree\", \"move\", \"rmtree\", \"Error\", \"SpecialFileError\",\n           \"ExecError\", \"make_archive\", \"get_archive_formats\",\n           \"register_archive_format\", \"unregister_archive_format\",\n           \"get_unpack_formats\", \"register_unpack_format\",\n           \"unregister_unpack_format\", \"unpack_archive\",\n           \"ignore_patterns\", \"chown\", \"which\", \"get_terminal_size\",\n           \"SameFileError\"]\n           # disk_usage is added later, if available on the platform",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "__all__ = [\"copyfileobj\", \"copyfile\", \"copymode\", \"copystat\", \"copy\", \"copy2\",\n           \"copytree\", \"move\", \"rmtree\", \"Error\", \"SpecialFileError\",\n           \"ExecError\", \"make_archive\", \"get_archive_formats\",\n           \"register_archive_format\", \"unregister_archive_format\",\n           \"get_unpack_formats\", \"register_unpack_format\",\n           \"unregister_unpack_format\", \"unpack_archive\",\n           \"ignore_patterns\", \"chown\", \"which\", \"get_terminal_size\",\n           \"SameFileError\"]\n           # disk_usage is added later, if available on the platform\nclass Error(OSError):",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "_use_fd_functions",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "_use_fd_functions = ({os.open, os.stat, os.unlink, os.rmdir} <=\n                     os.supports_dir_fd and\n                     os.scandir in os.supports_fd and\n                     os.stat in os.supports_follow_symlinks)\ndef rmtree(path, ignore_errors=False, onerror=None, *, onexc=None, dir_fd=None):\n    \"\"\"Recursively delete a directory tree.\n    If dir_fd is not None, it should be a file descriptor open to a directory;\n    path will then be relative to that directory.\n    dir_fd may not be implemented on your platform.\n    If it is unavailable, using it will raise a NotImplementedError.",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "rmtree.avoids_symlink_attacks",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "rmtree.avoids_symlink_attacks = _use_fd_functions\ndef _basename(path):\n    \"\"\"A basename() variant which first strips the trailing slash, if present.\n    Thus we always get the last component of the path, even for directories.\n    path: Union[PathLike, str]\n    e.g.\n    >>> os.path.basename('/bar/foo')\n    'foo'\n    >>> os.path.basename('/bar/foo/')\n    ''",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "_make_tarball.supports_root_dir",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "_make_tarball.supports_root_dir = True\n_make_zipfile.supports_root_dir = True\n# Maps the name of the archive format to a tuple containing:\n# * the archiving function\n# * extra keyword arguments\n# * description\n_ARCHIVE_FORMATS = {\n    'tar':   (_make_tarball, [('compress', None)],\n              \"uncompressed tar file\"),\n}",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "_make_zipfile.supports_root_dir",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "_make_zipfile.supports_root_dir = True\n# Maps the name of the archive format to a tuple containing:\n# * the archiving function\n# * extra keyword arguments\n# * description\n_ARCHIVE_FORMATS = {\n    'tar':   (_make_tarball, [('compress', None)],\n              \"uncompressed tar file\"),\n}\nif _ZLIB_SUPPORTED:",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "_ARCHIVE_FORMATS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "_ARCHIVE_FORMATS = {\n    'tar':   (_make_tarball, [('compress', None)],\n              \"uncompressed tar file\"),\n}\nif _ZLIB_SUPPORTED:\n    _ARCHIVE_FORMATS['gztar'] = (_make_tarball, [('compress', 'gzip')],\n                                \"gzip'ed tar-file\")\n    _ARCHIVE_FORMATS['zip'] = (_make_zipfile, [], \"ZIP file\")\nif _BZ2_SUPPORTED:\n    _ARCHIVE_FORMATS['bztar'] = (_make_tarball, [('compress', 'bzip2')],",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "_UNPACK_FORMATS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.shutil",
        "description": "pycharm_venv.Lib.shutil",
        "peekOfCode": "_UNPACK_FORMATS = {\n    'tar':   (['.tar'], _unpack_tarfile, [], \"uncompressed tar file\"),\n    'zip':   (['.zip'], _unpack_zipfile, [], \"ZIP file\"),\n}\nif _ZLIB_SUPPORTED:\n    _UNPACK_FORMATS['gztar'] = (['.tar.gz', '.tgz'], _unpack_tarfile, [],\n                                \"gzip'ed tar-file\")\nif _BZ2_SUPPORTED:\n    _UNPACK_FORMATS['bztar'] = (['.tar.bz2', '.tbz2'], _unpack_tarfile, [],\n                                \"bzip2'ed tar-file\")",
        "detail": "pycharm_venv.Lib.shutil",
        "documentation": {}
    },
    {
        "label": "_Printer",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "class _Printer(object):\n    \"\"\"interactive prompt objects for printing the license text, a list of\n    contributors and the copyright notice.\"\"\"\n    MAXLINES = 23\n    def __init__(self, name, data, files=(), dirs=()):\n        self.__name = name\n        self.__data = data\n        self.__files = files\n        self.__dirs = dirs\n        self.__lines = None",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "_Helper",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "class _Helper(object):\n    \"\"\"Define the built-in 'help'.\n    This is a wrapper around pydoc.help (with a twist).\n    \"\"\"\n    def __repr__(self):\n        return \"Type help() for interactive help, \" \"or help(object) for help about object.\"\n    def __call__(self, *args, **kwds):\n        import pydoc\n        return pydoc.help(*args, **kwds)\ndef sethelper():",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "makepath",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def makepath(*paths):\n    dir = os.path.join(*paths)\n    if _is_jython and (dir == \"__classpath__\" or dir.startswith(\"__pyclasspath__\")):\n        return dir, dir\n    dir = os.path.abspath(dir)\n    return dir, os.path.normcase(dir)\ndef abs__file__():\n    \"\"\"Set all module' __file__ attribute to an absolute path\"\"\"\n    for m in sys.modules.values():\n        if (_is_jython and not isinstance(m, ModuleType)) or hasattr(m, \"__loader__\"):",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "abs__file__",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def abs__file__():\n    \"\"\"Set all module' __file__ attribute to an absolute path\"\"\"\n    for m in sys.modules.values():\n        if (_is_jython and not isinstance(m, ModuleType)) or hasattr(m, \"__loader__\"):\n            # only modules need the abspath in Jython. and don't mess\n            # with a PEP 302-supplied __file__\n            continue\n        f = getattr(m, \"__file__\", None)\n        if f is None:\n            continue",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "removeduppaths",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def removeduppaths():\n    \"\"\" Remove duplicate entries from sys.path along with making them\n    absolute\"\"\"\n    # This ensures that the initial path provided by the interpreter contains\n    # only absolute pathnames, even if we're running from the build directory.\n    L = []\n    known_paths = set()\n    for dir in sys.path:\n        # Filter out duplicate paths (on case-insensitive file systems also\n        # if they only differ in case); turn relative paths into absolute",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "addbuilddir",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def addbuilddir():\n    \"\"\"Append ./build/lib.<platform> in case we're running in the build dir\n    (especially for Guido :-)\"\"\"\n    from distutils.util import get_platform\n    s = \"build/lib.{}-{:.3}\".format(get_platform(), sys.version)\n    if hasattr(sys, \"gettotalrefcount\"):\n        s += \"-pydebug\"\n    s = os.path.join(os.path.dirname(sys.path[-1]), s)\n    sys.path.append(s)\ndef _init_pathinfo():",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "addpackage",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def addpackage(sitedir, name, known_paths):\n    \"\"\"Add a new path to known_paths by combining sitedir and 'name' or execute\n    sitedir if it starts with 'import'\"\"\"\n    if known_paths is None:\n        _init_pathinfo()\n        reset = 1\n    else:\n        reset = 0\n    fullname = os.path.join(sitedir, name)\n    try:",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "addsitedir",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def addsitedir(sitedir, known_paths=None):\n    \"\"\"Add 'sitedir' argument to sys.path if missing and handle .pth files in\n    'sitedir'\"\"\"\n    if known_paths is None:\n        known_paths = _init_pathinfo()\n        reset = 1\n    else:\n        reset = 0\n    sitedir, sitedircase = makepath(sitedir)\n    if not sitedircase in known_paths:",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "addsitepackages",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def addsitepackages(known_paths, sys_prefix=sys.prefix, exec_prefix=sys.exec_prefix):\n    \"\"\"Add site-packages (and possibly site-python) to sys.path\"\"\"\n    prefixes = [os.path.join(sys_prefix, \"local\"), sys_prefix]\n    if exec_prefix != sys_prefix:\n        prefixes.append(os.path.join(exec_prefix, \"local\"))\n    for prefix in prefixes:\n        if prefix:\n            if sys.platform in (\"os2emx\", \"riscos\") or _is_jython:\n                sitedirs = [os.path.join(prefix, \"Lib\", \"site-packages\")]\n            elif _is_pypy:",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "check_enableusersite",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def check_enableusersite():\n    \"\"\"Check if user site directory is safe for inclusion\n    The function tests for the command line flag (including environment var),\n    process uid/gid equal to effective uid/gid.\n    None: Disabled for security reasons\n    False: Disabled by user (command line option)\n    True: Safe and enabled\n    \"\"\"\n    if hasattr(sys, \"flags\") and getattr(sys.flags, \"no_user_site\", False):\n        return False",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "addusersitepackages",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def addusersitepackages(known_paths):\n    \"\"\"Add a per user site-package to sys.path\n    Each user has its own python directory with site-packages in the\n    home directory.\n    USER_BASE is the root directory for all Python versions\n    USER_SITE is the user specific site-packages directory\n    USER_SITE/.. can be used for data.\n    \"\"\"\n    global USER_BASE, USER_SITE, ENABLE_USER_SITE\n    env_base = os.environ.get(\"PYTHONUSERBASE\", None)",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "setBEGINLIBPATH",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def setBEGINLIBPATH():\n    \"\"\"The OS/2 EMX port has optional extension modules that do double duty\n    as DLLs (and must use the .DLL file extension) for other extensions.\n    The library search path needs to be amended so these will be found\n    during module import.  Use BEGINLIBPATH so that these are at the start\n    of the library search path.\n    \"\"\"\n    dllpath = os.path.join(sys.prefix, \"Lib\", \"lib-dynload\")\n    libpath = os.environ[\"BEGINLIBPATH\"].split(\";\")\n    if libpath[-1]:",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "setquit",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def setquit():\n    \"\"\"Define new built-ins 'quit' and 'exit'.\n    These are simply strings that display a hint on how to exit.\n    \"\"\"\n    if os.sep == \":\":\n        eof = \"Cmd-Q\"\n    elif os.sep == \"\\\\\":\n        eof = \"Ctrl-Z plus Return\"\n    else:\n        eof = \"Ctrl-D (i.e. EOF)\"",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "setcopyright",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def setcopyright():\n    \"\"\"Set 'copyright' and 'credits' in __builtin__\"\"\"\n    builtins.copyright = _Printer(\"copyright\", sys.copyright)\n    if _is_jython:\n        builtins.credits = _Printer(\"credits\", \"Jython is maintained by the Jython developers (www.jython.org).\")\n    elif _is_pypy:\n        builtins.credits = _Printer(\"credits\", \"PyPy is maintained by the PyPy developers: http://pypy.org/\")\n    else:\n        builtins.credits = _Printer(\n            \"credits\",",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "sethelper",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def sethelper():\n    builtins.help = _Helper()\ndef aliasmbcs():\n    \"\"\"On Windows, some default encodings are not provided by Python,\n    while they are always available as \"mbcs\" in each locale. Make\n    them usable by aliasing to \"mbcs\" in such a case.\"\"\"\n    if sys.platform == \"win32\":\n        import locale, codecs\n        enc = locale.getdefaultlocale()[1]\n        if enc.startswith(\"cp\"):  # \"cp***\" ?",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "aliasmbcs",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def aliasmbcs():\n    \"\"\"On Windows, some default encodings are not provided by Python,\n    while they are always available as \"mbcs\" in each locale. Make\n    them usable by aliasing to \"mbcs\" in such a case.\"\"\"\n    if sys.platform == \"win32\":\n        import locale, codecs\n        enc = locale.getdefaultlocale()[1]\n        if enc.startswith(\"cp\"):  # \"cp***\" ?\n            try:\n                codecs.lookup(enc)",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "setencoding",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def setencoding():\n    \"\"\"Set the string encoding used by the Unicode implementation.  The\n    default is 'ascii', but if you're willing to experiment, you can\n    change this.\"\"\"\n    encoding = \"ascii\"  # Default value set by _PyUnicode_Init()\n    if 0:\n        # Enable to support locale aware default string encodings.\n        import locale\n        loc = locale.getdefaultlocale()\n        if loc[1]:",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "execsitecustomize",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def execsitecustomize():\n    \"\"\"Run custom site specific code, if available.\"\"\"\n    try:\n        import sitecustomize\n    except ImportError:\n        pass\ndef virtual_install_main_packages():\n    f = open(os.path.join(os.path.dirname(__file__), \"orig-prefix.txt\"))\n    sys.real_prefix = f.read().strip()\n    f.close()",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "virtual_install_main_packages",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def virtual_install_main_packages():\n    f = open(os.path.join(os.path.dirname(__file__), \"orig-prefix.txt\"))\n    sys.real_prefix = f.read().strip()\n    f.close()\n    pos = 2\n    hardcoded_relative_dirs = []\n    if sys.path[0] == \"\":\n        pos += 1\n    if _is_jython:\n        paths = [os.path.join(sys.real_prefix, \"Lib\")]",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "force_global_eggs_after_local_site_packages",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def force_global_eggs_after_local_site_packages():\n    \"\"\"\n    Force easy_installed eggs in the global environment to get placed\n    in sys.path after all packages inside the virtualenv.  This\n    maintains the \"least surprise\" result that packages in the\n    virtualenv always mask global packages, never the other way\n    around.\n    \"\"\"\n    egginsert = getattr(sys, \"__egginsert\", 0)\n    for i, path in enumerate(sys.path):",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "virtual_addsitepackages",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def virtual_addsitepackages(known_paths):\n    force_global_eggs_after_local_site_packages()\n    return addsitepackages(known_paths, sys_prefix=sys.real_prefix)\ndef fixclasspath():\n    \"\"\"Adjust the special classpath sys.path entries for Jython. These\n    entries should follow the base virtualenv lib directories.\n    \"\"\"\n    paths = []\n    classpaths = []\n    for path in sys.path:",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "fixclasspath",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def fixclasspath():\n    \"\"\"Adjust the special classpath sys.path entries for Jython. These\n    entries should follow the base virtualenv lib directories.\n    \"\"\"\n    paths = []\n    classpaths = []\n    for path in sys.path:\n        if path == \"__classpath__\" or path.startswith(\"__pyclasspath__\"):\n            classpaths.append(path)\n        else:",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "execusercustomize",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def execusercustomize():\n    \"\"\"Run custom user specific code, if available.\"\"\"\n    try:\n        import usercustomize\n    except ImportError:\n        pass\ndef enablerlcompleter():\n    \"\"\"Enable default readline configuration on interactive prompts, by\n    registering a sys.__interactivehook__.\n    If the readline module can be imported, the hook will set the Tab key",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "enablerlcompleter",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def enablerlcompleter():\n    \"\"\"Enable default readline configuration on interactive prompts, by\n    registering a sys.__interactivehook__.\n    If the readline module can be imported, the hook will set the Tab key\n    as completion key and register ~/.python_history as history file.\n    This can be overridden in the sitecustomize or usercustomize module,\n    or in a PYTHONSTARTUP file.\n    \"\"\"\n    def register_readline():\n        import atexit",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "def main():\n    global ENABLE_USER_SITE\n    virtual_install_main_packages()\n    if _is_pypy:\n        import_builtin_stuff()\n    abs__file__()\n    paths_in_sys = removeduppaths()\n    if os.name == \"posix\" and sys.path and os.path.basename(sys.path[-1]) == \"Modules\":\n        addbuilddir()\n    if _is_jython:",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "PREFIXES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "PREFIXES = [sys.prefix, sys.exec_prefix]\n# Enable per user site-packages directory\n# set it to False to disable the feature or True to force the feature\nENABLE_USER_SITE = None\n# for distutils.commands.install\nUSER_SITE = None\nUSER_BASE = None\n_is_64bit = (getattr(sys, \"maxsize\", None) or getattr(sys, \"maxint\")) > 2 ** 32\n_is_pypy = hasattr(sys, \"pypy_version_info\")\n_is_jython = sys.platform[:4] == \"java\"",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "ENABLE_USER_SITE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "ENABLE_USER_SITE = None\n# for distutils.commands.install\nUSER_SITE = None\nUSER_BASE = None\n_is_64bit = (getattr(sys, \"maxsize\", None) or getattr(sys, \"maxint\")) > 2 ** 32\n_is_pypy = hasattr(sys, \"pypy_version_info\")\n_is_jython = sys.platform[:4] == \"java\"\nif _is_jython:\n    ModuleType = type(os)\ndef makepath(*paths):",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "USER_SITE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "USER_SITE = None\nUSER_BASE = None\n_is_64bit = (getattr(sys, \"maxsize\", None) or getattr(sys, \"maxint\")) > 2 ** 32\n_is_pypy = hasattr(sys, \"pypy_version_info\")\n_is_jython = sys.platform[:4] == \"java\"\nif _is_jython:\n    ModuleType = type(os)\ndef makepath(*paths):\n    dir = os.path.join(*paths)\n    if _is_jython and (dir == \"__classpath__\" or dir.startswith(\"__pyclasspath__\")):",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "USER_BASE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "USER_BASE = None\n_is_64bit = (getattr(sys, \"maxsize\", None) or getattr(sys, \"maxint\")) > 2 ** 32\n_is_pypy = hasattr(sys, \"pypy_version_info\")\n_is_jython = sys.platform[:4] == \"java\"\nif _is_jython:\n    ModuleType = type(os)\ndef makepath(*paths):\n    dir = os.path.join(*paths)\n    if _is_jython and (dir == \"__classpath__\" or dir.startswith(\"__pyclasspath__\")):\n        return dir, dir",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "_is_64bit",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "_is_64bit = (getattr(sys, \"maxsize\", None) or getattr(sys, \"maxint\")) > 2 ** 32\n_is_pypy = hasattr(sys, \"pypy_version_info\")\n_is_jython = sys.platform[:4] == \"java\"\nif _is_jython:\n    ModuleType = type(os)\ndef makepath(*paths):\n    dir = os.path.join(*paths)\n    if _is_jython and (dir == \"__classpath__\" or dir.startswith(\"__pyclasspath__\")):\n        return dir, dir\n    dir = os.path.abspath(dir)",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "_is_pypy",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "_is_pypy = hasattr(sys, \"pypy_version_info\")\n_is_jython = sys.platform[:4] == \"java\"\nif _is_jython:\n    ModuleType = type(os)\ndef makepath(*paths):\n    dir = os.path.join(*paths)\n    if _is_jython and (dir == \"__classpath__\" or dir.startswith(\"__pyclasspath__\")):\n        return dir, dir\n    dir = os.path.abspath(dir)\n    return dir, os.path.normcase(dir)",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "_is_jython",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.site",
        "description": "pycharm_venv.Lib.site",
        "peekOfCode": "_is_jython = sys.platform[:4] == \"java\"\nif _is_jython:\n    ModuleType = type(os)\ndef makepath(*paths):\n    dir = os.path.join(*paths)\n    if _is_jython and (dir == \"__classpath__\" or dir.startswith(\"__pyclasspath__\")):\n        return dir, dir\n    dir = os.path.abspath(dir)\n    return dir, os.path.normcase(dir)\ndef abs__file__():",
        "detail": "pycharm_venv.Lib.site",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.struct",
        "description": "pycharm_venv.Lib.struct",
        "peekOfCode": "__all__ = [\n    # Functions\n    'calcsize', 'pack', 'pack_into', 'unpack', 'unpack_from',\n    'iter_unpack',\n    # Classes\n    'Struct',\n    # Exceptions\n    'error'\n    ]\nfrom _struct import *",
        "detail": "pycharm_venv.Lib.struct",
        "documentation": {}
    },
    {
        "label": "TarError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class TarError(Exception):\n    \"\"\"Base exception.\"\"\"\n    pass\nclass ExtractError(TarError):\n    \"\"\"General exception for extract errors.\"\"\"\n    pass\nclass ReadError(TarError):\n    \"\"\"Exception for unreadable tar archives.\"\"\"\n    pass\nclass CompressionError(TarError):",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "ExtractError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class ExtractError(TarError):\n    \"\"\"General exception for extract errors.\"\"\"\n    pass\nclass ReadError(TarError):\n    \"\"\"Exception for unreadable tar archives.\"\"\"\n    pass\nclass CompressionError(TarError):\n    \"\"\"Exception for unavailable compression methods.\"\"\"\n    pass\nclass StreamError(TarError):",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "ReadError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class ReadError(TarError):\n    \"\"\"Exception for unreadable tar archives.\"\"\"\n    pass\nclass CompressionError(TarError):\n    \"\"\"Exception for unavailable compression methods.\"\"\"\n    pass\nclass StreamError(TarError):\n    \"\"\"Exception for unsupported operations on stream-like TarFiles.\"\"\"\n    pass\nclass HeaderError(TarError):",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "CompressionError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class CompressionError(TarError):\n    \"\"\"Exception for unavailable compression methods.\"\"\"\n    pass\nclass StreamError(TarError):\n    \"\"\"Exception for unsupported operations on stream-like TarFiles.\"\"\"\n    pass\nclass HeaderError(TarError):\n    \"\"\"Base exception for header errors.\"\"\"\n    pass\nclass EmptyHeaderError(HeaderError):",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "StreamError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class StreamError(TarError):\n    \"\"\"Exception for unsupported operations on stream-like TarFiles.\"\"\"\n    pass\nclass HeaderError(TarError):\n    \"\"\"Base exception for header errors.\"\"\"\n    pass\nclass EmptyHeaderError(HeaderError):\n    \"\"\"Exception for empty headers.\"\"\"\n    pass\nclass TruncatedHeaderError(HeaderError):",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "HeaderError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class HeaderError(TarError):\n    \"\"\"Base exception for header errors.\"\"\"\n    pass\nclass EmptyHeaderError(HeaderError):\n    \"\"\"Exception for empty headers.\"\"\"\n    pass\nclass TruncatedHeaderError(HeaderError):\n    \"\"\"Exception for truncated headers.\"\"\"\n    pass\nclass EOFHeaderError(HeaderError):",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "EmptyHeaderError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class EmptyHeaderError(HeaderError):\n    \"\"\"Exception for empty headers.\"\"\"\n    pass\nclass TruncatedHeaderError(HeaderError):\n    \"\"\"Exception for truncated headers.\"\"\"\n    pass\nclass EOFHeaderError(HeaderError):\n    \"\"\"Exception for end of file headers.\"\"\"\n    pass\nclass InvalidHeaderError(HeaderError):",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "TruncatedHeaderError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class TruncatedHeaderError(HeaderError):\n    \"\"\"Exception for truncated headers.\"\"\"\n    pass\nclass EOFHeaderError(HeaderError):\n    \"\"\"Exception for end of file headers.\"\"\"\n    pass\nclass InvalidHeaderError(HeaderError):\n    \"\"\"Exception for invalid headers.\"\"\"\n    pass\nclass SubsequentHeaderError(HeaderError):",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "EOFHeaderError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class EOFHeaderError(HeaderError):\n    \"\"\"Exception for end of file headers.\"\"\"\n    pass\nclass InvalidHeaderError(HeaderError):\n    \"\"\"Exception for invalid headers.\"\"\"\n    pass\nclass SubsequentHeaderError(HeaderError):\n    \"\"\"Exception for missing and invalid extended headers.\"\"\"\n    pass\n#---------------------------",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "InvalidHeaderError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class InvalidHeaderError(HeaderError):\n    \"\"\"Exception for invalid headers.\"\"\"\n    pass\nclass SubsequentHeaderError(HeaderError):\n    \"\"\"Exception for missing and invalid extended headers.\"\"\"\n    pass\n#---------------------------\n# internal stream interface\n#---------------------------\nclass _LowLevelFile:",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "SubsequentHeaderError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class SubsequentHeaderError(HeaderError):\n    \"\"\"Exception for missing and invalid extended headers.\"\"\"\n    pass\n#---------------------------\n# internal stream interface\n#---------------------------\nclass _LowLevelFile:\n    \"\"\"Low-level file object. Supports reading and writing.\n       It is used instead of a regular file object for streaming\n       access.",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "_LowLevelFile",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class _LowLevelFile:\n    \"\"\"Low-level file object. Supports reading and writing.\n       It is used instead of a regular file object for streaming\n       access.\n    \"\"\"\n    def __init__(self, name, mode):\n        mode = {\n            \"r\": os.O_RDONLY,\n            \"w\": os.O_WRONLY | os.O_CREAT | os.O_TRUNC,\n        }[mode]",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "_Stream",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class _Stream:\n    \"\"\"Class that serves as an adapter between TarFile and\n       a stream-like object.  The stream-like object only\n       needs to have a read() or write() method that works with bytes,\n       and the method is accessed blockwise.\n       Use of gzip or bzip2 compression is possible.\n       A stream-like object could be for example: sys.stdin.buffer,\n       sys.stdout.buffer, a socket, a tape device etc.\n       _Stream is intended to be used only internally.\n    \"\"\"",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "_StreamProxy",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class _StreamProxy(object):\n    \"\"\"Small proxy class that enables transparent compression\n       detection for the Stream interface (mode 'r|*').\n    \"\"\"\n    def __init__(self, fileobj):\n        self.fileobj = fileobj\n        self.buf = self.fileobj.read(BLOCKSIZE)\n    def read(self, size):\n        self.read = self.fileobj.read\n        return self.buf",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "_FileInFile",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class _FileInFile(object):\n    \"\"\"A thin wrapper around an existing file object that\n       provides a part of its data as an individual file\n       object.\n    \"\"\"\n    def __init__(self, fileobj, offset, size, name, blockinfo=None):\n        self.fileobj = fileobj\n        self.offset = offset\n        self.size = size\n        self.position = 0",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "ExFileObject",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class ExFileObject(io.BufferedReader):\n    def __init__(self, tarfile, tarinfo):\n        fileobj = _FileInFile(tarfile.fileobj, tarinfo.offset_data,\n                tarinfo.size, tarinfo.name, tarinfo.sparse)\n        super().__init__(fileobj)\n#class ExFileObject\n#-----------------------------\n# extraction filters (PEP 706)\n#-----------------------------\nclass FilterError(TarError):",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "FilterError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class FilterError(TarError):\n    pass\nclass AbsolutePathError(FilterError):\n    def __init__(self, tarinfo):\n        self.tarinfo = tarinfo\n        super().__init__(f'member {tarinfo.name!r} has an absolute path')\nclass OutsideDestinationError(FilterError):\n    def __init__(self, tarinfo, path):\n        self.tarinfo = tarinfo\n        self._path = path",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "AbsolutePathError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class AbsolutePathError(FilterError):\n    def __init__(self, tarinfo):\n        self.tarinfo = tarinfo\n        super().__init__(f'member {tarinfo.name!r} has an absolute path')\nclass OutsideDestinationError(FilterError):\n    def __init__(self, tarinfo, path):\n        self.tarinfo = tarinfo\n        self._path = path\n        super().__init__(f'{tarinfo.name!r} would be extracted to {path!r}, '\n                         + 'which is outside the destination')",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "OutsideDestinationError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class OutsideDestinationError(FilterError):\n    def __init__(self, tarinfo, path):\n        self.tarinfo = tarinfo\n        self._path = path\n        super().__init__(f'{tarinfo.name!r} would be extracted to {path!r}, '\n                         + 'which is outside the destination')\nclass SpecialFileError(FilterError):\n    def __init__(self, tarinfo):\n        self.tarinfo = tarinfo\n        super().__init__(f'{tarinfo.name!r} is a special file')",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "SpecialFileError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class SpecialFileError(FilterError):\n    def __init__(self, tarinfo):\n        self.tarinfo = tarinfo\n        super().__init__(f'{tarinfo.name!r} is a special file')\nclass AbsoluteLinkError(FilterError):\n    def __init__(self, tarinfo):\n        self.tarinfo = tarinfo\n        super().__init__(f'{tarinfo.name!r} is a link to an absolute path')\nclass LinkOutsideDestinationError(FilterError):\n    def __init__(self, tarinfo, path):",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "AbsoluteLinkError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class AbsoluteLinkError(FilterError):\n    def __init__(self, tarinfo):\n        self.tarinfo = tarinfo\n        super().__init__(f'{tarinfo.name!r} is a link to an absolute path')\nclass LinkOutsideDestinationError(FilterError):\n    def __init__(self, tarinfo, path):\n        self.tarinfo = tarinfo\n        self._path = path\n        super().__init__(f'{tarinfo.name!r} would link to {path!r}, '\n                         + 'which is outside the destination')",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "LinkOutsideDestinationError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class LinkOutsideDestinationError(FilterError):\n    def __init__(self, tarinfo, path):\n        self.tarinfo = tarinfo\n        self._path = path\n        super().__init__(f'{tarinfo.name!r} would link to {path!r}, '\n                         + 'which is outside the destination')\ndef _get_filtered_attrs(member, dest_path, for_data=True):\n    new_attrs = {}\n    name = member.name\n    dest_path = os.path.realpath(dest_path)",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "TarInfo",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class TarInfo(object):\n    \"\"\"Informational class which holds the details about an\n       archive member given by a tar header block.\n       TarInfo objects are returned by TarFile.getmember(),\n       TarFile.getmembers() and TarFile.gettarinfo() and are\n       usually created internally.\n    \"\"\"\n    __slots__ = dict(\n        name = 'Name of the archive member.',\n        mode = 'Permission bits.',",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "TarFile",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "class TarFile(object):\n    \"\"\"The TarFile Class provides an interface to tar archives.\n    \"\"\"\n    debug = 0                   # May be set from 0 (no msgs) to 3 (all msgs)\n    dereference = False         # If true, add content of linked file to the\n                                # tar file, else the link.\n    ignore_zeros = False        # If true, skips empty or invalid blocks and\n                                # continues processing.\n    errorlevel = 1              # If 0, fatal errors only appear in debug\n                                # messages (if debug >= 0). If > 0, errors",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "stn",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "def stn(s, length, encoding, errors):\n    \"\"\"Convert a string to a null-terminated bytes object.\n    \"\"\"\n    if s is None:\n        raise ValueError(\"metadata cannot contain None\")\n    s = s.encode(encoding, errors)\n    return s[:length] + (length - len(s)) * NUL\ndef nts(s, encoding, errors):\n    \"\"\"Convert a null-terminated bytes object to a string.\n    \"\"\"",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "nts",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "def nts(s, encoding, errors):\n    \"\"\"Convert a null-terminated bytes object to a string.\n    \"\"\"\n    p = s.find(b\"\\0\")\n    if p != -1:\n        s = s[:p]\n    return s.decode(encoding, errors)\ndef nti(s):\n    \"\"\"Convert a number field to a python number.\n    \"\"\"",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "nti",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "def nti(s):\n    \"\"\"Convert a number field to a python number.\n    \"\"\"\n    # There are two possible encodings for a number field, see\n    # itn() below.\n    if s[0] in (0o200, 0o377):\n        n = 0\n        for i in range(len(s) - 1):\n            n <<= 8\n            n += s[i + 1]",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "itn",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "def itn(n, digits=8, format=DEFAULT_FORMAT):\n    \"\"\"Convert a python number to a number field.\n    \"\"\"\n    # POSIX 1003.1-1988 requires numbers to be encoded as a string of\n    # octal digits followed by a null-byte, this allows values up to\n    # (8**(digits-1))-1. GNU tar allows storing numbers greater than\n    # that if necessary. A leading 0o200 or 0o377 byte indicate this\n    # particular encoding, the following digits-1 bytes are a big-endian\n    # base-256 representation. This allows values up to (256**(digits-1))-1.\n    # A 0o200 byte indicates a positive number, a 0o377 byte a negative",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "calc_chksums",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "def calc_chksums(buf):\n    \"\"\"Calculate the checksum for a member's header by summing up all\n       characters except for the chksum field which is treated as if\n       it was filled with spaces. According to the GNU tar sources,\n       some tars (Sun and NeXT) calculate chksum with signed char,\n       which will be different if there are chars in the buffer with\n       the high bit set. So we calculate two checksums, unsigned and\n       signed.\n    \"\"\"\n    unsigned_chksum = 256 + sum(struct.unpack_from(\"148B8x356B\", buf))",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "copyfileobj",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "def copyfileobj(src, dst, length=None, exception=OSError, bufsize=None):\n    \"\"\"Copy length bytes from fileobj src to fileobj dst.\n       If length is None, copy the entire content.\n    \"\"\"\n    bufsize = bufsize or 16 * 1024\n    if length == 0:\n        return\n    if length is None:\n        shutil.copyfileobj(src, dst, bufsize)\n        return",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "fully_trusted_filter",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "def fully_trusted_filter(member, dest_path):\n    return member\ndef tar_filter(member, dest_path):\n    new_attrs = _get_filtered_attrs(member, dest_path, False)\n    if new_attrs:\n        return member.replace(**new_attrs, deep=False)\n    return member\ndef data_filter(member, dest_path):\n    new_attrs = _get_filtered_attrs(member, dest_path, True)\n    if new_attrs:",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "tar_filter",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "def tar_filter(member, dest_path):\n    new_attrs = _get_filtered_attrs(member, dest_path, False)\n    if new_attrs:\n        return member.replace(**new_attrs, deep=False)\n    return member\ndef data_filter(member, dest_path):\n    new_attrs = _get_filtered_attrs(member, dest_path, True)\n    if new_attrs:\n        return member.replace(**new_attrs, deep=False)\n    return member",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "data_filter",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "def data_filter(member, dest_path):\n    new_attrs = _get_filtered_attrs(member, dest_path, True)\n    if new_attrs:\n        return member.replace(**new_attrs, deep=False)\n    return member\n_NAMED_FILTERS = {\n    \"fully_trusted\": fully_trusted_filter,\n    \"tar\": tar_filter,\n    \"data\": data_filter,\n}",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "is_tarfile",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "def is_tarfile(name):\n    \"\"\"Return True if name points to a tar archive that we\n       are able to handle, else return False.\n       'name' should be a string, file, or file-like object.\n    \"\"\"\n    try:\n        if hasattr(name, \"read\"):\n            pos = name.tell()\n            t = open(fileobj=name)\n            name.seek(pos)",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "def main():\n    import argparse\n    description = 'A simple command-line interface for tarfile module.'\n    parser = argparse.ArgumentParser(description=description)\n    parser.add_argument('-v', '--verbose', action='store_true', default=False,\n                        help='Verbose output')\n    parser.add_argument('--filter', metavar='<filtername>',\n                        choices=_NAMED_FILTERS,\n                        help='Filter for extraction')\n    group = parser.add_mutually_exclusive_group(required=True)",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "__credits__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "__credits__ = \"Gustavo Niemeyer, Niels Gust\\u00e4bel, Richard Townsend.\"\n#---------\n# Imports\n#---------\nfrom builtins import open as bltn_open\nimport sys\nimport os\nimport io\nimport shutil\nimport stat",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "symlink_exception",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "symlink_exception = (AttributeError, NotImplementedError, OSError)\n# from tarfile import *\n__all__ = [\"TarFile\", \"TarInfo\", \"is_tarfile\", \"TarError\", \"ReadError\",\n           \"CompressionError\", \"StreamError\", \"ExtractError\", \"HeaderError\",\n           \"ENCODING\", \"USTAR_FORMAT\", \"GNU_FORMAT\", \"PAX_FORMAT\",\n           \"DEFAULT_FORMAT\", \"open\",\"fully_trusted_filter\", \"data_filter\",\n           \"tar_filter\", \"FilterError\", \"AbsoluteLinkError\",\n           \"OutsideDestinationError\", \"SpecialFileError\", \"AbsolutePathError\",\n           \"LinkOutsideDestinationError\"]\n#---------------------------------------------------------",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "__all__ = [\"TarFile\", \"TarInfo\", \"is_tarfile\", \"TarError\", \"ReadError\",\n           \"CompressionError\", \"StreamError\", \"ExtractError\", \"HeaderError\",\n           \"ENCODING\", \"USTAR_FORMAT\", \"GNU_FORMAT\", \"PAX_FORMAT\",\n           \"DEFAULT_FORMAT\", \"open\",\"fully_trusted_filter\", \"data_filter\",\n           \"tar_filter\", \"FilterError\", \"AbsoluteLinkError\",\n           \"OutsideDestinationError\", \"SpecialFileError\", \"AbsolutePathError\",\n           \"LinkOutsideDestinationError\"]\n#---------------------------------------------------------\n# tar constants\n#---------------------------------------------------------",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "NUL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "NUL = b\"\\0\"                     # the null character\nBLOCKSIZE = 512                 # length of processing blocks\nRECORDSIZE = BLOCKSIZE * 20     # length of records\nGNU_MAGIC = b\"ustar  \\0\"        # magic gnu tar string\nPOSIX_MAGIC = b\"ustar\\x0000\"    # magic posix tar string\nLENGTH_NAME = 100               # maximum length of a filename\nLENGTH_LINK = 100               # maximum length of a linkname\nLENGTH_PREFIX = 155             # maximum length of the prefix field\nREGTYPE = b\"0\"                  # regular file\nAREGTYPE = b\"\\0\"                # regular file",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "BLOCKSIZE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "BLOCKSIZE = 512                 # length of processing blocks\nRECORDSIZE = BLOCKSIZE * 20     # length of records\nGNU_MAGIC = b\"ustar  \\0\"        # magic gnu tar string\nPOSIX_MAGIC = b\"ustar\\x0000\"    # magic posix tar string\nLENGTH_NAME = 100               # maximum length of a filename\nLENGTH_LINK = 100               # maximum length of a linkname\nLENGTH_PREFIX = 155             # maximum length of the prefix field\nREGTYPE = b\"0\"                  # regular file\nAREGTYPE = b\"\\0\"                # regular file\nLNKTYPE = b\"1\"                  # link (inside tarfile)",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "RECORDSIZE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "RECORDSIZE = BLOCKSIZE * 20     # length of records\nGNU_MAGIC = b\"ustar  \\0\"        # magic gnu tar string\nPOSIX_MAGIC = b\"ustar\\x0000\"    # magic posix tar string\nLENGTH_NAME = 100               # maximum length of a filename\nLENGTH_LINK = 100               # maximum length of a linkname\nLENGTH_PREFIX = 155             # maximum length of the prefix field\nREGTYPE = b\"0\"                  # regular file\nAREGTYPE = b\"\\0\"                # regular file\nLNKTYPE = b\"1\"                  # link (inside tarfile)\nSYMTYPE = b\"2\"                  # symbolic link",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "GNU_MAGIC",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "GNU_MAGIC = b\"ustar  \\0\"        # magic gnu tar string\nPOSIX_MAGIC = b\"ustar\\x0000\"    # magic posix tar string\nLENGTH_NAME = 100               # maximum length of a filename\nLENGTH_LINK = 100               # maximum length of a linkname\nLENGTH_PREFIX = 155             # maximum length of the prefix field\nREGTYPE = b\"0\"                  # regular file\nAREGTYPE = b\"\\0\"                # regular file\nLNKTYPE = b\"1\"                  # link (inside tarfile)\nSYMTYPE = b\"2\"                  # symbolic link\nCHRTYPE = b\"3\"                  # character special device",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "POSIX_MAGIC",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "POSIX_MAGIC = b\"ustar\\x0000\"    # magic posix tar string\nLENGTH_NAME = 100               # maximum length of a filename\nLENGTH_LINK = 100               # maximum length of a linkname\nLENGTH_PREFIX = 155             # maximum length of the prefix field\nREGTYPE = b\"0\"                  # regular file\nAREGTYPE = b\"\\0\"                # regular file\nLNKTYPE = b\"1\"                  # link (inside tarfile)\nSYMTYPE = b\"2\"                  # symbolic link\nCHRTYPE = b\"3\"                  # character special device\nBLKTYPE = b\"4\"                  # block special device",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "LENGTH_NAME",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "LENGTH_NAME = 100               # maximum length of a filename\nLENGTH_LINK = 100               # maximum length of a linkname\nLENGTH_PREFIX = 155             # maximum length of the prefix field\nREGTYPE = b\"0\"                  # regular file\nAREGTYPE = b\"\\0\"                # regular file\nLNKTYPE = b\"1\"                  # link (inside tarfile)\nSYMTYPE = b\"2\"                  # symbolic link\nCHRTYPE = b\"3\"                  # character special device\nBLKTYPE = b\"4\"                  # block special device\nDIRTYPE = b\"5\"                  # directory",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "LENGTH_LINK",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "LENGTH_LINK = 100               # maximum length of a linkname\nLENGTH_PREFIX = 155             # maximum length of the prefix field\nREGTYPE = b\"0\"                  # regular file\nAREGTYPE = b\"\\0\"                # regular file\nLNKTYPE = b\"1\"                  # link (inside tarfile)\nSYMTYPE = b\"2\"                  # symbolic link\nCHRTYPE = b\"3\"                  # character special device\nBLKTYPE = b\"4\"                  # block special device\nDIRTYPE = b\"5\"                  # directory\nFIFOTYPE = b\"6\"                 # fifo special device",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "LENGTH_PREFIX",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "LENGTH_PREFIX = 155             # maximum length of the prefix field\nREGTYPE = b\"0\"                  # regular file\nAREGTYPE = b\"\\0\"                # regular file\nLNKTYPE = b\"1\"                  # link (inside tarfile)\nSYMTYPE = b\"2\"                  # symbolic link\nCHRTYPE = b\"3\"                  # character special device\nBLKTYPE = b\"4\"                  # block special device\nDIRTYPE = b\"5\"                  # directory\nFIFOTYPE = b\"6\"                 # fifo special device\nCONTTYPE = b\"7\"                 # contiguous file",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "REGTYPE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "REGTYPE = b\"0\"                  # regular file\nAREGTYPE = b\"\\0\"                # regular file\nLNKTYPE = b\"1\"                  # link (inside tarfile)\nSYMTYPE = b\"2\"                  # symbolic link\nCHRTYPE = b\"3\"                  # character special device\nBLKTYPE = b\"4\"                  # block special device\nDIRTYPE = b\"5\"                  # directory\nFIFOTYPE = b\"6\"                 # fifo special device\nCONTTYPE = b\"7\"                 # contiguous file\nGNUTYPE_LONGNAME = b\"L\"         # GNU tar longname",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "AREGTYPE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "AREGTYPE = b\"\\0\"                # regular file\nLNKTYPE = b\"1\"                  # link (inside tarfile)\nSYMTYPE = b\"2\"                  # symbolic link\nCHRTYPE = b\"3\"                  # character special device\nBLKTYPE = b\"4\"                  # block special device\nDIRTYPE = b\"5\"                  # directory\nFIFOTYPE = b\"6\"                 # fifo special device\nCONTTYPE = b\"7\"                 # contiguous file\nGNUTYPE_LONGNAME = b\"L\"         # GNU tar longname\nGNUTYPE_LONGLINK = b\"K\"         # GNU tar longlink",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "LNKTYPE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "LNKTYPE = b\"1\"                  # link (inside tarfile)\nSYMTYPE = b\"2\"                  # symbolic link\nCHRTYPE = b\"3\"                  # character special device\nBLKTYPE = b\"4\"                  # block special device\nDIRTYPE = b\"5\"                  # directory\nFIFOTYPE = b\"6\"                 # fifo special device\nCONTTYPE = b\"7\"                 # contiguous file\nGNUTYPE_LONGNAME = b\"L\"         # GNU tar longname\nGNUTYPE_LONGLINK = b\"K\"         # GNU tar longlink\nGNUTYPE_SPARSE = b\"S\"           # GNU tar sparse file",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "SYMTYPE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "SYMTYPE = b\"2\"                  # symbolic link\nCHRTYPE = b\"3\"                  # character special device\nBLKTYPE = b\"4\"                  # block special device\nDIRTYPE = b\"5\"                  # directory\nFIFOTYPE = b\"6\"                 # fifo special device\nCONTTYPE = b\"7\"                 # contiguous file\nGNUTYPE_LONGNAME = b\"L\"         # GNU tar longname\nGNUTYPE_LONGLINK = b\"K\"         # GNU tar longlink\nGNUTYPE_SPARSE = b\"S\"           # GNU tar sparse file\nXHDTYPE = b\"x\"                  # POSIX.1-2001 extended header",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "CHRTYPE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "CHRTYPE = b\"3\"                  # character special device\nBLKTYPE = b\"4\"                  # block special device\nDIRTYPE = b\"5\"                  # directory\nFIFOTYPE = b\"6\"                 # fifo special device\nCONTTYPE = b\"7\"                 # contiguous file\nGNUTYPE_LONGNAME = b\"L\"         # GNU tar longname\nGNUTYPE_LONGLINK = b\"K\"         # GNU tar longlink\nGNUTYPE_SPARSE = b\"S\"           # GNU tar sparse file\nXHDTYPE = b\"x\"                  # POSIX.1-2001 extended header\nXGLTYPE = b\"g\"                  # POSIX.1-2001 global header",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "BLKTYPE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "BLKTYPE = b\"4\"                  # block special device\nDIRTYPE = b\"5\"                  # directory\nFIFOTYPE = b\"6\"                 # fifo special device\nCONTTYPE = b\"7\"                 # contiguous file\nGNUTYPE_LONGNAME = b\"L\"         # GNU tar longname\nGNUTYPE_LONGLINK = b\"K\"         # GNU tar longlink\nGNUTYPE_SPARSE = b\"S\"           # GNU tar sparse file\nXHDTYPE = b\"x\"                  # POSIX.1-2001 extended header\nXGLTYPE = b\"g\"                  # POSIX.1-2001 global header\nSOLARIS_XHDTYPE = b\"X\"          # Solaris extended header",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "DIRTYPE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "DIRTYPE = b\"5\"                  # directory\nFIFOTYPE = b\"6\"                 # fifo special device\nCONTTYPE = b\"7\"                 # contiguous file\nGNUTYPE_LONGNAME = b\"L\"         # GNU tar longname\nGNUTYPE_LONGLINK = b\"K\"         # GNU tar longlink\nGNUTYPE_SPARSE = b\"S\"           # GNU tar sparse file\nXHDTYPE = b\"x\"                  # POSIX.1-2001 extended header\nXGLTYPE = b\"g\"                  # POSIX.1-2001 global header\nSOLARIS_XHDTYPE = b\"X\"          # Solaris extended header\nUSTAR_FORMAT = 0                # POSIX.1-1988 (ustar) format",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "FIFOTYPE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "FIFOTYPE = b\"6\"                 # fifo special device\nCONTTYPE = b\"7\"                 # contiguous file\nGNUTYPE_LONGNAME = b\"L\"         # GNU tar longname\nGNUTYPE_LONGLINK = b\"K\"         # GNU tar longlink\nGNUTYPE_SPARSE = b\"S\"           # GNU tar sparse file\nXHDTYPE = b\"x\"                  # POSIX.1-2001 extended header\nXGLTYPE = b\"g\"                  # POSIX.1-2001 global header\nSOLARIS_XHDTYPE = b\"X\"          # Solaris extended header\nUSTAR_FORMAT = 0                # POSIX.1-1988 (ustar) format\nGNU_FORMAT = 1                  # GNU tar format",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "CONTTYPE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "CONTTYPE = b\"7\"                 # contiguous file\nGNUTYPE_LONGNAME = b\"L\"         # GNU tar longname\nGNUTYPE_LONGLINK = b\"K\"         # GNU tar longlink\nGNUTYPE_SPARSE = b\"S\"           # GNU tar sparse file\nXHDTYPE = b\"x\"                  # POSIX.1-2001 extended header\nXGLTYPE = b\"g\"                  # POSIX.1-2001 global header\nSOLARIS_XHDTYPE = b\"X\"          # Solaris extended header\nUSTAR_FORMAT = 0                # POSIX.1-1988 (ustar) format\nGNU_FORMAT = 1                  # GNU tar format\nPAX_FORMAT = 2                  # POSIX.1-2001 (pax) format",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "GNUTYPE_LONGNAME",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "GNUTYPE_LONGNAME = b\"L\"         # GNU tar longname\nGNUTYPE_LONGLINK = b\"K\"         # GNU tar longlink\nGNUTYPE_SPARSE = b\"S\"           # GNU tar sparse file\nXHDTYPE = b\"x\"                  # POSIX.1-2001 extended header\nXGLTYPE = b\"g\"                  # POSIX.1-2001 global header\nSOLARIS_XHDTYPE = b\"X\"          # Solaris extended header\nUSTAR_FORMAT = 0                # POSIX.1-1988 (ustar) format\nGNU_FORMAT = 1                  # GNU tar format\nPAX_FORMAT = 2                  # POSIX.1-2001 (pax) format\nDEFAULT_FORMAT = PAX_FORMAT",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "GNUTYPE_LONGLINK",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "GNUTYPE_LONGLINK = b\"K\"         # GNU tar longlink\nGNUTYPE_SPARSE = b\"S\"           # GNU tar sparse file\nXHDTYPE = b\"x\"                  # POSIX.1-2001 extended header\nXGLTYPE = b\"g\"                  # POSIX.1-2001 global header\nSOLARIS_XHDTYPE = b\"X\"          # Solaris extended header\nUSTAR_FORMAT = 0                # POSIX.1-1988 (ustar) format\nGNU_FORMAT = 1                  # GNU tar format\nPAX_FORMAT = 2                  # POSIX.1-2001 (pax) format\nDEFAULT_FORMAT = PAX_FORMAT\n#---------------------------------------------------------",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "GNUTYPE_SPARSE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "GNUTYPE_SPARSE = b\"S\"           # GNU tar sparse file\nXHDTYPE = b\"x\"                  # POSIX.1-2001 extended header\nXGLTYPE = b\"g\"                  # POSIX.1-2001 global header\nSOLARIS_XHDTYPE = b\"X\"          # Solaris extended header\nUSTAR_FORMAT = 0                # POSIX.1-1988 (ustar) format\nGNU_FORMAT = 1                  # GNU tar format\nPAX_FORMAT = 2                  # POSIX.1-2001 (pax) format\nDEFAULT_FORMAT = PAX_FORMAT\n#---------------------------------------------------------\n# tarfile constants",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "XHDTYPE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "XHDTYPE = b\"x\"                  # POSIX.1-2001 extended header\nXGLTYPE = b\"g\"                  # POSIX.1-2001 global header\nSOLARIS_XHDTYPE = b\"X\"          # Solaris extended header\nUSTAR_FORMAT = 0                # POSIX.1-1988 (ustar) format\nGNU_FORMAT = 1                  # GNU tar format\nPAX_FORMAT = 2                  # POSIX.1-2001 (pax) format\nDEFAULT_FORMAT = PAX_FORMAT\n#---------------------------------------------------------\n# tarfile constants\n#---------------------------------------------------------",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "XGLTYPE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "XGLTYPE = b\"g\"                  # POSIX.1-2001 global header\nSOLARIS_XHDTYPE = b\"X\"          # Solaris extended header\nUSTAR_FORMAT = 0                # POSIX.1-1988 (ustar) format\nGNU_FORMAT = 1                  # GNU tar format\nPAX_FORMAT = 2                  # POSIX.1-2001 (pax) format\nDEFAULT_FORMAT = PAX_FORMAT\n#---------------------------------------------------------\n# tarfile constants\n#---------------------------------------------------------\n# File types that tarfile supports:",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "SOLARIS_XHDTYPE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "SOLARIS_XHDTYPE = b\"X\"          # Solaris extended header\nUSTAR_FORMAT = 0                # POSIX.1-1988 (ustar) format\nGNU_FORMAT = 1                  # GNU tar format\nPAX_FORMAT = 2                  # POSIX.1-2001 (pax) format\nDEFAULT_FORMAT = PAX_FORMAT\n#---------------------------------------------------------\n# tarfile constants\n#---------------------------------------------------------\n# File types that tarfile supports:\nSUPPORTED_TYPES = (REGTYPE, AREGTYPE, LNKTYPE,",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "USTAR_FORMAT",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "USTAR_FORMAT = 0                # POSIX.1-1988 (ustar) format\nGNU_FORMAT = 1                  # GNU tar format\nPAX_FORMAT = 2                  # POSIX.1-2001 (pax) format\nDEFAULT_FORMAT = PAX_FORMAT\n#---------------------------------------------------------\n# tarfile constants\n#---------------------------------------------------------\n# File types that tarfile supports:\nSUPPORTED_TYPES = (REGTYPE, AREGTYPE, LNKTYPE,\n                   SYMTYPE, DIRTYPE, FIFOTYPE,",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "GNU_FORMAT",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "GNU_FORMAT = 1                  # GNU tar format\nPAX_FORMAT = 2                  # POSIX.1-2001 (pax) format\nDEFAULT_FORMAT = PAX_FORMAT\n#---------------------------------------------------------\n# tarfile constants\n#---------------------------------------------------------\n# File types that tarfile supports:\nSUPPORTED_TYPES = (REGTYPE, AREGTYPE, LNKTYPE,\n                   SYMTYPE, DIRTYPE, FIFOTYPE,\n                   CONTTYPE, CHRTYPE, BLKTYPE,",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "PAX_FORMAT",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "PAX_FORMAT = 2                  # POSIX.1-2001 (pax) format\nDEFAULT_FORMAT = PAX_FORMAT\n#---------------------------------------------------------\n# tarfile constants\n#---------------------------------------------------------\n# File types that tarfile supports:\nSUPPORTED_TYPES = (REGTYPE, AREGTYPE, LNKTYPE,\n                   SYMTYPE, DIRTYPE, FIFOTYPE,\n                   CONTTYPE, CHRTYPE, BLKTYPE,\n                   GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "DEFAULT_FORMAT",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "DEFAULT_FORMAT = PAX_FORMAT\n#---------------------------------------------------------\n# tarfile constants\n#---------------------------------------------------------\n# File types that tarfile supports:\nSUPPORTED_TYPES = (REGTYPE, AREGTYPE, LNKTYPE,\n                   SYMTYPE, DIRTYPE, FIFOTYPE,\n                   CONTTYPE, CHRTYPE, BLKTYPE,\n                   GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,\n                   GNUTYPE_SPARSE)",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "SUPPORTED_TYPES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "SUPPORTED_TYPES = (REGTYPE, AREGTYPE, LNKTYPE,\n                   SYMTYPE, DIRTYPE, FIFOTYPE,\n                   CONTTYPE, CHRTYPE, BLKTYPE,\n                   GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,\n                   GNUTYPE_SPARSE)\n# File types that will be treated as a regular file.\nREGULAR_TYPES = (REGTYPE, AREGTYPE,\n                 CONTTYPE, GNUTYPE_SPARSE)\n# File types that are part of the GNU tar format.\nGNU_TYPES = (GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "REGULAR_TYPES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "REGULAR_TYPES = (REGTYPE, AREGTYPE,\n                 CONTTYPE, GNUTYPE_SPARSE)\n# File types that are part of the GNU tar format.\nGNU_TYPES = (GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,\n             GNUTYPE_SPARSE)\n# Fields from a pax header that override a TarInfo attribute.\nPAX_FIELDS = (\"path\", \"linkpath\", \"size\", \"mtime\",\n              \"uid\", \"gid\", \"uname\", \"gname\")\n# Fields from a pax header that are affected by hdrcharset.\nPAX_NAME_FIELDS = {\"path\", \"linkpath\", \"uname\", \"gname\"}",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "GNU_TYPES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "GNU_TYPES = (GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,\n             GNUTYPE_SPARSE)\n# Fields from a pax header that override a TarInfo attribute.\nPAX_FIELDS = (\"path\", \"linkpath\", \"size\", \"mtime\",\n              \"uid\", \"gid\", \"uname\", \"gname\")\n# Fields from a pax header that are affected by hdrcharset.\nPAX_NAME_FIELDS = {\"path\", \"linkpath\", \"uname\", \"gname\"}\n# Fields in a pax header that are numbers, all other fields\n# are treated as strings.\nPAX_NUMBER_FIELDS = {",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "PAX_FIELDS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "PAX_FIELDS = (\"path\", \"linkpath\", \"size\", \"mtime\",\n              \"uid\", \"gid\", \"uname\", \"gname\")\n# Fields from a pax header that are affected by hdrcharset.\nPAX_NAME_FIELDS = {\"path\", \"linkpath\", \"uname\", \"gname\"}\n# Fields in a pax header that are numbers, all other fields\n# are treated as strings.\nPAX_NUMBER_FIELDS = {\n    \"atime\": float,\n    \"ctime\": float,\n    \"mtime\": float,",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "PAX_NAME_FIELDS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "PAX_NAME_FIELDS = {\"path\", \"linkpath\", \"uname\", \"gname\"}\n# Fields in a pax header that are numbers, all other fields\n# are treated as strings.\nPAX_NUMBER_FIELDS = {\n    \"atime\": float,\n    \"ctime\": float,\n    \"mtime\": float,\n    \"uid\": int,\n    \"gid\": int,\n    \"size\": int",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "PAX_NUMBER_FIELDS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "PAX_NUMBER_FIELDS = {\n    \"atime\": float,\n    \"ctime\": float,\n    \"mtime\": float,\n    \"uid\": int,\n    \"gid\": int,\n    \"size\": int\n}\n#---------------------------------------------------------\n# initialization",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "_NAMED_FILTERS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "_NAMED_FILTERS = {\n    \"fully_trusted\": fully_trusted_filter,\n    \"tar\": tar_filter,\n    \"data\": data_filter,\n}\n#------------------\n# Exported Classes\n#------------------\n# Sentinel for replace() defaults, meaning \"don't change the attribute\"\n_KEEP = object()",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "_KEEP",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "_KEEP = object()\n# Header length is digits followed by a space.\n_header_length_prefix_re = re.compile(br\"([0-9]{1,20}) \")\nclass TarInfo(object):\n    \"\"\"Informational class which holds the details about an\n       archive member given by a tar header block.\n       TarInfo objects are returned by TarFile.getmember(),\n       TarFile.getmembers() and TarFile.gettarinfo() and are\n       usually created internally.\n    \"\"\"",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "_header_length_prefix_re",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "_header_length_prefix_re = re.compile(br\"([0-9]{1,20}) \")\nclass TarInfo(object):\n    \"\"\"Informational class which holds the details about an\n       archive member given by a tar header block.\n       TarInfo objects are returned by TarFile.getmember(),\n       TarFile.getmembers() and TarFile.gettarinfo() and are\n       usually created internally.\n    \"\"\"\n    __slots__ = dict(\n        name = 'Name of the archive member.',",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "open",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tarfile",
        "description": "pycharm_venv.Lib.tarfile",
        "peekOfCode": "open = TarFile.open\ndef main():\n    import argparse\n    description = 'A simple command-line interface for tarfile module.'\n    parser = argparse.ArgumentParser(description=description)\n    parser.add_argument('-v', '--verbose', action='store_true', default=False,\n                        help='Verbose output')\n    parser.add_argument('--filter', metavar='<filtername>',\n                        choices=_NAMED_FILTERS,\n                        help='Filter for extraction')",
        "detail": "pycharm_venv.Lib.tarfile",
        "documentation": {}
    },
    {
        "label": "_RandomNameSequence",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "class _RandomNameSequence:\n    \"\"\"An instance of _RandomNameSequence generates an endless\n    sequence of unpredictable strings which can safely be incorporated\n    into file names.  Each string is eight characters long.  Multiple\n    threads can safely use the same instance at the same time.\n    _RandomNameSequence is an iterator.\"\"\"\n    characters = \"abcdefghijklmnopqrstuvwxyz0123456789_\"\n    @property\n    def rng(self):\n        cur_pid = _os.getpid()",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "_TemporaryFileCloser",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "class _TemporaryFileCloser:\n    \"\"\"A separate object allowing proper closing of a temporary file's\n    underlying file object, without adding a __del__ method to the\n    temporary file.\"\"\"\n    cleanup_called = False\n    close_called = False\n    def __init__(self, file, name, delete=True, delete_on_close=True):\n        self.file = file\n        self.name = name\n        self.delete = delete",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "_TemporaryFileWrapper",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "class _TemporaryFileWrapper:\n    \"\"\"Temporary file wrapper\n    This class provides a wrapper around files opened for\n    temporary use.  In particular, it seeks to automatically\n    remove the file when it is no longer needed.\n    \"\"\"\n    def __init__(self, file, name, delete=True, delete_on_close=True):\n        self.file = file\n        self.name = name\n        self._closer = _TemporaryFileCloser(file, name, delete,",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "SpooledTemporaryFile",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "class SpooledTemporaryFile(_io.IOBase):\n    \"\"\"Temporary file wrapper, specialized to switch from BytesIO\n    or StringIO to a real file when it exceeds a certain size or\n    when a fileno is needed.\n    \"\"\"\n    _rolled = False\n    def __init__(self, max_size=0, mode='w+b', buffering=-1,\n                 encoding=None, newline=None,\n                 suffix=None, prefix=None, dir=None, *, errors=None):\n        if 'b' in mode:",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "TemporaryDirectory",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "class TemporaryDirectory:\n    \"\"\"Create and return a temporary directory.  This has the same\n    behavior as mkdtemp but can be used as a context manager.  For\n    example:\n        with TemporaryDirectory() as tmpdir:\n            ...\n    Upon exiting the context, the directory and everything contained\n    in it are removed (unless delete=False is passed or an exception\n    is raised during cleanup and ignore_cleanup_errors is not True).\n    Optional Arguments:",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "gettempprefix",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "def gettempprefix():\n    \"\"\"The default prefix for temporary directories as string.\"\"\"\n    return _os.fsdecode(template)\ndef gettempprefixb():\n    \"\"\"The default prefix for temporary directories as bytes.\"\"\"\n    return _os.fsencode(template)\ntempdir = None\ndef _gettempdir():\n    \"\"\"Private accessor for tempfile.tempdir.\"\"\"\n    global tempdir",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "gettempprefixb",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "def gettempprefixb():\n    \"\"\"The default prefix for temporary directories as bytes.\"\"\"\n    return _os.fsencode(template)\ntempdir = None\ndef _gettempdir():\n    \"\"\"Private accessor for tempfile.tempdir.\"\"\"\n    global tempdir\n    if tempdir is None:\n        _once_lock.acquire()\n        try:",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "gettempdir",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "def gettempdir():\n    \"\"\"Returns tempfile.tempdir as str.\"\"\"\n    return _os.fsdecode(_gettempdir())\ndef gettempdirb():\n    \"\"\"Returns tempfile.tempdir as bytes.\"\"\"\n    return _os.fsencode(_gettempdir())\ndef mkstemp(suffix=None, prefix=None, dir=None, text=False):\n    \"\"\"User-callable function to create and return a unique temporary\n    file.  The return value is a pair (fd, name) where fd is the\n    file descriptor returned by os.open, and name is the filename.",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "gettempdirb",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "def gettempdirb():\n    \"\"\"Returns tempfile.tempdir as bytes.\"\"\"\n    return _os.fsencode(_gettempdir())\ndef mkstemp(suffix=None, prefix=None, dir=None, text=False):\n    \"\"\"User-callable function to create and return a unique temporary\n    file.  The return value is a pair (fd, name) where fd is the\n    file descriptor returned by os.open, and name is the filename.\n    If 'suffix' is not None, the file name will end with that suffix,\n    otherwise there will be no suffix.\n    If 'prefix' is not None, the file name will begin with that prefix,",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "mkstemp",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "def mkstemp(suffix=None, prefix=None, dir=None, text=False):\n    \"\"\"User-callable function to create and return a unique temporary\n    file.  The return value is a pair (fd, name) where fd is the\n    file descriptor returned by os.open, and name is the filename.\n    If 'suffix' is not None, the file name will end with that suffix,\n    otherwise there will be no suffix.\n    If 'prefix' is not None, the file name will begin with that prefix,\n    otherwise a default prefix is used.\n    If 'dir' is not None, the file will be created in that directory,\n    otherwise a default directory is used.",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "mkdtemp",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "def mkdtemp(suffix=None, prefix=None, dir=None):\n    \"\"\"User-callable function to create and return a unique temporary\n    directory.  The return value is the pathname of the directory.\n    Arguments are as for mkstemp, except that the 'text' argument is\n    not accepted.\n    The directory is readable, writable, and searchable only by the\n    creating user.\n    Caller is responsible for deleting the directory when done with it.\n    \"\"\"\n    prefix, suffix, dir, output_type = _sanitize_params(prefix, suffix, dir)",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "mktemp",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "def mktemp(suffix=\"\", prefix=template, dir=None):\n    \"\"\"User-callable function to return a unique temporary file name.  The\n    file is not created.\n    Arguments are similar to mkstemp, except that the 'text' argument is\n    not accepted, and suffix=None, prefix=None and bytes file names are not\n    supported.\n    THIS FUNCTION IS UNSAFE AND SHOULD NOT BE USED.  The file name may\n    refer to a file that did not exist at some point, but by the time\n    you get around to creating it, someone else may have beaten you to\n    the punch.",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "NamedTemporaryFile",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "def NamedTemporaryFile(mode='w+b', buffering=-1, encoding=None,\n                       newline=None, suffix=None, prefix=None,\n                       dir=None, delete=True, *, errors=None,\n                       delete_on_close=True):\n    \"\"\"Create and return a temporary file.\n    Arguments:\n    'prefix', 'suffix', 'dir' -- as for mkstemp.\n    'mode' -- the mode argument to io.open (default \"w+b\").\n    'buffering' -- the buffer size argument to io.open (default -1).\n    'encoding' -- the encoding argument to io.open (default None)",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "__all__ = [\n    \"NamedTemporaryFile\", \"TemporaryFile\", # high level safe interfaces\n    \"SpooledTemporaryFile\", \"TemporaryDirectory\",\n    \"mkstemp\", \"mkdtemp\",                  # low level safe interfaces\n    \"mktemp\",                              # deprecated unsafe interface\n    \"TMP_MAX\", \"gettempprefix\",            # constants\n    \"tempdir\", \"gettempdir\",\n    \"gettempprefixb\", \"gettempdirb\",\n   ]\n# Imports.",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "_allocate_lock",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "_allocate_lock = _thread.allocate_lock\n_text_openflags = _os.O_RDWR | _os.O_CREAT | _os.O_EXCL\nif hasattr(_os, 'O_NOFOLLOW'):\n    _text_openflags |= _os.O_NOFOLLOW\n_bin_openflags = _text_openflags\nif hasattr(_os, 'O_BINARY'):\n    _bin_openflags |= _os.O_BINARY\nif hasattr(_os, 'TMP_MAX'):\n    TMP_MAX = _os.TMP_MAX\nelse:",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "_text_openflags",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "_text_openflags = _os.O_RDWR | _os.O_CREAT | _os.O_EXCL\nif hasattr(_os, 'O_NOFOLLOW'):\n    _text_openflags |= _os.O_NOFOLLOW\n_bin_openflags = _text_openflags\nif hasattr(_os, 'O_BINARY'):\n    _bin_openflags |= _os.O_BINARY\nif hasattr(_os, 'TMP_MAX'):\n    TMP_MAX = _os.TMP_MAX\nelse:\n    TMP_MAX = 10000",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "_bin_openflags",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "_bin_openflags = _text_openflags\nif hasattr(_os, 'O_BINARY'):\n    _bin_openflags |= _os.O_BINARY\nif hasattr(_os, 'TMP_MAX'):\n    TMP_MAX = _os.TMP_MAX\nelse:\n    TMP_MAX = 10000\n# This variable _was_ unused for legacy reasons, see issue 10354.\n# But as of 3.5 we actually use it at runtime so changing it would\n# have a possibly desirable side effect...  But we do not want to support",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "template",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "template = \"tmp\"\n# Internal routines.\n_once_lock = _allocate_lock()\ndef _exists(fn):\n    try:\n        _os.lstat(fn)\n    except OSError:\n        return False\n    else:\n        return True",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "_once_lock",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "_once_lock = _allocate_lock()\ndef _exists(fn):\n    try:\n        _os.lstat(fn)\n    except OSError:\n        return False\n    else:\n        return True\ndef _infer_return_type(*args):\n    \"\"\"Look at the type of all args and divine their implied return type.\"\"\"",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "_name_sequence",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "_name_sequence = None\ndef _get_candidate_names():\n    \"\"\"Common setup sequence for all user-callable interfaces.\"\"\"\n    global _name_sequence\n    if _name_sequence is None:\n        _once_lock.acquire()\n        try:\n            if _name_sequence is None:\n                _name_sequence = _RandomNameSequence()\n        finally:",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "tempdir",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tempfile",
        "description": "pycharm_venv.Lib.tempfile",
        "peekOfCode": "tempdir = None\ndef _gettempdir():\n    \"\"\"Private accessor for tempfile.tempdir.\"\"\"\n    global tempdir\n    if tempdir is None:\n        _once_lock.acquire()\n        try:\n            if tempdir is None:\n                tempdir = _get_default_tempdir()\n        finally:",
        "detail": "pycharm_venv.Lib.tempfile",
        "documentation": {}
    },
    {
        "label": "ISTERMINAL",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "def ISTERMINAL(x):\n    return x < NT_OFFSET\ndef ISNONTERMINAL(x):\n    return x >= NT_OFFSET\ndef ISEOF(x):\n    return x == ENDMARKER",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "ISNONTERMINAL",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "def ISNONTERMINAL(x):\n    return x >= NT_OFFSET\ndef ISEOF(x):\n    return x == ENDMARKER",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "ISEOF",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "def ISEOF(x):\n    return x == ENDMARKER",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "__all__ = ['tok_name', 'ISTERMINAL', 'ISNONTERMINAL', 'ISEOF']\nENDMARKER = 0\nNAME = 1\nNUMBER = 2\nSTRING = 3\nNEWLINE = 4\nINDENT = 5\nDEDENT = 6\nLPAR = 7\nRPAR = 8",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "ENDMARKER",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "ENDMARKER = 0\nNAME = 1\nNUMBER = 2\nSTRING = 3\nNEWLINE = 4\nINDENT = 5\nDEDENT = 6\nLPAR = 7\nRPAR = 8\nLSQB = 9",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "NAME",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "NAME = 1\nNUMBER = 2\nSTRING = 3\nNEWLINE = 4\nINDENT = 5\nDEDENT = 6\nLPAR = 7\nRPAR = 8\nLSQB = 9\nRSQB = 10",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "NUMBER",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "NUMBER = 2\nSTRING = 3\nNEWLINE = 4\nINDENT = 5\nDEDENT = 6\nLPAR = 7\nRPAR = 8\nLSQB = 9\nRSQB = 10\nCOLON = 11",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "STRING",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "STRING = 3\nNEWLINE = 4\nINDENT = 5\nDEDENT = 6\nLPAR = 7\nRPAR = 8\nLSQB = 9\nRSQB = 10\nCOLON = 11\nCOMMA = 12",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "NEWLINE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "NEWLINE = 4\nINDENT = 5\nDEDENT = 6\nLPAR = 7\nRPAR = 8\nLSQB = 9\nRSQB = 10\nCOLON = 11\nCOMMA = 12\nSEMI = 13",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "INDENT",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "INDENT = 5\nDEDENT = 6\nLPAR = 7\nRPAR = 8\nLSQB = 9\nRSQB = 10\nCOLON = 11\nCOMMA = 12\nSEMI = 13\nPLUS = 14",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "DEDENT",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "DEDENT = 6\nLPAR = 7\nRPAR = 8\nLSQB = 9\nRSQB = 10\nCOLON = 11\nCOMMA = 12\nSEMI = 13\nPLUS = 14\nMINUS = 15",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "LPAR",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "LPAR = 7\nRPAR = 8\nLSQB = 9\nRSQB = 10\nCOLON = 11\nCOMMA = 12\nSEMI = 13\nPLUS = 14\nMINUS = 15\nSTAR = 16",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "RPAR",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "RPAR = 8\nLSQB = 9\nRSQB = 10\nCOLON = 11\nCOMMA = 12\nSEMI = 13\nPLUS = 14\nMINUS = 15\nSTAR = 16\nSLASH = 17",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "LSQB",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "LSQB = 9\nRSQB = 10\nCOLON = 11\nCOMMA = 12\nSEMI = 13\nPLUS = 14\nMINUS = 15\nSTAR = 16\nSLASH = 17\nVBAR = 18",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "RSQB",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "RSQB = 10\nCOLON = 11\nCOMMA = 12\nSEMI = 13\nPLUS = 14\nMINUS = 15\nSTAR = 16\nSLASH = 17\nVBAR = 18\nAMPER = 19",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "COLON",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "COLON = 11\nCOMMA = 12\nSEMI = 13\nPLUS = 14\nMINUS = 15\nSTAR = 16\nSLASH = 17\nVBAR = 18\nAMPER = 19\nLESS = 20",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "COMMA",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "COMMA = 12\nSEMI = 13\nPLUS = 14\nMINUS = 15\nSTAR = 16\nSLASH = 17\nVBAR = 18\nAMPER = 19\nLESS = 20\nGREATER = 21",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "SEMI",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "SEMI = 13\nPLUS = 14\nMINUS = 15\nSTAR = 16\nSLASH = 17\nVBAR = 18\nAMPER = 19\nLESS = 20\nGREATER = 21\nEQUAL = 22",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "PLUS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "PLUS = 14\nMINUS = 15\nSTAR = 16\nSLASH = 17\nVBAR = 18\nAMPER = 19\nLESS = 20\nGREATER = 21\nEQUAL = 22\nDOT = 23",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "MINUS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "MINUS = 15\nSTAR = 16\nSLASH = 17\nVBAR = 18\nAMPER = 19\nLESS = 20\nGREATER = 21\nEQUAL = 22\nDOT = 23\nPERCENT = 24",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "STAR",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "STAR = 16\nSLASH = 17\nVBAR = 18\nAMPER = 19\nLESS = 20\nGREATER = 21\nEQUAL = 22\nDOT = 23\nPERCENT = 24\nLBRACE = 25",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "SLASH",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "SLASH = 17\nVBAR = 18\nAMPER = 19\nLESS = 20\nGREATER = 21\nEQUAL = 22\nDOT = 23\nPERCENT = 24\nLBRACE = 25\nRBRACE = 26",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "VBAR",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "VBAR = 18\nAMPER = 19\nLESS = 20\nGREATER = 21\nEQUAL = 22\nDOT = 23\nPERCENT = 24\nLBRACE = 25\nRBRACE = 26\nEQEQUAL = 27",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "AMPER",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "AMPER = 19\nLESS = 20\nGREATER = 21\nEQUAL = 22\nDOT = 23\nPERCENT = 24\nLBRACE = 25\nRBRACE = 26\nEQEQUAL = 27\nNOTEQUAL = 28",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "LESS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "LESS = 20\nGREATER = 21\nEQUAL = 22\nDOT = 23\nPERCENT = 24\nLBRACE = 25\nRBRACE = 26\nEQEQUAL = 27\nNOTEQUAL = 28\nLESSEQUAL = 29",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "GREATER",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "GREATER = 21\nEQUAL = 22\nDOT = 23\nPERCENT = 24\nLBRACE = 25\nRBRACE = 26\nEQEQUAL = 27\nNOTEQUAL = 28\nLESSEQUAL = 29\nGREATEREQUAL = 30",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "EQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "EQUAL = 22\nDOT = 23\nPERCENT = 24\nLBRACE = 25\nRBRACE = 26\nEQEQUAL = 27\nNOTEQUAL = 28\nLESSEQUAL = 29\nGREATEREQUAL = 30\nTILDE = 31",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "DOT",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "DOT = 23\nPERCENT = 24\nLBRACE = 25\nRBRACE = 26\nEQEQUAL = 27\nNOTEQUAL = 28\nLESSEQUAL = 29\nGREATEREQUAL = 30\nTILDE = 31\nCIRCUMFLEX = 32",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "PERCENT",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "PERCENT = 24\nLBRACE = 25\nRBRACE = 26\nEQEQUAL = 27\nNOTEQUAL = 28\nLESSEQUAL = 29\nGREATEREQUAL = 30\nTILDE = 31\nCIRCUMFLEX = 32\nLEFTSHIFT = 33",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "LBRACE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "LBRACE = 25\nRBRACE = 26\nEQEQUAL = 27\nNOTEQUAL = 28\nLESSEQUAL = 29\nGREATEREQUAL = 30\nTILDE = 31\nCIRCUMFLEX = 32\nLEFTSHIFT = 33\nRIGHTSHIFT = 34",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "RBRACE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "RBRACE = 26\nEQEQUAL = 27\nNOTEQUAL = 28\nLESSEQUAL = 29\nGREATEREQUAL = 30\nTILDE = 31\nCIRCUMFLEX = 32\nLEFTSHIFT = 33\nRIGHTSHIFT = 34\nDOUBLESTAR = 35",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "EQEQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "EQEQUAL = 27\nNOTEQUAL = 28\nLESSEQUAL = 29\nGREATEREQUAL = 30\nTILDE = 31\nCIRCUMFLEX = 32\nLEFTSHIFT = 33\nRIGHTSHIFT = 34\nDOUBLESTAR = 35\nPLUSEQUAL = 36",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "NOTEQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "NOTEQUAL = 28\nLESSEQUAL = 29\nGREATEREQUAL = 30\nTILDE = 31\nCIRCUMFLEX = 32\nLEFTSHIFT = 33\nRIGHTSHIFT = 34\nDOUBLESTAR = 35\nPLUSEQUAL = 36\nMINEQUAL = 37",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "LESSEQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "LESSEQUAL = 29\nGREATEREQUAL = 30\nTILDE = 31\nCIRCUMFLEX = 32\nLEFTSHIFT = 33\nRIGHTSHIFT = 34\nDOUBLESTAR = 35\nPLUSEQUAL = 36\nMINEQUAL = 37\nSTAREQUAL = 38",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "GREATEREQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "GREATEREQUAL = 30\nTILDE = 31\nCIRCUMFLEX = 32\nLEFTSHIFT = 33\nRIGHTSHIFT = 34\nDOUBLESTAR = 35\nPLUSEQUAL = 36\nMINEQUAL = 37\nSTAREQUAL = 38\nSLASHEQUAL = 39",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "TILDE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "TILDE = 31\nCIRCUMFLEX = 32\nLEFTSHIFT = 33\nRIGHTSHIFT = 34\nDOUBLESTAR = 35\nPLUSEQUAL = 36\nMINEQUAL = 37\nSTAREQUAL = 38\nSLASHEQUAL = 39\nPERCENTEQUAL = 40",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "CIRCUMFLEX",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "CIRCUMFLEX = 32\nLEFTSHIFT = 33\nRIGHTSHIFT = 34\nDOUBLESTAR = 35\nPLUSEQUAL = 36\nMINEQUAL = 37\nSTAREQUAL = 38\nSLASHEQUAL = 39\nPERCENTEQUAL = 40\nAMPEREQUAL = 41",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "LEFTSHIFT",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "LEFTSHIFT = 33\nRIGHTSHIFT = 34\nDOUBLESTAR = 35\nPLUSEQUAL = 36\nMINEQUAL = 37\nSTAREQUAL = 38\nSLASHEQUAL = 39\nPERCENTEQUAL = 40\nAMPEREQUAL = 41\nVBAREQUAL = 42",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "RIGHTSHIFT",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "RIGHTSHIFT = 34\nDOUBLESTAR = 35\nPLUSEQUAL = 36\nMINEQUAL = 37\nSTAREQUAL = 38\nSLASHEQUAL = 39\nPERCENTEQUAL = 40\nAMPEREQUAL = 41\nVBAREQUAL = 42\nCIRCUMFLEXEQUAL = 43",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "DOUBLESTAR",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "DOUBLESTAR = 35\nPLUSEQUAL = 36\nMINEQUAL = 37\nSTAREQUAL = 38\nSLASHEQUAL = 39\nPERCENTEQUAL = 40\nAMPEREQUAL = 41\nVBAREQUAL = 42\nCIRCUMFLEXEQUAL = 43\nLEFTSHIFTEQUAL = 44",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "PLUSEQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "PLUSEQUAL = 36\nMINEQUAL = 37\nSTAREQUAL = 38\nSLASHEQUAL = 39\nPERCENTEQUAL = 40\nAMPEREQUAL = 41\nVBAREQUAL = 42\nCIRCUMFLEXEQUAL = 43\nLEFTSHIFTEQUAL = 44\nRIGHTSHIFTEQUAL = 45",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "MINEQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "MINEQUAL = 37\nSTAREQUAL = 38\nSLASHEQUAL = 39\nPERCENTEQUAL = 40\nAMPEREQUAL = 41\nVBAREQUAL = 42\nCIRCUMFLEXEQUAL = 43\nLEFTSHIFTEQUAL = 44\nRIGHTSHIFTEQUAL = 45\nDOUBLESTAREQUAL = 46",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "STAREQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "STAREQUAL = 38\nSLASHEQUAL = 39\nPERCENTEQUAL = 40\nAMPEREQUAL = 41\nVBAREQUAL = 42\nCIRCUMFLEXEQUAL = 43\nLEFTSHIFTEQUAL = 44\nRIGHTSHIFTEQUAL = 45\nDOUBLESTAREQUAL = 46\nDOUBLESLASH = 47",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "SLASHEQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "SLASHEQUAL = 39\nPERCENTEQUAL = 40\nAMPEREQUAL = 41\nVBAREQUAL = 42\nCIRCUMFLEXEQUAL = 43\nLEFTSHIFTEQUAL = 44\nRIGHTSHIFTEQUAL = 45\nDOUBLESTAREQUAL = 46\nDOUBLESLASH = 47\nDOUBLESLASHEQUAL = 48",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "PERCENTEQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "PERCENTEQUAL = 40\nAMPEREQUAL = 41\nVBAREQUAL = 42\nCIRCUMFLEXEQUAL = 43\nLEFTSHIFTEQUAL = 44\nRIGHTSHIFTEQUAL = 45\nDOUBLESTAREQUAL = 46\nDOUBLESLASH = 47\nDOUBLESLASHEQUAL = 48\nAT = 49",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "AMPEREQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "AMPEREQUAL = 41\nVBAREQUAL = 42\nCIRCUMFLEXEQUAL = 43\nLEFTSHIFTEQUAL = 44\nRIGHTSHIFTEQUAL = 45\nDOUBLESTAREQUAL = 46\nDOUBLESLASH = 47\nDOUBLESLASHEQUAL = 48\nAT = 49\nATEQUAL = 50",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "VBAREQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "VBAREQUAL = 42\nCIRCUMFLEXEQUAL = 43\nLEFTSHIFTEQUAL = 44\nRIGHTSHIFTEQUAL = 45\nDOUBLESTAREQUAL = 46\nDOUBLESLASH = 47\nDOUBLESLASHEQUAL = 48\nAT = 49\nATEQUAL = 50\nRARROW = 51",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "CIRCUMFLEXEQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "CIRCUMFLEXEQUAL = 43\nLEFTSHIFTEQUAL = 44\nRIGHTSHIFTEQUAL = 45\nDOUBLESTAREQUAL = 46\nDOUBLESLASH = 47\nDOUBLESLASHEQUAL = 48\nAT = 49\nATEQUAL = 50\nRARROW = 51\nELLIPSIS = 52",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "LEFTSHIFTEQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "LEFTSHIFTEQUAL = 44\nRIGHTSHIFTEQUAL = 45\nDOUBLESTAREQUAL = 46\nDOUBLESLASH = 47\nDOUBLESLASHEQUAL = 48\nAT = 49\nATEQUAL = 50\nRARROW = 51\nELLIPSIS = 52\nCOLONEQUAL = 53",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "RIGHTSHIFTEQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "RIGHTSHIFTEQUAL = 45\nDOUBLESTAREQUAL = 46\nDOUBLESLASH = 47\nDOUBLESLASHEQUAL = 48\nAT = 49\nATEQUAL = 50\nRARROW = 51\nELLIPSIS = 52\nCOLONEQUAL = 53\nEXCLAMATION = 54",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "DOUBLESTAREQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "DOUBLESTAREQUAL = 46\nDOUBLESLASH = 47\nDOUBLESLASHEQUAL = 48\nAT = 49\nATEQUAL = 50\nRARROW = 51\nELLIPSIS = 52\nCOLONEQUAL = 53\nEXCLAMATION = 54\nOP = 55",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "DOUBLESLASH",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "DOUBLESLASH = 47\nDOUBLESLASHEQUAL = 48\nAT = 49\nATEQUAL = 50\nRARROW = 51\nELLIPSIS = 52\nCOLONEQUAL = 53\nEXCLAMATION = 54\nOP = 55\nTYPE_IGNORE = 56",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "DOUBLESLASHEQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "DOUBLESLASHEQUAL = 48\nAT = 49\nATEQUAL = 50\nRARROW = 51\nELLIPSIS = 52\nCOLONEQUAL = 53\nEXCLAMATION = 54\nOP = 55\nTYPE_IGNORE = 56\nTYPE_COMMENT = 57",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "AT",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "AT = 49\nATEQUAL = 50\nRARROW = 51\nELLIPSIS = 52\nCOLONEQUAL = 53\nEXCLAMATION = 54\nOP = 55\nTYPE_IGNORE = 56\nTYPE_COMMENT = 57\nSOFT_KEYWORD = 58",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "ATEQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "ATEQUAL = 50\nRARROW = 51\nELLIPSIS = 52\nCOLONEQUAL = 53\nEXCLAMATION = 54\nOP = 55\nTYPE_IGNORE = 56\nTYPE_COMMENT = 57\nSOFT_KEYWORD = 58\nFSTRING_START = 59",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "RARROW",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "RARROW = 51\nELLIPSIS = 52\nCOLONEQUAL = 53\nEXCLAMATION = 54\nOP = 55\nTYPE_IGNORE = 56\nTYPE_COMMENT = 57\nSOFT_KEYWORD = 58\nFSTRING_START = 59\nFSTRING_MIDDLE = 60",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "ELLIPSIS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "ELLIPSIS = 52\nCOLONEQUAL = 53\nEXCLAMATION = 54\nOP = 55\nTYPE_IGNORE = 56\nTYPE_COMMENT = 57\nSOFT_KEYWORD = 58\nFSTRING_START = 59\nFSTRING_MIDDLE = 60\nFSTRING_END = 61",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "COLONEQUAL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "COLONEQUAL = 53\nEXCLAMATION = 54\nOP = 55\nTYPE_IGNORE = 56\nTYPE_COMMENT = 57\nSOFT_KEYWORD = 58\nFSTRING_START = 59\nFSTRING_MIDDLE = 60\nFSTRING_END = 61\nCOMMENT = 62",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "EXCLAMATION",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "EXCLAMATION = 54\nOP = 55\nTYPE_IGNORE = 56\nTYPE_COMMENT = 57\nSOFT_KEYWORD = 58\nFSTRING_START = 59\nFSTRING_MIDDLE = 60\nFSTRING_END = 61\nCOMMENT = 62\nNL = 63",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "OP",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "OP = 55\nTYPE_IGNORE = 56\nTYPE_COMMENT = 57\nSOFT_KEYWORD = 58\nFSTRING_START = 59\nFSTRING_MIDDLE = 60\nFSTRING_END = 61\nCOMMENT = 62\nNL = 63\n# These aren't used by the C tokenizer but are needed for tokenize.py",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "TYPE_IGNORE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "TYPE_IGNORE = 56\nTYPE_COMMENT = 57\nSOFT_KEYWORD = 58\nFSTRING_START = 59\nFSTRING_MIDDLE = 60\nFSTRING_END = 61\nCOMMENT = 62\nNL = 63\n# These aren't used by the C tokenizer but are needed for tokenize.py\nERRORTOKEN = 64",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "TYPE_COMMENT",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "TYPE_COMMENT = 57\nSOFT_KEYWORD = 58\nFSTRING_START = 59\nFSTRING_MIDDLE = 60\nFSTRING_END = 61\nCOMMENT = 62\nNL = 63\n# These aren't used by the C tokenizer but are needed for tokenize.py\nERRORTOKEN = 64\nENCODING = 65",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "SOFT_KEYWORD",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "SOFT_KEYWORD = 58\nFSTRING_START = 59\nFSTRING_MIDDLE = 60\nFSTRING_END = 61\nCOMMENT = 62\nNL = 63\n# These aren't used by the C tokenizer but are needed for tokenize.py\nERRORTOKEN = 64\nENCODING = 65\nN_TOKENS = 66",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "FSTRING_START",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "FSTRING_START = 59\nFSTRING_MIDDLE = 60\nFSTRING_END = 61\nCOMMENT = 62\nNL = 63\n# These aren't used by the C tokenizer but are needed for tokenize.py\nERRORTOKEN = 64\nENCODING = 65\nN_TOKENS = 66\n# Special definitions for cooperation with parser",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "FSTRING_MIDDLE",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "FSTRING_MIDDLE = 60\nFSTRING_END = 61\nCOMMENT = 62\nNL = 63\n# These aren't used by the C tokenizer but are needed for tokenize.py\nERRORTOKEN = 64\nENCODING = 65\nN_TOKENS = 66\n# Special definitions for cooperation with parser\nNT_OFFSET = 256",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "FSTRING_END",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "FSTRING_END = 61\nCOMMENT = 62\nNL = 63\n# These aren't used by the C tokenizer but are needed for tokenize.py\nERRORTOKEN = 64\nENCODING = 65\nN_TOKENS = 66\n# Special definitions for cooperation with parser\nNT_OFFSET = 256\ntok_name = {value: name",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "COMMENT",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "COMMENT = 62\nNL = 63\n# These aren't used by the C tokenizer but are needed for tokenize.py\nERRORTOKEN = 64\nENCODING = 65\nN_TOKENS = 66\n# Special definitions for cooperation with parser\nNT_OFFSET = 256\ntok_name = {value: name\n            for name, value in globals().items()",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "NL",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "NL = 63\n# These aren't used by the C tokenizer but are needed for tokenize.py\nERRORTOKEN = 64\nENCODING = 65\nN_TOKENS = 66\n# Special definitions for cooperation with parser\nNT_OFFSET = 256\ntok_name = {value: name\n            for name, value in globals().items()\n            if isinstance(value, int) and not name.startswith('_')}",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "ERRORTOKEN",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "ERRORTOKEN = 64\nENCODING = 65\nN_TOKENS = 66\n# Special definitions for cooperation with parser\nNT_OFFSET = 256\ntok_name = {value: name\n            for name, value in globals().items()\n            if isinstance(value, int) and not name.startswith('_')}\n__all__.extend(tok_name.values())\nEXACT_TOKEN_TYPES = {",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "ENCODING",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "ENCODING = 65\nN_TOKENS = 66\n# Special definitions for cooperation with parser\nNT_OFFSET = 256\ntok_name = {value: name\n            for name, value in globals().items()\n            if isinstance(value, int) and not name.startswith('_')}\n__all__.extend(tok_name.values())\nEXACT_TOKEN_TYPES = {\n    '!': EXCLAMATION,",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "N_TOKENS",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "N_TOKENS = 66\n# Special definitions for cooperation with parser\nNT_OFFSET = 256\ntok_name = {value: name\n            for name, value in globals().items()\n            if isinstance(value, int) and not name.startswith('_')}\n__all__.extend(tok_name.values())\nEXACT_TOKEN_TYPES = {\n    '!': EXCLAMATION,\n    '!=': NOTEQUAL,",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "NT_OFFSET",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "NT_OFFSET = 256\ntok_name = {value: name\n            for name, value in globals().items()\n            if isinstance(value, int) and not name.startswith('_')}\n__all__.extend(tok_name.values())\nEXACT_TOKEN_TYPES = {\n    '!': EXCLAMATION,\n    '!=': NOTEQUAL,\n    '%': PERCENT,\n    '%=': PERCENTEQUAL,",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "tok_name",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "tok_name = {value: name\n            for name, value in globals().items()\n            if isinstance(value, int) and not name.startswith('_')}\n__all__.extend(tok_name.values())\nEXACT_TOKEN_TYPES = {\n    '!': EXCLAMATION,\n    '!=': NOTEQUAL,\n    '%': PERCENT,\n    '%=': PERCENTEQUAL,\n    '&': AMPER,",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "EXACT_TOKEN_TYPES",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.token",
        "description": "pycharm_venv.Lib.token",
        "peekOfCode": "EXACT_TOKEN_TYPES = {\n    '!': EXCLAMATION,\n    '!=': NOTEQUAL,\n    '%': PERCENT,\n    '%=': PERCENTEQUAL,\n    '&': AMPER,\n    '&=': AMPEREQUAL,\n    '(': LPAR,\n    ')': RPAR,\n    '*': STAR,",
        "detail": "pycharm_venv.Lib.token",
        "documentation": {}
    },
    {
        "label": "TokenInfo",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "class TokenInfo(collections.namedtuple('TokenInfo', 'type string start end line')):\n    def __repr__(self):\n        annotated_type = '%d (%s)' % (self.type, tok_name[self.type])\n        return ('TokenInfo(type=%s, string=%r, start=%r, end=%r, line=%r)' %\n                self._replace(type=annotated_type))\n    @property\n    def exact_type(self):\n        if self.type == OP and self.string in EXACT_TOKEN_TYPES:\n            return EXACT_TOKEN_TYPES[self.string]\n        else:",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "TokenError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "class TokenError(Exception): pass\nclass Untokenizer:\n    def __init__(self):\n        self.tokens = []\n        self.prev_row = 1\n        self.prev_col = 0\n        self.prev_type = None\n        self.encoding = None\n    def add_whitespace(self, start):\n        row, col = start",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Untokenizer",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "class Untokenizer:\n    def __init__(self):\n        self.tokens = []\n        self.prev_row = 1\n        self.prev_col = 0\n        self.prev_type = None\n        self.encoding = None\n    def add_whitespace(self, start):\n        row, col = start\n        if row < self.prev_row or row == self.prev_row and col < self.prev_col:",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "group",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "def group(*choices): return '(' + '|'.join(choices) + ')'\ndef any(*choices): return group(*choices) + '*'\ndef maybe(*choices): return group(*choices) + '?'\n# Note: we use unicode matching for names (\"\\w\") but ascii matching for\n# number literals.\nWhitespace = r'[ \\f\\t]*'\nComment = r'#[^\\r\\n]*'\nIgnore = Whitespace + any(r'\\\\\\r?\\n' + Whitespace) + maybe(Comment)\nName = r'\\w+'\nHexnumber = r'0[xX](?:_?[0-9a-fA-F])+'",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "any",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "def any(*choices): return group(*choices) + '*'\ndef maybe(*choices): return group(*choices) + '?'\n# Note: we use unicode matching for names (\"\\w\") but ascii matching for\n# number literals.\nWhitespace = r'[ \\f\\t]*'\nComment = r'#[^\\r\\n]*'\nIgnore = Whitespace + any(r'\\\\\\r?\\n' + Whitespace) + maybe(Comment)\nName = r'\\w+'\nHexnumber = r'0[xX](?:_?[0-9a-fA-F])+'\nBinnumber = r'0[bB](?:_?[01])+'",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "maybe",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "def maybe(*choices): return group(*choices) + '?'\n# Note: we use unicode matching for names (\"\\w\") but ascii matching for\n# number literals.\nWhitespace = r'[ \\f\\t]*'\nComment = r'#[^\\r\\n]*'\nIgnore = Whitespace + any(r'\\\\\\r?\\n' + Whitespace) + maybe(Comment)\nName = r'\\w+'\nHexnumber = r'0[xX](?:_?[0-9a-fA-F])+'\nBinnumber = r'0[bB](?:_?[01])+'\nOctnumber = r'0[oO](?:_?[0-7])+'",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "untokenize",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "def untokenize(iterable):\n    \"\"\"Transform tokens back into Python source code.\n    It returns a bytes object, encoded using the ENCODING\n    token, which is the first token sequence output by tokenize.\n    Each element returned by the iterable must be a token sequence\n    with at least two elements, a token number and token value.  If\n    only two tokens are passed, the resulting output is poor.\n    Round-trip invariant for full input:\n        Untokenized source will match input source exactly\n    Round-trip invariant for limited input:",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "detect_encoding",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "def detect_encoding(readline):\n    \"\"\"\n    The detect_encoding() function is used to detect the encoding that should\n    be used to decode a Python source file.  It requires one argument, readline,\n    in the same way as the tokenize() generator.\n    It will call readline a maximum of twice, and return the encoding used\n    (as a string) and a list of any lines (left as bytes) it has read in.\n    It detects the encoding from the presence of a utf-8 bom or an encoding\n    cookie as specified in pep-0263.  If both a bom and a cookie are present,\n    but disagree, a SyntaxError will be raised.  If the encoding cookie is an",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "open",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "def open(filename):\n    \"\"\"Open a file in read only mode using the encoding detected by\n    detect_encoding().\n    \"\"\"\n    buffer = _builtin_open(filename, 'rb')\n    try:\n        encoding, lines = detect_encoding(buffer.readline)\n        buffer.seek(0)\n        text = TextIOWrapper(buffer, encoding, line_buffering=True)\n        text.mode = 'r'",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "tokenize",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "def tokenize(readline):\n    \"\"\"\n    The tokenize() generator requires one argument, readline, which\n    must be a callable object which provides the same interface as the\n    readline() method of built-in file objects.  Each call to the function\n    should return one line of input as bytes.  Alternatively, readline\n    can be a callable function terminating with StopIteration:\n        readline = open(myfile, 'rb').__next__  # Example of alternate readline\n    The generator produces 5-tuples with these members: the token type; the\n    token string; a 2-tuple (srow, scol) of ints specifying the row and",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "generate_tokens",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "def generate_tokens(readline):\n    \"\"\"Tokenize a source reading Python code as unicode strings.\n    This has the same API as tokenize(), except that it expects the *readline*\n    callable to return str objects instead of bytes.\n    \"\"\"\n    return _generate_tokens_from_c_tokenizer(readline, extra_tokens=True)\ndef main():\n    import argparse\n    # Helper error handling routines\n    def perror(message):",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "def main():\n    import argparse\n    # Helper error handling routines\n    def perror(message):\n        sys.stderr.write(message)\n        sys.stderr.write('\\n')\n    def error(message, filename=None, location=None):\n        if location:\n            args = (filename,) + location + (message,)\n            perror(\"%s:%d:%d: error: %s\" % args)",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "__author__ = 'Ka-Ping Yee <ping@lfw.org>'\n__credits__ = ('GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, '\n               'Skip Montanaro, Raymond Hettinger, Trent Nelson, '\n               'Michael Foord')\nfrom builtins import open as _builtin_open\nfrom codecs import lookup, BOM_UTF8\nimport collections\nimport functools\nfrom io import TextIOWrapper\nimport itertools as _itertools",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "__credits__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "__credits__ = ('GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, '\n               'Skip Montanaro, Raymond Hettinger, Trent Nelson, '\n               'Michael Foord')\nfrom builtins import open as _builtin_open\nfrom codecs import lookup, BOM_UTF8\nimport collections\nimport functools\nfrom io import TextIOWrapper\nimport itertools as _itertools\nimport re",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "cookie_re",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "cookie_re = re.compile(r'^[ \\t\\f]*#.*?coding[:=][ \\t]*([-\\w.]+)', re.ASCII)\nblank_re = re.compile(br'^[ \\t\\f]*(?:[#\\r\\n]|$)', re.ASCII)\nimport token\n__all__ = token.__all__ + [\"tokenize\", \"generate_tokens\", \"detect_encoding\",\n                           \"untokenize\", \"TokenInfo\", \"open\", \"TokenError\"]\ndel token\nclass TokenInfo(collections.namedtuple('TokenInfo', 'type string start end line')):\n    def __repr__(self):\n        annotated_type = '%d (%s)' % (self.type, tok_name[self.type])\n        return ('TokenInfo(type=%s, string=%r, start=%r, end=%r, line=%r)' %",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "blank_re",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "blank_re = re.compile(br'^[ \\t\\f]*(?:[#\\r\\n]|$)', re.ASCII)\nimport token\n__all__ = token.__all__ + [\"tokenize\", \"generate_tokens\", \"detect_encoding\",\n                           \"untokenize\", \"TokenInfo\", \"open\", \"TokenError\"]\ndel token\nclass TokenInfo(collections.namedtuple('TokenInfo', 'type string start end line')):\n    def __repr__(self):\n        annotated_type = '%d (%s)' % (self.type, tok_name[self.type])\n        return ('TokenInfo(type=%s, string=%r, start=%r, end=%r, line=%r)' %\n                self._replace(type=annotated_type))",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "__all__ = token.__all__ + [\"tokenize\", \"generate_tokens\", \"detect_encoding\",\n                           \"untokenize\", \"TokenInfo\", \"open\", \"TokenError\"]\ndel token\nclass TokenInfo(collections.namedtuple('TokenInfo', 'type string start end line')):\n    def __repr__(self):\n        annotated_type = '%d (%s)' % (self.type, tok_name[self.type])\n        return ('TokenInfo(type=%s, string=%r, start=%r, end=%r, line=%r)' %\n                self._replace(type=annotated_type))\n    @property\n    def exact_type(self):",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Whitespace",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Whitespace = r'[ \\f\\t]*'\nComment = r'#[^\\r\\n]*'\nIgnore = Whitespace + any(r'\\\\\\r?\\n' + Whitespace) + maybe(Comment)\nName = r'\\w+'\nHexnumber = r'0[xX](?:_?[0-9a-fA-F])+'\nBinnumber = r'0[bB](?:_?[01])+'\nOctnumber = r'0[oO](?:_?[0-7])+'\nDecnumber = r'(?:0(?:_?0)*|[1-9](?:_?[0-9])*)'\nIntnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber)\nExponent = r'[eE][-+]?[0-9](?:_?[0-9])*'",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Comment",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Comment = r'#[^\\r\\n]*'\nIgnore = Whitespace + any(r'\\\\\\r?\\n' + Whitespace) + maybe(Comment)\nName = r'\\w+'\nHexnumber = r'0[xX](?:_?[0-9a-fA-F])+'\nBinnumber = r'0[bB](?:_?[01])+'\nOctnumber = r'0[oO](?:_?[0-7])+'\nDecnumber = r'(?:0(?:_?0)*|[1-9](?:_?[0-9])*)'\nIntnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber)\nExponent = r'[eE][-+]?[0-9](?:_?[0-9])*'\nPointfloat = group(r'[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?',",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Ignore",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Ignore = Whitespace + any(r'\\\\\\r?\\n' + Whitespace) + maybe(Comment)\nName = r'\\w+'\nHexnumber = r'0[xX](?:_?[0-9a-fA-F])+'\nBinnumber = r'0[bB](?:_?[01])+'\nOctnumber = r'0[oO](?:_?[0-7])+'\nDecnumber = r'(?:0(?:_?0)*|[1-9](?:_?[0-9])*)'\nIntnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber)\nExponent = r'[eE][-+]?[0-9](?:_?[0-9])*'\nPointfloat = group(r'[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?',\n                   r'\\.[0-9](?:_?[0-9])*') + maybe(Exponent)",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Name",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Name = r'\\w+'\nHexnumber = r'0[xX](?:_?[0-9a-fA-F])+'\nBinnumber = r'0[bB](?:_?[01])+'\nOctnumber = r'0[oO](?:_?[0-7])+'\nDecnumber = r'(?:0(?:_?0)*|[1-9](?:_?[0-9])*)'\nIntnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber)\nExponent = r'[eE][-+]?[0-9](?:_?[0-9])*'\nPointfloat = group(r'[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?',\n                   r'\\.[0-9](?:_?[0-9])*') + maybe(Exponent)\nExpfloat = r'[0-9](?:_?[0-9])*' + Exponent",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Hexnumber",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Hexnumber = r'0[xX](?:_?[0-9a-fA-F])+'\nBinnumber = r'0[bB](?:_?[01])+'\nOctnumber = r'0[oO](?:_?[0-7])+'\nDecnumber = r'(?:0(?:_?0)*|[1-9](?:_?[0-9])*)'\nIntnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber)\nExponent = r'[eE][-+]?[0-9](?:_?[0-9])*'\nPointfloat = group(r'[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?',\n                   r'\\.[0-9](?:_?[0-9])*') + maybe(Exponent)\nExpfloat = r'[0-9](?:_?[0-9])*' + Exponent\nFloatnumber = group(Pointfloat, Expfloat)",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Binnumber",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Binnumber = r'0[bB](?:_?[01])+'\nOctnumber = r'0[oO](?:_?[0-7])+'\nDecnumber = r'(?:0(?:_?0)*|[1-9](?:_?[0-9])*)'\nIntnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber)\nExponent = r'[eE][-+]?[0-9](?:_?[0-9])*'\nPointfloat = group(r'[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?',\n                   r'\\.[0-9](?:_?[0-9])*') + maybe(Exponent)\nExpfloat = r'[0-9](?:_?[0-9])*' + Exponent\nFloatnumber = group(Pointfloat, Expfloat)\nImagnumber = group(r'[0-9](?:_?[0-9])*[jJ]', Floatnumber + r'[jJ]')",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Octnumber",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Octnumber = r'0[oO](?:_?[0-7])+'\nDecnumber = r'(?:0(?:_?0)*|[1-9](?:_?[0-9])*)'\nIntnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber)\nExponent = r'[eE][-+]?[0-9](?:_?[0-9])*'\nPointfloat = group(r'[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?',\n                   r'\\.[0-9](?:_?[0-9])*') + maybe(Exponent)\nExpfloat = r'[0-9](?:_?[0-9])*' + Exponent\nFloatnumber = group(Pointfloat, Expfloat)\nImagnumber = group(r'[0-9](?:_?[0-9])*[jJ]', Floatnumber + r'[jJ]')\nNumber = group(Imagnumber, Floatnumber, Intnumber)",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Decnumber",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Decnumber = r'(?:0(?:_?0)*|[1-9](?:_?[0-9])*)'\nIntnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber)\nExponent = r'[eE][-+]?[0-9](?:_?[0-9])*'\nPointfloat = group(r'[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?',\n                   r'\\.[0-9](?:_?[0-9])*') + maybe(Exponent)\nExpfloat = r'[0-9](?:_?[0-9])*' + Exponent\nFloatnumber = group(Pointfloat, Expfloat)\nImagnumber = group(r'[0-9](?:_?[0-9])*[jJ]', Floatnumber + r'[jJ]')\nNumber = group(Imagnumber, Floatnumber, Intnumber)\n# Return the empty string, plus all of the valid string prefixes.",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Intnumber",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Intnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber)\nExponent = r'[eE][-+]?[0-9](?:_?[0-9])*'\nPointfloat = group(r'[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?',\n                   r'\\.[0-9](?:_?[0-9])*') + maybe(Exponent)\nExpfloat = r'[0-9](?:_?[0-9])*' + Exponent\nFloatnumber = group(Pointfloat, Expfloat)\nImagnumber = group(r'[0-9](?:_?[0-9])*[jJ]', Floatnumber + r'[jJ]')\nNumber = group(Imagnumber, Floatnumber, Intnumber)\n# Return the empty string, plus all of the valid string prefixes.\ndef _all_string_prefixes():",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Exponent",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Exponent = r'[eE][-+]?[0-9](?:_?[0-9])*'\nPointfloat = group(r'[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?',\n                   r'\\.[0-9](?:_?[0-9])*') + maybe(Exponent)\nExpfloat = r'[0-9](?:_?[0-9])*' + Exponent\nFloatnumber = group(Pointfloat, Expfloat)\nImagnumber = group(r'[0-9](?:_?[0-9])*[jJ]', Floatnumber + r'[jJ]')\nNumber = group(Imagnumber, Floatnumber, Intnumber)\n# Return the empty string, plus all of the valid string prefixes.\ndef _all_string_prefixes():\n    # The valid string prefixes. Only contain the lower case versions,",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Pointfloat",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Pointfloat = group(r'[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?',\n                   r'\\.[0-9](?:_?[0-9])*') + maybe(Exponent)\nExpfloat = r'[0-9](?:_?[0-9])*' + Exponent\nFloatnumber = group(Pointfloat, Expfloat)\nImagnumber = group(r'[0-9](?:_?[0-9])*[jJ]', Floatnumber + r'[jJ]')\nNumber = group(Imagnumber, Floatnumber, Intnumber)\n# Return the empty string, plus all of the valid string prefixes.\ndef _all_string_prefixes():\n    # The valid string prefixes. Only contain the lower case versions,\n    #  and don't contain any permutations (include 'fr', but not",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Expfloat",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Expfloat = r'[0-9](?:_?[0-9])*' + Exponent\nFloatnumber = group(Pointfloat, Expfloat)\nImagnumber = group(r'[0-9](?:_?[0-9])*[jJ]', Floatnumber + r'[jJ]')\nNumber = group(Imagnumber, Floatnumber, Intnumber)\n# Return the empty string, plus all of the valid string prefixes.\ndef _all_string_prefixes():\n    # The valid string prefixes. Only contain the lower case versions,\n    #  and don't contain any permutations (include 'fr', but not\n    #  'rf'). The various permutations will be generated.\n    _valid_string_prefixes = ['b', 'r', 'u', 'f', 'br', 'fr']",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Floatnumber",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Floatnumber = group(Pointfloat, Expfloat)\nImagnumber = group(r'[0-9](?:_?[0-9])*[jJ]', Floatnumber + r'[jJ]')\nNumber = group(Imagnumber, Floatnumber, Intnumber)\n# Return the empty string, plus all of the valid string prefixes.\ndef _all_string_prefixes():\n    # The valid string prefixes. Only contain the lower case versions,\n    #  and don't contain any permutations (include 'fr', but not\n    #  'rf'). The various permutations will be generated.\n    _valid_string_prefixes = ['b', 'r', 'u', 'f', 'br', 'fr']\n    # if we add binary f-strings, add: ['fb', 'fbr']",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Imagnumber",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Imagnumber = group(r'[0-9](?:_?[0-9])*[jJ]', Floatnumber + r'[jJ]')\nNumber = group(Imagnumber, Floatnumber, Intnumber)\n# Return the empty string, plus all of the valid string prefixes.\ndef _all_string_prefixes():\n    # The valid string prefixes. Only contain the lower case versions,\n    #  and don't contain any permutations (include 'fr', but not\n    #  'rf'). The various permutations will be generated.\n    _valid_string_prefixes = ['b', 'r', 'u', 'f', 'br', 'fr']\n    # if we add binary f-strings, add: ['fb', 'fbr']\n    result = {''}",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Number",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Number = group(Imagnumber, Floatnumber, Intnumber)\n# Return the empty string, plus all of the valid string prefixes.\ndef _all_string_prefixes():\n    # The valid string prefixes. Only contain the lower case versions,\n    #  and don't contain any permutations (include 'fr', but not\n    #  'rf'). The various permutations will be generated.\n    _valid_string_prefixes = ['b', 'r', 'u', 'f', 'br', 'fr']\n    # if we add binary f-strings, add: ['fb', 'fbr']\n    result = {''}\n    for prefix in _valid_string_prefixes:",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "StringPrefix",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "StringPrefix = group(*_all_string_prefixes())\n# Tail end of ' string.\nSingle = r\"[^'\\\\]*(?:\\\\.[^'\\\\]*)*'\"\n# Tail end of \" string.\nDouble = r'[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"'\n# Tail end of ''' string.\nSingle3 = r\"[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''\"\n# Tail end of \"\"\" string.\nDouble3 = r'[^\"\\\\]*(?:(?:\\\\.|\"(?!\"\"))[^\"\\\\]*)*\"\"\"'\nTriple = group(StringPrefix + \"'''\", StringPrefix + '\"\"\"')",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Single",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Single = r\"[^'\\\\]*(?:\\\\.[^'\\\\]*)*'\"\n# Tail end of \" string.\nDouble = r'[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"'\n# Tail end of ''' string.\nSingle3 = r\"[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''\"\n# Tail end of \"\"\" string.\nDouble3 = r'[^\"\\\\]*(?:(?:\\\\.|\"(?!\"\"))[^\"\\\\]*)*\"\"\"'\nTriple = group(StringPrefix + \"'''\", StringPrefix + '\"\"\"')\n# Single-line ' or \" string.\nString = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'\",",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Double",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Double = r'[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"'\n# Tail end of ''' string.\nSingle3 = r\"[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''\"\n# Tail end of \"\"\" string.\nDouble3 = r'[^\"\\\\]*(?:(?:\\\\.|\"(?!\"\"))[^\"\\\\]*)*\"\"\"'\nTriple = group(StringPrefix + \"'''\", StringPrefix + '\"\"\"')\n# Single-line ' or \" string.\nString = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'\",\n               StringPrefix + r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*\"')\n# Sorting in reverse order puts the long operators before their prefixes.",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Single3",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Single3 = r\"[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''\"\n# Tail end of \"\"\" string.\nDouble3 = r'[^\"\\\\]*(?:(?:\\\\.|\"(?!\"\"))[^\"\\\\]*)*\"\"\"'\nTriple = group(StringPrefix + \"'''\", StringPrefix + '\"\"\"')\n# Single-line ' or \" string.\nString = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'\",\n               StringPrefix + r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*\"')\n# Sorting in reverse order puts the long operators before their prefixes.\n# Otherwise if = came before ==, == would get recognized as two instances\n# of =.",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Double3",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Double3 = r'[^\"\\\\]*(?:(?:\\\\.|\"(?!\"\"))[^\"\\\\]*)*\"\"\"'\nTriple = group(StringPrefix + \"'''\", StringPrefix + '\"\"\"')\n# Single-line ' or \" string.\nString = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'\",\n               StringPrefix + r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*\"')\n# Sorting in reverse order puts the long operators before their prefixes.\n# Otherwise if = came before ==, == would get recognized as two instances\n# of =.\nSpecial = group(*map(re.escape, sorted(EXACT_TOKEN_TYPES, reverse=True)))\nFunny = group(r'\\r?\\n', Special)",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Triple",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Triple = group(StringPrefix + \"'''\", StringPrefix + '\"\"\"')\n# Single-line ' or \" string.\nString = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'\",\n               StringPrefix + r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*\"')\n# Sorting in reverse order puts the long operators before their prefixes.\n# Otherwise if = came before ==, == would get recognized as two instances\n# of =.\nSpecial = group(*map(re.escape, sorted(EXACT_TOKEN_TYPES, reverse=True)))\nFunny = group(r'\\r?\\n', Special)\nPlainToken = group(Number, Funny, String, Name)",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "String",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "String = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'\",\n               StringPrefix + r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*\"')\n# Sorting in reverse order puts the long operators before their prefixes.\n# Otherwise if = came before ==, == would get recognized as two instances\n# of =.\nSpecial = group(*map(re.escape, sorted(EXACT_TOKEN_TYPES, reverse=True)))\nFunny = group(r'\\r?\\n', Special)\nPlainToken = group(Number, Funny, String, Name)\nToken = Ignore + PlainToken\n# First (or only) line of ' or \" string.",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Special",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Special = group(*map(re.escape, sorted(EXACT_TOKEN_TYPES, reverse=True)))\nFunny = group(r'\\r?\\n', Special)\nPlainToken = group(Number, Funny, String, Name)\nToken = Ignore + PlainToken\n# First (or only) line of ' or \" string.\nContStr = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*\" +\n                group(\"'\", r'\\\\\\r?\\n'),\n                StringPrefix + r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*' +\n                group('\"', r'\\\\\\r?\\n'))\nPseudoExtras = group(r'\\\\\\r?\\n|\\Z', Comment, Triple)",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Funny",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Funny = group(r'\\r?\\n', Special)\nPlainToken = group(Number, Funny, String, Name)\nToken = Ignore + PlainToken\n# First (or only) line of ' or \" string.\nContStr = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*\" +\n                group(\"'\", r'\\\\\\r?\\n'),\n                StringPrefix + r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*' +\n                group('\"', r'\\\\\\r?\\n'))\nPseudoExtras = group(r'\\\\\\r?\\n|\\Z', Comment, Triple)\nPseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "PlainToken",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "PlainToken = group(Number, Funny, String, Name)\nToken = Ignore + PlainToken\n# First (or only) line of ' or \" string.\nContStr = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*\" +\n                group(\"'\", r'\\\\\\r?\\n'),\n                StringPrefix + r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*' +\n                group('\"', r'\\\\\\r?\\n'))\nPseudoExtras = group(r'\\\\\\r?\\n|\\Z', Comment, Triple)\nPseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)\n# For a given string prefix plus quotes, endpats maps it to a regex",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "Token",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "Token = Ignore + PlainToken\n# First (or only) line of ' or \" string.\nContStr = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*\" +\n                group(\"'\", r'\\\\\\r?\\n'),\n                StringPrefix + r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*' +\n                group('\"', r'\\\\\\r?\\n'))\nPseudoExtras = group(r'\\\\\\r?\\n|\\Z', Comment, Triple)\nPseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)\n# For a given string prefix plus quotes, endpats maps it to a regex\n#  to match the remainder of that string. _prefix can be empty, for",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "ContStr",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "ContStr = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*\" +\n                group(\"'\", r'\\\\\\r?\\n'),\n                StringPrefix + r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*' +\n                group('\"', r'\\\\\\r?\\n'))\nPseudoExtras = group(r'\\\\\\r?\\n|\\Z', Comment, Triple)\nPseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)\n# For a given string prefix plus quotes, endpats maps it to a regex\n#  to match the remainder of that string. _prefix can be empty, for\n#  a normal single or triple quoted string (with no prefix).\nendpats = {}",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "PseudoExtras",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "PseudoExtras = group(r'\\\\\\r?\\n|\\Z', Comment, Triple)\nPseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)\n# For a given string prefix plus quotes, endpats maps it to a regex\n#  to match the remainder of that string. _prefix can be empty, for\n#  a normal single or triple quoted string (with no prefix).\nendpats = {}\nfor _prefix in _all_string_prefixes():\n    endpats[_prefix + \"'\"] = Single\n    endpats[_prefix + '\"'] = Double\n    endpats[_prefix + \"'''\"] = Single3",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "PseudoToken",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "PseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)\n# For a given string prefix plus quotes, endpats maps it to a regex\n#  to match the remainder of that string. _prefix can be empty, for\n#  a normal single or triple quoted string (with no prefix).\nendpats = {}\nfor _prefix in _all_string_prefixes():\n    endpats[_prefix + \"'\"] = Single\n    endpats[_prefix + '\"'] = Double\n    endpats[_prefix + \"'''\"] = Single3\n    endpats[_prefix + '\"\"\"'] = Double3",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "endpats",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "endpats = {}\nfor _prefix in _all_string_prefixes():\n    endpats[_prefix + \"'\"] = Single\n    endpats[_prefix + '\"'] = Double\n    endpats[_prefix + \"'''\"] = Single3\n    endpats[_prefix + '\"\"\"'] = Double3\ndel _prefix\n# A set of all of the single and triple quoted string prefixes,\n#  including the opening quotes.\nsingle_quoted = set()",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "single_quoted",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "single_quoted = set()\ntriple_quoted = set()\nfor t in _all_string_prefixes():\n    for u in (t + '\"', t + \"'\"):\n        single_quoted.add(u)\n    for u in (t + '\"\"\"', t + \"'''\"):\n        triple_quoted.add(u)\ndel t, u\ntabsize = 8\nclass TokenError(Exception): pass",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "triple_quoted",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "triple_quoted = set()\nfor t in _all_string_prefixes():\n    for u in (t + '\"', t + \"'\"):\n        single_quoted.add(u)\n    for u in (t + '\"\"\"', t + \"'''\"):\n        triple_quoted.add(u)\ndel t, u\ntabsize = 8\nclass TokenError(Exception): pass\nclass Untokenizer:",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "tabsize",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.tokenize",
        "description": "pycharm_venv.Lib.tokenize",
        "peekOfCode": "tabsize = 8\nclass TokenError(Exception): pass\nclass Untokenizer:\n    def __init__(self):\n        self.tokens = []\n        self.prev_row = 1\n        self.prev_col = 0\n        self.prev_type = None\n        self.encoding = None\n    def add_whitespace(self, start):",
        "detail": "pycharm_venv.Lib.tokenize",
        "documentation": {}
    },
    {
        "label": "_C",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "class _C:\n    def _m(self): pass\nMethodType = type(_C()._m)\nBuiltinFunctionType = type(len)\nBuiltinMethodType = type([].append)     # Same as BuiltinFunctionType\nWrapperDescriptorType = type(object.__init__)\nMethodWrapperType = type(object().__str__)\nMethodDescriptorType = type(str.join)\nClassMethodDescriptorType = type(dict.__dict__['fromkeys'])\nModuleType = type(sys)",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "DynamicClassAttribute",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "class DynamicClassAttribute:\n    \"\"\"Route attribute access on a class to __getattr__.\n    This is a descriptor, used to define attributes that act differently when\n    accessed through an instance and through a class.  Instance access remains\n    normal, but access to an attribute through a class will be routed to the\n    class's __getattr__ method; this is done by raising AttributeError.\n    This allows one to have properties active on an instance, and have virtual\n    attributes on the class with the same name.  (Enum used this between Python\n    versions 3.4 - 3.9 .)\n    Subclass from this to use a different method of accessing virtual attributes",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "_GeneratorWrapper",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "class _GeneratorWrapper:\n    # TODO: Implement this in C.\n    def __init__(self, gen):\n        self.__wrapped = gen\n        self.__isgen = gen.__class__ is GeneratorType\n        self.__name__ = getattr(gen, '__name__', None)\n        self.__qualname__ = getattr(gen, '__qualname__', None)\n    def send(self, val):\n        return self.__wrapped.send(val)\n    def throw(self, tp, *rest):",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "new_class",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "def new_class(name, bases=(), kwds=None, exec_body=None):\n    \"\"\"Create a class object dynamically using the appropriate metaclass.\"\"\"\n    resolved_bases = resolve_bases(bases)\n    meta, ns, kwds = prepare_class(name, resolved_bases, kwds)\n    if exec_body is not None:\n        exec_body(ns)\n    if resolved_bases is not bases:\n        ns['__orig_bases__'] = bases\n    return meta(name, resolved_bases, ns, **kwds)\ndef resolve_bases(bases):",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "resolve_bases",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "def resolve_bases(bases):\n    \"\"\"Resolve MRO entries dynamically as specified by PEP 560.\"\"\"\n    new_bases = list(bases)\n    updated = False\n    shift = 0\n    for i, base in enumerate(bases):\n        if isinstance(base, type):\n            continue\n        if not hasattr(base, \"__mro_entries__\"):\n            continue",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "prepare_class",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "def prepare_class(name, bases=(), kwds=None):\n    \"\"\"Call the __prepare__ method of the appropriate metaclass.\n    Returns (metaclass, namespace, kwds) as a 3-tuple\n    *metaclass* is the appropriate metaclass\n    *namespace* is the prepared class namespace\n    *kwds* is an updated copy of the passed in kwds argument with any\n    'metaclass' entry removed. If no kwds argument is passed in, this will\n    be an empty dict.\n    \"\"\"\n    if kwds is None:",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "get_original_bases",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "def get_original_bases(cls, /):\n    \"\"\"Return the class's \"original\" bases prior to modification by `__mro_entries__`.\n    Examples::\n        from typing import TypeVar, Generic, NamedTuple, TypedDict\n        T = TypeVar(\"T\")\n        class Foo(Generic[T]): ...\n        class Bar(Foo[int], float): ...\n        class Baz(list[str]): ...\n        Eggs = NamedTuple(\"Eggs\", [(\"a\", int), (\"b\", str)])\n        Spam = TypedDict(\"Spam\", {\"a\": int, \"b\": str})",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "coroutine",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "def coroutine(func):\n    \"\"\"Convert regular generator function to a coroutine.\"\"\"\n    if not callable(func):\n        raise TypeError('types.coroutine() expects a callable')\n    if (func.__class__ is FunctionType and\n        getattr(func, '__code__', None).__class__ is CodeType):\n        co_flags = func.__code__.co_flags\n        # Check if 'func' is a coroutine function.\n        # (0x180 == CO_COROUTINE | CO_ITERABLE_COROUTINE)\n        if co_flags & 0x180:",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "FunctionType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "FunctionType = type(_f)\nLambdaType = type(lambda: None)         # Same as FunctionType\nCodeType = type(_f.__code__)\nMappingProxyType = type(type.__dict__)\nSimpleNamespace = type(sys.implementation)\ndef _cell_factory():\n    a = 1\n    def f():\n        nonlocal a\n    return f.__closure__[0]",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "LambdaType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "LambdaType = type(lambda: None)         # Same as FunctionType\nCodeType = type(_f.__code__)\nMappingProxyType = type(type.__dict__)\nSimpleNamespace = type(sys.implementation)\ndef _cell_factory():\n    a = 1\n    def f():\n        nonlocal a\n    return f.__closure__[0]\nCellType = type(_cell_factory())",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "CodeType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "CodeType = type(_f.__code__)\nMappingProxyType = type(type.__dict__)\nSimpleNamespace = type(sys.implementation)\ndef _cell_factory():\n    a = 1\n    def f():\n        nonlocal a\n    return f.__closure__[0]\nCellType = type(_cell_factory())\ndef _g():",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "MappingProxyType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "MappingProxyType = type(type.__dict__)\nSimpleNamespace = type(sys.implementation)\ndef _cell_factory():\n    a = 1\n    def f():\n        nonlocal a\n    return f.__closure__[0]\nCellType = type(_cell_factory())\ndef _g():\n    yield 1",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "SimpleNamespace",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "SimpleNamespace = type(sys.implementation)\ndef _cell_factory():\n    a = 1\n    def f():\n        nonlocal a\n    return f.__closure__[0]\nCellType = type(_cell_factory())\ndef _g():\n    yield 1\nGeneratorType = type(_g())",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "CellType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "CellType = type(_cell_factory())\ndef _g():\n    yield 1\nGeneratorType = type(_g())\nasync def _c(): pass\n_c = _c()\nCoroutineType = type(_c)\n_c.close()  # Prevent ResourceWarning\nasync def _ag():\n    yield",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "GeneratorType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "GeneratorType = type(_g())\nasync def _c(): pass\n_c = _c()\nCoroutineType = type(_c)\n_c.close()  # Prevent ResourceWarning\nasync def _ag():\n    yield\n_ag = _ag()\nAsyncGeneratorType = type(_ag)\nclass _C:",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "_c",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "_c = _c()\nCoroutineType = type(_c)\n_c.close()  # Prevent ResourceWarning\nasync def _ag():\n    yield\n_ag = _ag()\nAsyncGeneratorType = type(_ag)\nclass _C:\n    def _m(self): pass\nMethodType = type(_C()._m)",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "CoroutineType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "CoroutineType = type(_c)\n_c.close()  # Prevent ResourceWarning\nasync def _ag():\n    yield\n_ag = _ag()\nAsyncGeneratorType = type(_ag)\nclass _C:\n    def _m(self): pass\nMethodType = type(_C()._m)\nBuiltinFunctionType = type(len)",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "_ag",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "_ag = _ag()\nAsyncGeneratorType = type(_ag)\nclass _C:\n    def _m(self): pass\nMethodType = type(_C()._m)\nBuiltinFunctionType = type(len)\nBuiltinMethodType = type([].append)     # Same as BuiltinFunctionType\nWrapperDescriptorType = type(object.__init__)\nMethodWrapperType = type(object().__str__)\nMethodDescriptorType = type(str.join)",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "AsyncGeneratorType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "AsyncGeneratorType = type(_ag)\nclass _C:\n    def _m(self): pass\nMethodType = type(_C()._m)\nBuiltinFunctionType = type(len)\nBuiltinMethodType = type([].append)     # Same as BuiltinFunctionType\nWrapperDescriptorType = type(object.__init__)\nMethodWrapperType = type(object().__str__)\nMethodDescriptorType = type(str.join)\nClassMethodDescriptorType = type(dict.__dict__['fromkeys'])",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "MethodType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "MethodType = type(_C()._m)\nBuiltinFunctionType = type(len)\nBuiltinMethodType = type([].append)     # Same as BuiltinFunctionType\nWrapperDescriptorType = type(object.__init__)\nMethodWrapperType = type(object().__str__)\nMethodDescriptorType = type(str.join)\nClassMethodDescriptorType = type(dict.__dict__['fromkeys'])\nModuleType = type(sys)\ntry:\n    raise TypeError",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "BuiltinFunctionType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "BuiltinFunctionType = type(len)\nBuiltinMethodType = type([].append)     # Same as BuiltinFunctionType\nWrapperDescriptorType = type(object.__init__)\nMethodWrapperType = type(object().__str__)\nMethodDescriptorType = type(str.join)\nClassMethodDescriptorType = type(dict.__dict__['fromkeys'])\nModuleType = type(sys)\ntry:\n    raise TypeError\nexcept TypeError as exc:",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "BuiltinMethodType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "BuiltinMethodType = type([].append)     # Same as BuiltinFunctionType\nWrapperDescriptorType = type(object.__init__)\nMethodWrapperType = type(object().__str__)\nMethodDescriptorType = type(str.join)\nClassMethodDescriptorType = type(dict.__dict__['fromkeys'])\nModuleType = type(sys)\ntry:\n    raise TypeError\nexcept TypeError as exc:\n    TracebackType = type(exc.__traceback__)",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "WrapperDescriptorType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "WrapperDescriptorType = type(object.__init__)\nMethodWrapperType = type(object().__str__)\nMethodDescriptorType = type(str.join)\nClassMethodDescriptorType = type(dict.__dict__['fromkeys'])\nModuleType = type(sys)\ntry:\n    raise TypeError\nexcept TypeError as exc:\n    TracebackType = type(exc.__traceback__)\n    FrameType = type(exc.__traceback__.tb_frame)",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "MethodWrapperType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "MethodWrapperType = type(object().__str__)\nMethodDescriptorType = type(str.join)\nClassMethodDescriptorType = type(dict.__dict__['fromkeys'])\nModuleType = type(sys)\ntry:\n    raise TypeError\nexcept TypeError as exc:\n    TracebackType = type(exc.__traceback__)\n    FrameType = type(exc.__traceback__.tb_frame)\nGetSetDescriptorType = type(FunctionType.__code__)",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "MethodDescriptorType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "MethodDescriptorType = type(str.join)\nClassMethodDescriptorType = type(dict.__dict__['fromkeys'])\nModuleType = type(sys)\ntry:\n    raise TypeError\nexcept TypeError as exc:\n    TracebackType = type(exc.__traceback__)\n    FrameType = type(exc.__traceback__.tb_frame)\nGetSetDescriptorType = type(FunctionType.__code__)\nMemberDescriptorType = type(FunctionType.__globals__)",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "ClassMethodDescriptorType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "ClassMethodDescriptorType = type(dict.__dict__['fromkeys'])\nModuleType = type(sys)\ntry:\n    raise TypeError\nexcept TypeError as exc:\n    TracebackType = type(exc.__traceback__)\n    FrameType = type(exc.__traceback__.tb_frame)\nGetSetDescriptorType = type(FunctionType.__code__)\nMemberDescriptorType = type(FunctionType.__globals__)\ndel sys, _f, _g, _C, _c, _ag, _cell_factory  # Not for export",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "ModuleType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "ModuleType = type(sys)\ntry:\n    raise TypeError\nexcept TypeError as exc:\n    TracebackType = type(exc.__traceback__)\n    FrameType = type(exc.__traceback__.tb_frame)\nGetSetDescriptorType = type(FunctionType.__code__)\nMemberDescriptorType = type(FunctionType.__globals__)\ndel sys, _f, _g, _C, _c, _ag, _cell_factory  # Not for export\n# Provide a PEP 3115 compliant mechanism for class creation",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "GetSetDescriptorType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "GetSetDescriptorType = type(FunctionType.__code__)\nMemberDescriptorType = type(FunctionType.__globals__)\ndel sys, _f, _g, _C, _c, _ag, _cell_factory  # Not for export\n# Provide a PEP 3115 compliant mechanism for class creation\ndef new_class(name, bases=(), kwds=None, exec_body=None):\n    \"\"\"Create a class object dynamically using the appropriate metaclass.\"\"\"\n    resolved_bases = resolve_bases(bases)\n    meta, ns, kwds = prepare_class(name, resolved_bases, kwds)\n    if exec_body is not None:\n        exec_body(ns)",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "MemberDescriptorType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "MemberDescriptorType = type(FunctionType.__globals__)\ndel sys, _f, _g, _C, _c, _ag, _cell_factory  # Not for export\n# Provide a PEP 3115 compliant mechanism for class creation\ndef new_class(name, bases=(), kwds=None, exec_body=None):\n    \"\"\"Create a class object dynamically using the appropriate metaclass.\"\"\"\n    resolved_bases = resolve_bases(bases)\n    meta, ns, kwds = prepare_class(name, resolved_bases, kwds)\n    if exec_body is not None:\n        exec_body(ns)\n    if resolved_bases is not bases:",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "GenericAlias",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "GenericAlias = type(list[int])\nUnionType = type(int | str)\nEllipsisType = type(Ellipsis)\nNoneType = type(None)\nNotImplementedType = type(NotImplemented)\ndef __getattr__(name):\n    if name == 'CapsuleType':\n        import _socket\n        return type(_socket.CAPI)\n    raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "UnionType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "UnionType = type(int | str)\nEllipsisType = type(Ellipsis)\nNoneType = type(None)\nNotImplementedType = type(NotImplemented)\ndef __getattr__(name):\n    if name == 'CapsuleType':\n        import _socket\n        return type(_socket.CAPI)\n    raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n__all__ = [n for n in globals() if n[:1] != '_']",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "EllipsisType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "EllipsisType = type(Ellipsis)\nNoneType = type(None)\nNotImplementedType = type(NotImplemented)\ndef __getattr__(name):\n    if name == 'CapsuleType':\n        import _socket\n        return type(_socket.CAPI)\n    raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n__all__ = [n for n in globals() if n[:1] != '_']\n__all__ += ['CapsuleType']",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "NoneType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "NoneType = type(None)\nNotImplementedType = type(NotImplemented)\ndef __getattr__(name):\n    if name == 'CapsuleType':\n        import _socket\n        return type(_socket.CAPI)\n    raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n__all__ = [n for n in globals() if n[:1] != '_']\n__all__ += ['CapsuleType']",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "NotImplementedType",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "NotImplementedType = type(NotImplemented)\ndef __getattr__(name):\n    if name == 'CapsuleType':\n        import _socket\n        return type(_socket.CAPI)\n    raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n__all__ = [n for n in globals() if n[:1] != '_']\n__all__ += ['CapsuleType']",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.types",
        "description": "pycharm_venv.Lib.types",
        "peekOfCode": "__all__ = [n for n in globals() if n[:1] != '_']\n__all__ += ['CapsuleType']",
        "detail": "pycharm_venv.Lib.types",
        "documentation": {}
    },
    {
        "label": "_OptionError",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.warnings",
        "description": "pycharm_venv.Lib.warnings",
        "peekOfCode": "class _OptionError(Exception):\n    \"\"\"Exception used by option processing helpers.\"\"\"\n    pass\n# Helper to process -W options passed via sys.warnoptions\ndef _processoptions(args):\n    for arg in args:\n        try:\n            _setoption(arg)\n        except _OptionError as msg:\n            print(\"Invalid -W option ignored:\", msg, file=sys.stderr)",
        "detail": "pycharm_venv.Lib.warnings",
        "documentation": {}
    },
    {
        "label": "WarningMessage",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.warnings",
        "description": "pycharm_venv.Lib.warnings",
        "peekOfCode": "class WarningMessage(object):\n    _WARNING_DETAILS = (\"message\", \"category\", \"filename\", \"lineno\", \"file\",\n                        \"line\", \"source\")\n    def __init__(self, message, category, filename, lineno, file=None,\n                 line=None, source=None):\n        self.message = message\n        self.category = category\n        self.filename = filename\n        self.lineno = lineno\n        self.file = file",
        "detail": "pycharm_venv.Lib.warnings",
        "documentation": {}
    },
    {
        "label": "catch_warnings",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.warnings",
        "description": "pycharm_venv.Lib.warnings",
        "peekOfCode": "class catch_warnings(object):\n    \"\"\"A context manager that copies and restores the warnings filter upon\n    exiting the context.\n    The 'record' argument specifies whether warnings should be captured by a\n    custom implementation of warnings.showwarning() and be appended to a list\n    returned by the context manager. Otherwise None is returned by the context\n    manager. The objects appended to the list are arguments whose attributes\n    mirror the arguments to showwarning().\n    The 'module' argument is to specify an alternative module to the module\n    named 'warnings' and imported under that name. This argument is only useful",
        "detail": "pycharm_venv.Lib.warnings",
        "documentation": {}
    },
    {
        "label": "deprecated",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.warnings",
        "description": "pycharm_venv.Lib.warnings",
        "peekOfCode": "class deprecated:\n    \"\"\"Indicate that a class, function or overload is deprecated.\n    When this decorator is applied to an object, the type checker\n    will generate a diagnostic on usage of the deprecated object.\n    Usage:\n        @deprecated(\"Use B instead\")\n        class A:\n            pass\n        @deprecated(\"Use g instead\")\n        def f():",
        "detail": "pycharm_venv.Lib.warnings",
        "documentation": {}
    },
    {
        "label": "showwarning",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.warnings",
        "description": "pycharm_venv.Lib.warnings",
        "peekOfCode": "def showwarning(message, category, filename, lineno, file=None, line=None):\n    \"\"\"Hook to write a warning to a file; replace if you like.\"\"\"\n    msg = WarningMessage(message, category, filename, lineno, file, line)\n    _showwarnmsg_impl(msg)\ndef formatwarning(message, category, filename, lineno, line=None):\n    \"\"\"Function to format a warning the standard way.\"\"\"\n    msg = WarningMessage(message, category, filename, lineno, None, line)\n    return _formatwarnmsg_impl(msg)\ndef _showwarnmsg_impl(msg):\n    file = msg.file",
        "detail": "pycharm_venv.Lib.warnings",
        "documentation": {}
    },
    {
        "label": "formatwarning",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.warnings",
        "description": "pycharm_venv.Lib.warnings",
        "peekOfCode": "def formatwarning(message, category, filename, lineno, line=None):\n    \"\"\"Function to format a warning the standard way.\"\"\"\n    msg = WarningMessage(message, category, filename, lineno, None, line)\n    return _formatwarnmsg_impl(msg)\ndef _showwarnmsg_impl(msg):\n    file = msg.file\n    if file is None:\n        file = sys.stderr\n        if file is None:\n            # sys.stderr is None when run with pythonw.exe:",
        "detail": "pycharm_venv.Lib.warnings",
        "documentation": {}
    },
    {
        "label": "filterwarnings",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.warnings",
        "description": "pycharm_venv.Lib.warnings",
        "peekOfCode": "def filterwarnings(action, message=\"\", category=Warning, module=\"\", lineno=0,\n                   append=False):\n    \"\"\"Insert an entry into the list of warnings filters (at the front).\n    'action' -- one of \"error\", \"ignore\", \"always\", \"default\", \"module\",\n                or \"once\"\n    'message' -- a regex that the warning message must match\n    'category' -- a class that the warning must be a subclass of\n    'module' -- a regex that the module name must match\n    'lineno' -- an integer line number, 0 matches all warnings\n    'append' -- if true, append to the list of filters",
        "detail": "pycharm_venv.Lib.warnings",
        "documentation": {}
    },
    {
        "label": "simplefilter",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.warnings",
        "description": "pycharm_venv.Lib.warnings",
        "peekOfCode": "def simplefilter(action, category=Warning, lineno=0, append=False):\n    \"\"\"Insert a simple entry into the list of warnings filters (at the front).\n    A simple filter matches all modules and messages.\n    'action' -- one of \"error\", \"ignore\", \"always\", \"default\", \"module\",\n                or \"once\"\n    'category' -- a class that the warning must be a subclass of\n    'lineno' -- an integer line number, 0 matches all warnings\n    'append' -- if true, append to the list of filters\n    \"\"\"\n    if action not in {\"error\", \"ignore\", \"always\", \"default\", \"module\", \"once\"}:",
        "detail": "pycharm_venv.Lib.warnings",
        "documentation": {}
    },
    {
        "label": "resetwarnings",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.warnings",
        "description": "pycharm_venv.Lib.warnings",
        "peekOfCode": "def resetwarnings():\n    \"\"\"Clear the list of warning filters, so that no filters are active.\"\"\"\n    filters[:] = []\n    _filters_mutated()\nclass _OptionError(Exception):\n    \"\"\"Exception used by option processing helpers.\"\"\"\n    pass\n# Helper to process -W options passed via sys.warnoptions\ndef _processoptions(args):\n    for arg in args:",
        "detail": "pycharm_venv.Lib.warnings",
        "documentation": {}
    },
    {
        "label": "warn",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.warnings",
        "description": "pycharm_venv.Lib.warnings",
        "peekOfCode": "def warn(message, category=None, stacklevel=1, source=None,\n         *, skip_file_prefixes=()):\n    \"\"\"Issue a warning, or maybe ignore it or raise an exception.\"\"\"\n    # Check if message is already a Warning object\n    if isinstance(message, Warning):\n        category = message.__class__\n    # Check category argument\n    if category is None:\n        category = UserWarning\n    if not (isinstance(category, type) and issubclass(category, Warning)):",
        "detail": "pycharm_venv.Lib.warnings",
        "documentation": {}
    },
    {
        "label": "warn_explicit",
        "kind": 2,
        "importPath": "pycharm_venv.Lib.warnings",
        "description": "pycharm_venv.Lib.warnings",
        "peekOfCode": "def warn_explicit(message, category, filename, lineno,\n                  module=None, registry=None, module_globals=None,\n                  source=None):\n    lineno = int(lineno)\n    if module is None:\n        module = filename or \"<unknown>\"\n        if module[-3:].lower() == \".py\":\n            module = module[:-3] # XXX What about leading pathname?\n    if registry is None:\n        registry = {}",
        "detail": "pycharm_venv.Lib.warnings",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.warnings",
        "description": "pycharm_venv.Lib.warnings",
        "peekOfCode": "__all__ = [\"warn\", \"warn_explicit\", \"showwarning\",\n           \"formatwarning\", \"filterwarnings\", \"simplefilter\",\n           \"resetwarnings\", \"catch_warnings\", \"deprecated\"]\ndef showwarning(message, category, filename, lineno, file=None, line=None):\n    \"\"\"Hook to write a warning to a file; replace if you like.\"\"\"\n    msg = WarningMessage(message, category, filename, lineno, file, line)\n    _showwarnmsg_impl(msg)\ndef formatwarning(message, category, filename, lineno, line=None):\n    \"\"\"Function to format a warning the standard way.\"\"\"\n    msg = WarningMessage(message, category, filename, lineno, None, line)",
        "detail": "pycharm_venv.Lib.warnings",
        "documentation": {}
    },
    {
        "label": "_showwarning_orig",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.warnings",
        "description": "pycharm_venv.Lib.warnings",
        "peekOfCode": "_showwarning_orig = showwarning\ndef _showwarnmsg(msg):\n    \"\"\"Hook to write a warning to a file; replace if you like.\"\"\"\n    try:\n        sw = showwarning\n    except NameError:\n        pass\n    else:\n        if sw is not _showwarning_orig:\n            # warnings.showwarning() was replaced",
        "detail": "pycharm_venv.Lib.warnings",
        "documentation": {}
    },
    {
        "label": "_formatwarning_orig",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.warnings",
        "description": "pycharm_venv.Lib.warnings",
        "peekOfCode": "_formatwarning_orig = formatwarning\ndef _formatwarnmsg(msg):\n    \"\"\"Function to format a warning the standard way.\"\"\"\n    try:\n        fw = formatwarning\n    except NameError:\n        pass\n    else:\n        if fw is not _formatwarning_orig:\n            # warnings.formatwarning() was replaced",
        "detail": "pycharm_venv.Lib.warnings",
        "documentation": {}
    },
    {
        "label": "_DEPRECATED_MSG",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.warnings",
        "description": "pycharm_venv.Lib.warnings",
        "peekOfCode": "_DEPRECATED_MSG = \"{name!r} is deprecated and slated for removal in Python {remove}\"\ndef _deprecated(name, message=_DEPRECATED_MSG, *, remove, _version=sys.version_info):\n    \"\"\"Warn that *name* is deprecated or should be removed.\n    RuntimeError is raised if *remove* specifies a major/minor tuple older than\n    the current Python version or the same version but past the alpha.\n    The *message* argument is formatted with *name* and *remove* as a Python\n    version tuple (e.g. (3, 11)).\n    \"\"\"\n    remove_formatted = f\"{remove[0]}.{remove[1]}\"\n    if (_version[:2] > remove) or (_version[:2] == remove and _version[3] != \"alpha\"):",
        "detail": "pycharm_venv.Lib.warnings",
        "documentation": {}
    },
    {
        "label": "WeakMethod",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.weakref",
        "description": "pycharm_venv.Lib.weakref",
        "peekOfCode": "class WeakMethod(ref):\n    \"\"\"\n    A custom `weakref.ref` subclass which simulates a weak reference to\n    a bound method, working around the lifetime problem of bound methods.\n    \"\"\"\n    __slots__ = \"_func_ref\", \"_meth_type\", \"_alive\", \"__weakref__\"\n    def __new__(cls, meth, callback=None):\n        try:\n            obj = meth.__self__\n            func = meth.__func__",
        "detail": "pycharm_venv.Lib.weakref",
        "documentation": {}
    },
    {
        "label": "WeakValueDictionary",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.weakref",
        "description": "pycharm_venv.Lib.weakref",
        "peekOfCode": "class WeakValueDictionary(_collections_abc.MutableMapping):\n    \"\"\"Mapping class that references values weakly.\n    Entries in the dictionary will be discarded when no strong\n    reference to the value exists anymore\n    \"\"\"\n    # We inherit the constructor without worrying about the input\n    # dictionary; since it uses our .update() method, we get the right\n    # checks (if the other dictionary is a WeakValueDictionary,\n    # objects are unwrapped on the way out, and we always wrap on the\n    # way in).",
        "detail": "pycharm_venv.Lib.weakref",
        "documentation": {}
    },
    {
        "label": "KeyedRef",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.weakref",
        "description": "pycharm_venv.Lib.weakref",
        "peekOfCode": "class KeyedRef(ref):\n    \"\"\"Specialized reference that includes a key corresponding to the value.\n    This is used in the WeakValueDictionary to avoid having to create\n    a function object for each key stored in the mapping.  A shared\n    callback object can use the 'key' attribute of a KeyedRef instead\n    of getting a reference to the key from an enclosing scope.\n    \"\"\"\n    __slots__ = \"key\",\n    def __new__(type, ob, callback, key):\n        self = ref.__new__(type, ob, callback)",
        "detail": "pycharm_venv.Lib.weakref",
        "documentation": {}
    },
    {
        "label": "WeakKeyDictionary",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.weakref",
        "description": "pycharm_venv.Lib.weakref",
        "peekOfCode": "class WeakKeyDictionary(_collections_abc.MutableMapping):\n    \"\"\" Mapping class that references keys weakly.\n    Entries in the dictionary will be discarded when there is no\n    longer a strong reference to the key. This can be used to\n    associate additional data with an object owned by other parts of\n    an application without adding attributes to those objects. This\n    can be especially useful with objects that override attribute\n    accesses.\n    \"\"\"\n    def __init__(self, dict=None):",
        "detail": "pycharm_venv.Lib.weakref",
        "documentation": {}
    },
    {
        "label": "finalize",
        "kind": 6,
        "importPath": "pycharm_venv.Lib.weakref",
        "description": "pycharm_venv.Lib.weakref",
        "peekOfCode": "class finalize:\n    \"\"\"Class for finalization of weakrefable objects\n    finalize(obj, func, *args, **kwargs) returns a callable finalizer\n    object which will be called when obj is garbage collected. The\n    first time the finalizer is called it evaluates func(*arg, **kwargs)\n    and returns the result. After this the finalizer is dead, and\n    calling it just returns None.\n    When the program exits any remaining finalizers for which the\n    atexit attribute is true will be run in reverse order of creation.\n    By default atexit is true.",
        "detail": "pycharm_venv.Lib.weakref",
        "documentation": {}
    },
    {
        "label": "ProxyTypes",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.weakref",
        "description": "pycharm_venv.Lib.weakref",
        "peekOfCode": "ProxyTypes = (ProxyType, CallableProxyType)\n__all__ = [\"ref\", \"proxy\", \"getweakrefcount\", \"getweakrefs\",\n           \"WeakKeyDictionary\", \"ReferenceType\", \"ProxyType\",\n           \"CallableProxyType\", \"ProxyTypes\", \"WeakValueDictionary\",\n           \"WeakSet\", \"WeakMethod\", \"finalize\"]\n_collections_abc.MutableSet.register(WeakSet)\nclass WeakMethod(ref):\n    \"\"\"\n    A custom `weakref.ref` subclass which simulates a weak reference to\n    a bound method, working around the lifetime problem of bound methods.",
        "detail": "pycharm_venv.Lib.weakref",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib.weakref",
        "description": "pycharm_venv.Lib.weakref",
        "peekOfCode": "__all__ = [\"ref\", \"proxy\", \"getweakrefcount\", \"getweakrefs\",\n           \"WeakKeyDictionary\", \"ReferenceType\", \"ProxyType\",\n           \"CallableProxyType\", \"ProxyTypes\", \"WeakValueDictionary\",\n           \"WeakSet\", \"WeakMethod\", \"finalize\"]\n_collections_abc.MutableSet.register(WeakSet)\nclass WeakMethod(ref):\n    \"\"\"\n    A custom `weakref.ref` subclass which simulates a weak reference to\n    a bound method, working around the lifetime problem of bound methods.\n    \"\"\"",
        "detail": "pycharm_venv.Lib.weakref",
        "documentation": {}
    },
    {
        "label": "_IterationGuard",
        "kind": 6,
        "importPath": "pycharm_venv.Lib._weakrefset",
        "description": "pycharm_venv.Lib._weakrefset",
        "peekOfCode": "class _IterationGuard:\n    # This context manager registers itself in the current iterators of the\n    # weak container, such as to delay all removals until the context manager\n    # exits.\n    # This technique should be relatively thread-safe (since sets are).\n    def __init__(self, weakcontainer):\n        # Don't create cycles\n        self.weakcontainer = ref(weakcontainer)\n    def __enter__(self):\n        w = self.weakcontainer()",
        "detail": "pycharm_venv.Lib._weakrefset",
        "documentation": {}
    },
    {
        "label": "WeakSet",
        "kind": 6,
        "importPath": "pycharm_venv.Lib._weakrefset",
        "description": "pycharm_venv.Lib._weakrefset",
        "peekOfCode": "class WeakSet:\n    def __init__(self, data=None):\n        self.data = set()\n        def _remove(item, selfref=ref(self)):\n            self = selfref()\n            if self is not None:\n                if self._iterating:\n                    self._pending_removals.append(item)\n                else:\n                    self.data.discard(item)",
        "detail": "pycharm_venv.Lib._weakrefset",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "pycharm_venv.Lib._weakrefset",
        "description": "pycharm_venv.Lib._weakrefset",
        "peekOfCode": "__all__ = ['WeakSet']\nclass _IterationGuard:\n    # This context manager registers itself in the current iterators of the\n    # weak container, such as to delay all removals until the context manager\n    # exits.\n    # This technique should be relatively thread-safe (since sets are).\n    def __init__(self, weakcontainer):\n        # Don't create cycles\n        self.weakcontainer = ref(weakcontainer)\n    def __enter__(self):",
        "detail": "pycharm_venv.Lib._weakrefset",
        "documentation": {}
    }
]